package main

import (
	"fmt"
	"log"
	"os"

	"github.com/kpango/glg"
)

const (
	cimguiGoPackagePath = "github.com/AllenDang/cimgui-go"
	generatorInfo       = "// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.\n// DO NOT EDIT.\n\n"
	goPackageHeader     = generatorInfo + "package %[1]s\n\nimport (\n\"" + cimguiGoPackagePath + "/datautils\"\n\t\"" + cimguiGoPackagePath + "/%[2]s\"\n)\n\n"
	cppFileHeader       = generatorInfo
)

// this cextracts enums and structs names from json file.
func getEnumAndStructNames(enumJsonBytes []byte, context *Context) (enumNames []EnumIdentifier, structNames []CIdentifier, err error) {
	enums, err := getEnumDefs(enumJsonBytes)
	if err != nil {
		return nil, nil, fmt.Errorf("cannot get enum definitions: %w", err)
	}

	structs, err := getStructDefs(enumJsonBytes)
	if err != nil {
		return nil, nil, fmt.Errorf("cannot get struct definitions: %w", err)
	}

	for _, e := range enums {
		enumNames = append(enumNames, e.Name)
	}

	for _, s := range structs {
		if shouldSkipStruct := context.preset.SkipStructs[s.Name]; !shouldSkipStruct {
			structNames = append(structNames, s.Name)
		}
	}

	return
}

func validateFiles(f *flags) {
	stat, err := os.Stat(f.defJsonPath)
	if err != nil || stat.IsDir() {
		glg.Fatal("Invalid definitions json file path")
	}

	stat, err = os.Stat(f.enumsJsonpath)
	if err != nil || stat.IsDir() {
		glg.Fatal("Invalid enum json file path")
	}

	stat, err = os.Stat(f.typedefsJsonpath)
	if err != nil || stat.IsDir() {
		glg.Fatalf("Invalid typedefs json file path: %s", f.typedefsJsonpath)
	}
}

// this will store json data processed by appropiate pre-rocessors
type Context struct {
	funcs    []FuncDef
	structs  []StructDef
	enums    []EnumDef
	typedefs *Typedefs

	prefix string

	funcNames     map[CIdentifier]bool
	enumNames     map[CIdentifier]bool
	structNames   map[CIdentifier]bool
	typedefsNames map[CIdentifier]bool

	arrayIndexGetters map[CIdentifier]CIdentifier

	refStructNames map[CIdentifier]bool
	refEnumNames   map[CIdentifier]bool
	refTypedefs    map[CIdentifier]bool

	// TODO: might want to remove this
	flags *flags

	preset *Preset
}

func main() {
	flags := parse()
	validateFiles(flags)

	jsonData, err := loadData(flags)
	if err != nil {
		glg.Fatalf("cannot load data: %v", err)
	}

	context, err := jsonData.parseJson()
	if err != nil {
		glg.Fatalf("cannot parse json: %v", err)
	}

	context.prefix = flags.prefix
	context.flags = flags

	// 1. Generate code
	// 1.1. Generate Go Enums
	enumNames, err := generateGoEnums(flags.prefix, context.enums, context)
	if err != nil {
		glg.Fatalf("Generating enum names: %v", err)
	}

	context.enumNames = MergeMaps(SliceToMap(enumNames), context.refEnumNames)

	// 1.2. Generate Go typedefs
	callbacks, err := GenerateTypedefs(context.typedefs, context.structs, context)
	if err != nil {
		log.Panic(err)
	}

	context.structNames = SliceToMap(callbacks)

	// 1.3. Generate C wrapper
	validFuncs, err := generateCppWrapper(flags.prefix, flags.include, context.funcs, context)
	if err != nil {
		log.Panic(err)
	}

	// 1.3.1. Generate Struct accessors in C
	structAccessorFuncs, err := generateCppStructsAccessor(flags.prefix, validFuncs, context.structs, context)
	if err != nil {
		log.Panic(err)
	}

	// This variable stores funcs that needs to be written to GO now.
	validFuncs = append(validFuncs, structAccessorFuncs...)

	if err := GenerateGoFuncs(validFuncs, context); err != nil {
		log.Panic(err)
	}
}

func getGoPackageHeader(ctx *Context) string {
	return fmt.Sprintf(goPackageHeader, ctx.flags.packageName, ctx.flags.refPackageName)
}

func prefixGoPackage(t, sourcePackage GoIdentifier, ctx *Context) GoIdentifier {
	if sourcePackage == GoIdentifier(ctx.flags.packageName) || sourcePackage == "" {
		return t
	}

	isPtr := HasPrefix(t, "*")
	t = TrimPrefix(t, "*")
	t = sourcePackage + "." + t

	if isPtr {
		t = "*" + t
	}

	return t
}
