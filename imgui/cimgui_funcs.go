// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include "../imgui/extra_types.h"
// #include "cimgui_structs_accessor.h"
// #include "cimgui_wrapper.h"
// #include "stdlib.h"
import "C"
import (
	"unsafe"

	"github.com/AllenDang/cimgui-go/internal"
	"github.com/AllenDang/cimgui-go/utils/vectors"
)

func (self *BitVector) InternalClear() {
	selfArg, selfFin := self.Handle()
	C.ImBitVector_Clear(internal.ReinterpretCast[*C.ImBitVector](selfArg))

	selfFin()
}

func (self *BitVector) InternalClearBit(n int32) {
	selfArg, selfFin := self.Handle()
	C.ImBitVector_ClearBit(internal.ReinterpretCast[*C.ImBitVector](selfArg), C.int(n))

	selfFin()
}

func (self *BitVector) InternalCreate(sz int32) {
	selfArg, selfFin := self.Handle()
	C.ImBitVector_Create(internal.ReinterpretCast[*C.ImBitVector](selfArg), C.int(sz))

	selfFin()
}

func (self *BitVector) InternalSetBit(n int32) {
	selfArg, selfFin := self.Handle()
	C.ImBitVector_SetBit(internal.ReinterpretCast[*C.ImBitVector](selfArg), C.int(n))

	selfFin()
}

func (self *BitVector) InternalTestBit(n int32) bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImBitVector_TestBit(internal.ReinterpretCast[*C.ImBitVector](selfArg), C.int(n)) == C.bool(true)
}

// ColorHSVV parameter default value hint:
// a: 1.0f
func ColorHSVV(h float32, s float32, v float32, a float32) Color {
	pOut := new(Color)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.ImColor_HSV(internal.ReinterpretCast[*C.ImColor](pOutArg), C.float(h), C.float(s), C.float(v), C.float(a))

	pOutFin()

	return *pOut
}

// SetHSVV parameter default value hint:
// a: 1.0f
func (self *Color) SetHSVV(h float32, s float32, v float32, a float32) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImColor_SetHSV(internal.ReinterpretCast[*C.ImColor](selfArg), C.float(h), C.float(s), C.float(v), C.float(a))

	selfFin()
}

func (self *Color) Destroy() {
	selfArg, selfFin := internal.Wrap(self)
	C.ImColor_destroy(internal.ReinterpretCast[*C.ImColor](selfArg))

	selfFin()
}

func (self *DrawCmd) TexID() TextureID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextureIDFromC(func() *C.ImTextureID {
		result := C.ImDrawCmd_GetTexID(internal.ReinterpretCast[*C.ImDrawCmd](selfArg))
		return &result
	}())
}

// Also ensure our padding fields are zeroed
func NewDrawCmd() *DrawCmd {
	return NewDrawCmdFromC(C.ImDrawCmd_ImDrawCmd())
}

func (self *DrawCmd) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImDrawCmd_destroy(internal.ReinterpretCast[*C.ImDrawCmd](selfArg))

	selfFin()
}

func InternalNewDrawDataBuilder() *DrawDataBuilder {
	return NewDrawDataBuilderFromC(C.ImDrawDataBuilder_ImDrawDataBuilder())
}

func (self *DrawDataBuilder) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImDrawDataBuilder_destroy(internal.ReinterpretCast[*C.ImDrawDataBuilder](selfArg))

	selfFin()
}

// Helper to add an external draw list into an existing ImDrawData.
func (self *DrawData) AddDrawList(draw_list *DrawList) {
	selfArg, selfFin := self.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	C.ImDrawData_AddDrawList(internal.ReinterpretCast[*C.ImDrawData](selfArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg))

	selfFin()
	draw_listFin()
}

func (self *DrawData) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImDrawData_Clear(internal.ReinterpretCast[*C.ImDrawData](selfArg))

	selfFin()
}

// Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
func (self *DrawData) DeIndexAllBuffers() {
	selfArg, selfFin := self.Handle()
	C.ImDrawData_DeIndexAllBuffers(internal.ReinterpretCast[*C.ImDrawData](selfArg))

	selfFin()
}

func NewDrawData() *DrawData {
	return NewDrawDataFromC(C.ImDrawData_ImDrawData())
}

// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
func (self *DrawData) ScaleClipRects(fb_scale Vec2) {
	selfArg, selfFin := self.Handle()
	C.ImDrawData_ScaleClipRects(internal.ReinterpretCast[*C.ImDrawData](selfArg), internal.ReinterpretCast[C.ImVec2](fb_scale.ToC()))

	selfFin()
}

func (self *DrawData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImDrawData_destroy(internal.ReinterpretCast[*C.ImDrawData](selfArg))

	selfFin()
}

func InternalNewDrawListSharedData() *DrawListSharedData {
	return NewDrawListSharedDataFromC(C.ImDrawListSharedData_ImDrawListSharedData())
}

func (self *DrawListSharedData) InternalSetCircleTessellationMaxError(max_error float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawListSharedData_SetCircleTessellationMaxError(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg), C.float(max_error))

	selfFin()
}

func (self *DrawListSharedData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImDrawListSharedData_destroy(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg))

	selfFin()
}

// Do not clear Channels[] so our allocations are reused next frame
func (self *DrawListSplitter) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImDrawListSplitter_Clear(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg))

	selfFin()
}

func (self *DrawListSplitter) ClearFreeMemory() {
	selfArg, selfFin := self.Handle()
	C.ImDrawListSplitter_ClearFreeMemory(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg))

	selfFin()
}

func NewDrawListSplitter() *DrawListSplitter {
	return NewDrawListSplitterFromC(C.ImDrawListSplitter_ImDrawListSplitter())
}

func (self *DrawListSplitter) Merge(draw_list *DrawList) {
	selfArg, selfFin := self.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	C.ImDrawListSplitter_Merge(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg))

	selfFin()
	draw_listFin()
}

func (self *DrawListSplitter) SetCurrentChannel(draw_list *DrawList, channel_idx int32) {
	selfArg, selfFin := self.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	C.ImDrawListSplitter_SetCurrentChannel(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.int(channel_idx))

	selfFin()
	draw_listFin()
}

func (self *DrawListSplitter) Split(draw_list *DrawList, count int32) {
	selfArg, selfFin := self.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	C.ImDrawListSplitter_Split(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.int(count))

	selfFin()
	draw_listFin()
}

func (self *DrawListSplitter) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImDrawListSplitter_destroy(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg))

	selfFin()
}

// Cubic Bezier (4 control points)
// AddBezierCubicV parameter default value hint:
// num_segments: 0
func (self *DrawList) AddBezierCubicV(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32, thickness float32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddBezierCubic(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), C.ImU32(col), C.float(thickness), C.int(num_segments))

	selfFin()
}

// Quadratic Bezier (3 control points)
// AddBezierQuadraticV parameter default value hint:
// num_segments: 0
func (self *DrawList) AddBezierQuadraticV(p1 Vec2, p2 Vec2, p3 Vec2, col uint32, thickness float32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddBezierQuadratic(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), C.ImU32(col), C.float(thickness), C.int(num_segments))

	selfFin()
}

// AddCallbackV parameter default value hint:
// userdata_size: 0
func (self *DrawList) AddCallbackV(callback DrawCallback, userdata uintptr, userdata_size uint64) {
	selfArg, selfFin := self.Handle()
	callbackArg, callbackFin := callback.C()
	C.wrap_ImDrawList_AddCallbackV(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImDrawCallback](callbackArg), C.uintptr_t(userdata), C.xulong(userdata_size))

	selfFin()
	callbackFin()
}

// AddCircleV parameter default value hint:
// num_segments: 0
// thickness: 1.0f
func (self *DrawList) AddCircleV(center Vec2, radius float32, col uint32, num_segments int32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddCircle(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.ImU32(col), C.int(num_segments), C.float(thickness))

	selfFin()
}

// AddCircleFilledV parameter default value hint:
// num_segments: 0
func (self *DrawList) AddCircleFilledV(center Vec2, radius float32, col uint32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddCircleFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.ImU32(col), C.int(num_segments))

	selfFin()
}

func (self *DrawList) AddConcavePolyFilled(points *Vec2, num_points int32, col uint32) {
	selfArg, selfFin := self.Handle()
	pointsArg, pointsFin := internal.Wrap(points)
	C.ImDrawList_AddConcavePolyFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[*C.ImVec2](pointsArg), C.int(num_points), C.ImU32(col))

	selfFin()
	pointsFin()
}

func (self *DrawList) AddConvexPolyFilled(points *Vec2, num_points int32, col uint32) {
	selfArg, selfFin := self.Handle()
	pointsArg, pointsFin := internal.Wrap(points)
	C.ImDrawList_AddConvexPolyFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[*C.ImVec2](pointsArg), C.int(num_points), C.ImU32(col))

	selfFin()
	pointsFin()
}

// This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
func (self *DrawList) AddDrawCmd() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddDrawCmd(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

// AddEllipseV parameter default value hint:
// rot: 0.0f
// num_segments: 0
// thickness: 1.0f
func (self *DrawList) AddEllipseV(center Vec2, radius Vec2, col uint32, rot float32, num_segments int32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddEllipse(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), internal.ReinterpretCast[C.ImVec2](radius.ToC()), C.ImU32(col), C.float(rot), C.int(num_segments), C.float(thickness))

	selfFin()
}

// AddEllipseFilledV parameter default value hint:
// rot: 0.0f
// num_segments: 0
func (self *DrawList) AddEllipseFilledV(center Vec2, radius Vec2, col uint32, rot float32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddEllipseFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), internal.ReinterpretCast[C.ImVec2](radius.ToC()), C.ImU32(col), C.float(rot), C.int(num_segments))

	selfFin()
}

// AddImageV parameter default value hint:
// uv_min: ImVec2(0,0)
// uv_max: ImVec2(1,1)
// col: 4294967295
func (self *DrawList) AddImageV(user_texture_id TextureID, p_min Vec2, p_max Vec2, uv_min Vec2, uv_max Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.ImDrawList_AddImage(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), internal.ReinterpretCast[C.ImVec2](uv_min.ToC()), internal.ReinterpretCast[C.ImVec2](uv_max.ToC()), C.ImU32(col))

	selfFin()
	user_texture_idFin()
}

// AddImageQuadV parameter default value hint:
// uv1: ImVec2(0,0)
// uv2: ImVec2(1,0)
// uv3: ImVec2(1,1)
// uv4: ImVec2(0,1)
// col: 4294967295
func (self *DrawList) AddImageQuadV(user_texture_id TextureID, p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, uv1 Vec2, uv2 Vec2, uv3 Vec2, uv4 Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.ImDrawList_AddImageQuad(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), internal.ReinterpretCast[C.ImVec2](uv1.ToC()), internal.ReinterpretCast[C.ImVec2](uv2.ToC()), internal.ReinterpretCast[C.ImVec2](uv3.ToC()), internal.ReinterpretCast[C.ImVec2](uv4.ToC()), C.ImU32(col))

	selfFin()
	user_texture_idFin()
}

// AddImageRoundedV parameter default value hint:
// flags: 0
func (self *DrawList) AddImageRoundedV(user_texture_id TextureID, p_min Vec2, p_max Vec2, uv_min Vec2, uv_max Vec2, col uint32, rounding float32, flags DrawFlags) {
	selfArg, selfFin := self.Handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.ImDrawList_AddImageRounded(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), internal.ReinterpretCast[C.ImVec2](uv_min.ToC()), internal.ReinterpretCast[C.ImVec2](uv_max.ToC()), C.ImU32(col), C.float(rounding), C.ImDrawFlags(flags))

	selfFin()
	user_texture_idFin()
}

// AddLineV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddLineV(p1 Vec2, p2 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddLine(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), C.ImU32(col), C.float(thickness))

	selfFin()
}

// AddNgonV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddNgonV(center Vec2, radius float32, col uint32, num_segments int32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddNgon(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.ImU32(col), C.int(num_segments), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddNgonFilled(center Vec2, radius float32, col uint32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddNgonFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.ImU32(col), C.int(num_segments))

	selfFin()
}

func (self *DrawList) AddPolyline(points *Vec2, num_points int32, col uint32, flags DrawFlags, thickness float32) {
	selfArg, selfFin := self.Handle()
	pointsArg, pointsFin := internal.Wrap(points)
	C.ImDrawList_AddPolyline(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[*C.ImVec2](pointsArg), C.int(num_points), C.ImU32(col), C.ImDrawFlags(flags), C.float(thickness))

	selfFin()
	pointsFin()
}

// AddQuadV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddQuadV(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddQuad(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddQuadFilled(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddQuadFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), C.ImU32(col))

	selfFin()
}

// a: upper-left, b: lower-right (== upper-left + size)
// AddRectV parameter default value hint:
// rounding: 0.0f
// flags: 0
// thickness: 1.0f
func (self *DrawList) AddRectV(p_min Vec2, p_max Vec2, col uint32, rounding float32, flags DrawFlags, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddRect(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(col), C.float(rounding), C.ImDrawFlags(flags), C.float(thickness))

	selfFin()
}

// a: upper-left, b: lower-right (== upper-left + size)
// AddRectFilledV parameter default value hint:
// rounding: 0.0f
// flags: 0
func (self *DrawList) AddRectFilledV(p_min Vec2, p_max Vec2, col uint32, rounding float32, flags DrawFlags) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddRectFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(col), C.float(rounding), C.ImDrawFlags(flags))

	selfFin()
}

func (self *DrawList) AddRectFilledMultiColor(p_min Vec2, p_max Vec2, col_upr_left uint32, col_upr_right uint32, col_bot_right uint32, col_bot_left uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddRectFilledMultiColor(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(col_upr_left), C.ImU32(col_upr_right), C.ImU32(col_bot_right), C.ImU32(col_bot_left))

	selfFin()
}

// AddTextFontPtrV parameter default value hint:
// wrap_width: 0.0f
// cpu_fine_clip_rect: NULL
func (self *DrawList) AddTextFontPtrV(font *Font, font_size float32, pos Vec2, col uint32, text_begin string, wrap_width float32, cpu_fine_clip_rect *Vec4) {
	selfArg, selfFin := self.Handle()
	fontArg, fontFin := font.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	cpu_fine_clip_rectArg, cpu_fine_clip_rectFin := internal.Wrap(cpu_fine_clip_rect)
	C.wrap_ImDrawList_AddText_FontPtrV(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[*C.ImFont](fontArg), C.float(font_size), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), text_beginArg, C.float(wrap_width), internal.ReinterpretCast[*C.ImVec4](cpu_fine_clip_rectArg))

	selfFin()
	fontFin()
	text_beginFin()
	cpu_fine_clip_rectFin()
}

// AddTextVec2V parameter default value hint:
func (self *DrawList) AddTextVec2V(pos Vec2, col uint32, text_begin string) {
	selfArg, selfFin := self.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	C.wrap_ImDrawList_AddText_Vec2V(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), text_beginArg)

	selfFin()
	text_beginFin()
}

// AddTriangleV parameter default value hint:
// thickness: 1.0f
func (self *DrawList) AddTriangleV(p1 Vec2, p2 Vec2, p3 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddTriangle(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddTriangleFilled(p1 Vec2, p2 Vec2, p3 Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_AddTriangleFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) ChannelsMerge() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_ChannelsMerge(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) ChannelsSetCurrent(n int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_ChannelsSetCurrent(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.int(n))

	selfFin()
}

func (self *DrawList) ChannelsSplit(count int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_ChannelsSplit(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.int(count))

	selfFin()
}

// Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.
func (self *DrawList) CloneOutput() *DrawList {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDrawListFromC(C.ImDrawList_CloneOutput(internal.ReinterpretCast[*C.ImDrawList](selfArg)))
}

func (self *DrawList) ClipRectMax() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImDrawList_GetClipRectMax(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImDrawList](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *DrawList) ClipRectMin() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImDrawList_GetClipRectMin(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImDrawList](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func NewDrawList(shared_data *DrawListSharedData) *DrawList {
	shared_dataArg, shared_dataFin := shared_data.Handle()

	defer func() {
		shared_dataFin()
	}()
	return NewDrawListFromC(C.ImDrawList_ImDrawList(internal.ReinterpretCast[*C.ImDrawListSharedData](shared_dataArg)))
}

// PathArcToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathArcToV(center Vec2, radius float32, a_min float32, a_max float32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathArcTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.float(a_min), C.float(a_max), C.int(num_segments))

	selfFin()
}

// Use precomputed angles for a 12 steps circle
func (self *DrawList) PathArcToFast(center Vec2, radius float32, a_min_of_12 int32, a_max_of_12 int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathArcToFast(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.int(a_min_of_12), C.int(a_max_of_12))

	selfFin()
}

// Cubic Bezier (4 control points)
// PathBezierCubicCurveToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathBezierCubicCurveToV(p2 Vec2, p3 Vec2, p4 Vec2, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathBezierCubicCurveTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), C.int(num_segments))

	selfFin()
}

// Quadratic Bezier (3 control points)
// PathBezierQuadraticCurveToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathBezierQuadraticCurveToV(p2 Vec2, p3 Vec2, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathBezierQuadraticCurveTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), C.int(num_segments))

	selfFin()
}

func (self *DrawList) PathClear() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathClear(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

// Ellipse
// PathEllipticalArcToV parameter default value hint:
// num_segments: 0
func (self *DrawList) PathEllipticalArcToV(center Vec2, radius Vec2, rot float32, a_min float32, a_max float32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathEllipticalArcTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), internal.ReinterpretCast[C.ImVec2](radius.ToC()), C.float(rot), C.float(a_min), C.float(a_max), C.int(num_segments))

	selfFin()
}

func (self *DrawList) PathFillConcave(col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathFillConcave(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PathFillConvex(col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathFillConvex(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PathLineTo(pos Vec2) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathLineTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()))

	selfFin()
}

func (self *DrawList) PathLineToMergeDuplicate(pos Vec2) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathLineToMergeDuplicate(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()))

	selfFin()
}

// PathRectV parameter default value hint:
// rounding: 0.0f
// flags: 0
func (self *DrawList) PathRectV(rect_min Vec2, rect_max Vec2, rounding float32, flags DrawFlags) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathRect(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](rect_min.ToC()), internal.ReinterpretCast[C.ImVec2](rect_max.ToC()), C.float(rounding), C.ImDrawFlags(flags))

	selfFin()
}

// PathStrokeV parameter default value hint:
// flags: 0
// thickness: 1.0f
func (self *DrawList) PathStrokeV(col uint32, flags DrawFlags, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PathStroke(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.ImU32(col), C.ImDrawFlags(flags), C.float(thickness))

	selfFin()
}

func (self *DrawList) PopClipRect() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PopClipRect(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) PopTextureID() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PopTextureID(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) PrimQuadUV(a Vec2, b Vec2, c Vec2, d Vec2, uv_a Vec2, uv_b Vec2, uv_c Vec2, uv_d Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PrimQuadUV(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](c.ToC()), internal.ReinterpretCast[C.ImVec2](d.ToC()), internal.ReinterpretCast[C.ImVec2](uv_a.ToC()), internal.ReinterpretCast[C.ImVec2](uv_b.ToC()), internal.ReinterpretCast[C.ImVec2](uv_c.ToC()), internal.ReinterpretCast[C.ImVec2](uv_d.ToC()), C.ImU32(col))

	selfFin()
}

// Axis aligned rectangle (composed of two triangles)
func (self *DrawList) PrimRect(a Vec2, b Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PrimRect(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PrimRectUV(a Vec2, b Vec2, uv_a Vec2, uv_b Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PrimRectUV(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](uv_a.ToC()), internal.ReinterpretCast[C.ImVec2](uv_b.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PrimReserve(idx_count int32, vtx_count int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PrimReserve(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.int(idx_count), C.int(vtx_count))

	selfFin()
}

func (self *DrawList) PrimUnreserve(idx_count int32, vtx_count int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PrimUnreserve(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.int(idx_count), C.int(vtx_count))

	selfFin()
}

// Write vertex with unique index
func (self *DrawList) PrimVtx(pos Vec2, uv Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PrimVtx(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), internal.ReinterpretCast[C.ImVec2](uv.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PrimWriteIdx(idx DrawIdx) {
	selfArg, selfFin := self.Handle()
	idxArg, idxFin := idx.C()
	C.ImDrawList_PrimWriteIdx(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImDrawIdx](idxArg))

	selfFin()
	idxFin()
}

func (self *DrawList) PrimWriteVtx(pos Vec2, uv Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PrimWriteVtx(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), internal.ReinterpretCast[C.ImVec2](uv.ToC()), C.ImU32(col))

	selfFin()
}

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
// PushClipRectV parameter default value hint:
// intersect_with_current_clip_rect: false
func (self *DrawList) PushClipRectV(clip_rect_min Vec2, clip_rect_max Vec2, intersect_with_current_clip_rect bool) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PushClipRect(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](clip_rect_min.ToC()), internal.ReinterpretCast[C.ImVec2](clip_rect_max.ToC()), C.bool(intersect_with_current_clip_rect))

	selfFin()
}

func (self *DrawList) PushClipRectFullScreen() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_PushClipRectFullScreen(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) PushTextureID(texture_id TextureID) {
	selfArg, selfFin := self.Handle()
	texture_idArg, texture_idFin := texture_id.C()
	C.ImDrawList_PushTextureID(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](texture_idArg))

	selfFin()
	texture_idFin()
}

func (self *DrawList) CalcCircleAutoSegmentCount(radius float32) int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImDrawList__CalcCircleAutoSegmentCount(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.float(radius)))
}

func (self *DrawList) ClearFreeMemory() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__ClearFreeMemory(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) OnChangedClipRect() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__OnChangedClipRect(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) OnChangedTextureID() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__OnChangedTextureID(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) OnChangedVtxOffset() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__OnChangedVtxOffset(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) PathArcToFastEx(center Vec2, radius float32, a_min_sample int32, a_max_sample int32, a_step int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__PathArcToFastEx(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.int(a_min_sample), C.int(a_max_sample), C.int(a_step))

	selfFin()
}

func (self *DrawList) PathArcToN(center Vec2, radius float32, a_min float32, a_max float32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__PathArcToN(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.float(a_min), C.float(a_max), C.int(num_segments))

	selfFin()
}

func (self *DrawList) PopUnusedDrawCmd() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__PopUnusedDrawCmd(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) ResetForNewFrame() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__ResetForNewFrame(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) SetTextureID(texture_id TextureID) {
	selfArg, selfFin := self.Handle()
	texture_idArg, texture_idFin := texture_id.C()
	C.ImDrawList__SetTextureID(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](texture_idArg))

	selfFin()
	texture_idFin()
}

func (self *DrawList) TryMergeDrawCmds() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList__TryMergeDrawCmds(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func (self *DrawList) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImDrawList_destroy(internal.ReinterpretCast[*C.ImDrawList](selfArg))

	selfFin()
}

func NewFontAtlasCustomRect() *FontAtlasCustomRect {
	return NewFontAtlasCustomRectFromC(C.ImFontAtlasCustomRect_ImFontAtlasCustomRect())
}

func (self *FontAtlasCustomRect) IsPacked() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontAtlasCustomRect_IsPacked(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)) == C.bool(true)
}

func (self *FontAtlasCustomRect) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImFontAtlasCustomRect_destroy(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg))

	selfFin()
}

// AddCustomRectFontGlyphV parameter default value hint:
// offset: ImVec2(0,0)
func (self *FontAtlas) AddCustomRectFontGlyphV(font *Font, id Wchar, width int32, height int32, advance_x float32, offset Vec2) int32 {
	selfArg, selfFin := self.Handle()
	fontArg, fontFin := font.Handle()

	defer func() {
		selfFin()
		fontFin()
	}()
	return int32(C.ImFontAtlas_AddCustomRectFontGlyph(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), internal.ReinterpretCast[*C.ImFont](fontArg), C.ImWchar(id), C.int(width), C.int(height), C.float(advance_x), internal.ReinterpretCast[C.ImVec2](offset.ToC())))
}

func (self *FontAtlas) AddCustomRectRegular(width int32, height int32) int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImFontAtlas_AddCustomRectRegular(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), C.int(width), C.int(height)))
}

func (self *FontAtlas) AddFont(font_cfg *FontConfig) *Font {
	selfArg, selfFin := self.Handle()
	font_cfgArg, font_cfgFin := font_cfg.Handle()

	defer func() {
		selfFin()
		font_cfgFin()
	}()
	return NewFontFromC(C.ImFontAtlas_AddFont(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), internal.ReinterpretCast[*C.ImFontConfig](font_cfgArg)))
}

// AddFontDefaultV parameter default value hint:
// font_cfg: NULL
func (self *FontAtlas) AddFontDefaultV(font_cfg *FontConfig) *Font {
	selfArg, selfFin := self.Handle()
	font_cfgArg, font_cfgFin := font_cfg.Handle()

	defer func() {
		selfFin()
		font_cfgFin()
	}()
	return NewFontFromC(C.ImFontAtlas_AddFontDefault(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), internal.ReinterpretCast[*C.ImFontConfig](font_cfgArg)))
}

// AddFontFromFileTTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromFileTTFV(filename string, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.Handle()
	filenameArg, filenameFin := internal.WrapString[C.char](filename)
	font_cfgArg, font_cfgFin := font_cfg.Handle()

	defer func() {
		selfFin()
		filenameFin()
		font_cfgFin()
	}()
	return NewFontFromC(C.ImFontAtlas_AddFontFromFileTTF(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), filenameArg, C.float(size_pixels), internal.ReinterpretCast[*C.ImFontConfig](font_cfgArg), (*C.ImWchar)(glyph_ranges)))
}

// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
// AddFontFromMemoryCompressedBase85TTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromMemoryCompressedBase85TTFV(compressed_font_data_base85 string, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.Handle()
	compressed_font_data_base85Arg, compressed_font_data_base85Fin := internal.WrapString[C.char](compressed_font_data_base85)
	font_cfgArg, font_cfgFin := font_cfg.Handle()

	defer func() {
		selfFin()
		compressed_font_data_base85Fin()
		font_cfgFin()
	}()
	return NewFontFromC(C.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), compressed_font_data_base85Arg, C.float(size_pixels), internal.ReinterpretCast[*C.ImFontConfig](font_cfgArg), (*C.ImWchar)(glyph_ranges)))
}

// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
// AddFontFromMemoryCompressedTTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromMemoryCompressedTTFV(compressed_font_data uintptr, compressed_font_data_size int32, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.Handle()
	font_cfgArg, font_cfgFin := font_cfg.Handle()

	defer func() {
		selfFin()
		font_cfgFin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryCompressedTTFV(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), C.uintptr_t(compressed_font_data), C.int(compressed_font_data_size), C.float(size_pixels), internal.ReinterpretCast[*C.ImFontConfig](font_cfgArg), (*C.ImWchar)(glyph_ranges)))
}

// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
// AddFontFromMemoryTTFV parameter default value hint:
// font_cfg: NULL
// glyph_ranges: NULL
func (self *FontAtlas) AddFontFromMemoryTTFV(font_data uintptr, font_data_size int32, size_pixels float32, font_cfg *FontConfig, glyph_ranges *Wchar) *Font {
	selfArg, selfFin := self.Handle()
	font_cfgArg, font_cfgFin := font_cfg.Handle()

	defer func() {
		selfFin()
		font_cfgFin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryTTFV(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), C.uintptr_t(font_data), C.int(font_data_size), C.float(size_pixels), internal.ReinterpretCast[*C.ImFontConfig](font_cfgArg), (*C.ImWchar)(glyph_ranges)))
}

// Build pixels data. This is called automatically for you by the GetTexData*** functions.
func (self *FontAtlas) Build() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontAtlas_Build(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)) == C.bool(true)
}

func (self *FontAtlas) CalcCustomRectUV(rect *FontAtlasCustomRect, out_uv_min *Vec2, out_uv_max *Vec2) {
	selfArg, selfFin := self.Handle()
	rectArg, rectFin := rect.Handle()
	out_uv_minArg, out_uv_minFin := internal.Wrap(out_uv_min)
	out_uv_maxArg, out_uv_maxFin := internal.Wrap(out_uv_max)
	C.ImFontAtlas_CalcCustomRectUV(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), internal.ReinterpretCast[*C.ImFontAtlasCustomRect](rectArg), internal.ReinterpretCast[*C.ImVec2](out_uv_minArg), internal.ReinterpretCast[*C.ImVec2](out_uv_maxArg))

	selfFin()
	rectFin()
	out_uv_minFin()
	out_uv_maxFin()
}

// Clear all input and output.
func (self *FontAtlas) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImFontAtlas_Clear(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))

	selfFin()
}

// Clear output font data (glyphs storage, UV coordinates).
func (self *FontAtlas) ClearFonts() {
	selfArg, selfFin := self.Handle()
	C.ImFontAtlas_ClearFonts(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))

	selfFin()
}

// Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
func (self *FontAtlas) ClearInputData() {
	selfArg, selfFin := self.Handle()
	C.ImFontAtlas_ClearInputData(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))

	selfFin()
}

// Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
func (self *FontAtlas) ClearTexData() {
	selfArg, selfFin := self.Handle()
	C.ImFontAtlas_ClearTexData(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))

	selfFin()
}

func (self *FontAtlas) CustomRectByIndex(index int32) *FontAtlasCustomRect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontAtlasCustomRectFromC(C.ImFontAtlas_GetCustomRectByIndex(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), C.int(index)))
}

// Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
func (self *FontAtlas) GlyphRangesChineseFull() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesChineseFull(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
func (self *FontAtlas) GlyphRangesChineseSimplifiedCommon() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Default + about 400 Cyrillic characters
func (self *FontAtlas) GlyphRangesCyrillic() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesCyrillic(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Basic Latin, Extended Latin
func (self *FontAtlas) GlyphRangesDefault() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesDefault(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Default + Greek and Coptic
func (self *FontAtlas) GlyphRangesGreek() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesGreek(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs
func (self *FontAtlas) GlyphRangesJapanese() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesJapanese(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Default + Korean characters
func (self *FontAtlas) GlyphRangesKorean() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesKorean(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Default + Thai characters
func (self *FontAtlas) GlyphRangesThai() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesThai(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// Default + Vietnamese characters
func (self *FontAtlas) GlyphRangesVietnamese() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.ImFontAtlas_GetGlyphRangesVietnamese(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

func (self *FontAtlas) MouseCursorTexData(cursor MouseCursor, out_offset *Vec2, out_size *Vec2, out_uv_border [2]*Vec2, out_uv_fill [2]*Vec2) bool {
	selfArg, selfFin := self.Handle()
	out_offsetArg, out_offsetFin := internal.Wrap(out_offset)
	out_sizeArg, out_sizeFin := internal.Wrap(out_size)
	out_uv_borderArg := make([]C.ImVec2, len(out_uv_border))
	out_uv_borderFin := make([]func(), len(out_uv_border))
	for i, out_uv_borderV := range out_uv_border {
		var tmp *C.ImVec2
		tmp, out_uv_borderFin[i] = internal.Wrap(out_uv_borderV)
		out_uv_borderArg[i] = *tmp
	}

	out_uv_fillArg := make([]C.ImVec2, len(out_uv_fill))
	out_uv_fillFin := make([]func(), len(out_uv_fill))
	for i, out_uv_fillV := range out_uv_fill {
		var tmp *C.ImVec2
		tmp, out_uv_fillFin[i] = internal.Wrap(out_uv_fillV)
		out_uv_fillArg[i] = *tmp
	}

	defer func() {
		selfFin()
		out_offsetFin()
		out_sizeFin()

		for _, out_uv_borderV := range out_uv_borderFin {
			out_uv_borderV()
		}

		for _, out_uv_fillV := range out_uv_fillFin {
			out_uv_fillV()
		}
	}()
	return C.ImFontAtlas_GetMouseCursorTexData(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), C.ImGuiMouseCursor(cursor), internal.ReinterpretCast[*C.ImVec2](out_offsetArg), internal.ReinterpretCast[*C.ImVec2](out_sizeArg), (*C.ImVec2)(&out_uv_borderArg[0]), (*C.ImVec2)(&out_uv_fillArg[0])) == C.bool(true)
}

func NewFontAtlas() *FontAtlas {
	return NewFontAtlasFromC(C.ImFontAtlas_ImFontAtlas())
}

// Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
func (self *FontAtlas) IsBuilt() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontAtlas_IsBuilt(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)) == C.bool(true)
}

func (self *FontAtlas) SetTexID(id TextureID) {
	selfArg, selfFin := self.Handle()
	idArg, idFin := id.C()
	C.ImFontAtlas_SetTexID(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), internal.ReinterpretCast[C.ImTextureID](idArg))

	selfFin()
	idFin()
}

func (self *FontAtlas) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImFontAtlas_destroy(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))

	selfFin()
}

func NewFontConfig() *FontConfig {
	return NewFontConfigFromC(C.ImFontConfig_ImFontConfig())
}

func (self *FontConfig) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImFontConfig_destroy(internal.ReinterpretCast[*C.ImFontConfig](selfArg))

	selfFin()
}

// Add character
func (self *FontGlyphRangesBuilder) AddChar(c Wchar) {
	selfArg, selfFin := self.Handle()
	C.ImFontGlyphRangesBuilder_AddChar(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg), C.ImWchar(c))

	selfFin()
}

// Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
func (self *FontGlyphRangesBuilder) AddRanges(ranges *Wchar) {
	selfArg, selfFin := self.Handle()
	C.ImFontGlyphRangesBuilder_AddRanges(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg), (*C.ImWchar)(ranges))

	selfFin()
}

// Add string (each character of the UTF-8 string are added)
// AddTextV parameter default value hint:
func (self *FontGlyphRangesBuilder) AddTextV(text string) {
	selfArg, selfFin := self.Handle()
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_ImFontGlyphRangesBuilder_AddTextV(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg), textArg, C.int(len(text)))

	selfFin()
	textFin()
}

func (self *FontGlyphRangesBuilder) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImFontGlyphRangesBuilder_Clear(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg))

	selfFin()
}

// Get bit n in the array
func (self *FontGlyphRangesBuilder) Bit(n uint64) bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImFontGlyphRangesBuilder_GetBit(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg), C.xulong(n)) == C.bool(true)
}

func NewFontGlyphRangesBuilder() *FontGlyphRangesBuilder {
	return NewFontGlyphRangesBuilderFromC(C.ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder())
}

// Set bit n in the array
func (self *FontGlyphRangesBuilder) SetBit(n uint64) {
	selfArg, selfFin := self.Handle()
	C.ImFontGlyphRangesBuilder_SetBit(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg), C.xulong(n))

	selfFin()
}

func (self *FontGlyphRangesBuilder) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImFontGlyphRangesBuilder_destroy(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg))

	selfFin()
}

func (self *Font) AddGlyph(src_cfg *FontConfig, c Wchar, x0 float32, y0 float32, x1 float32, y1 float32, u0 float32, v0 float32, u1 float32, v1 float32, advance_x float32) {
	selfArg, selfFin := self.Handle()
	src_cfgArg, src_cfgFin := src_cfg.Handle()
	C.ImFont_AddGlyph(internal.ReinterpretCast[*C.ImFont](selfArg), internal.ReinterpretCast[*C.ImFontConfig](src_cfgArg), C.ImWchar(c), C.float(x0), C.float(y0), C.float(x1), C.float(y1), C.float(u0), C.float(v0), C.float(u1), C.float(v1), C.float(advance_x))

	selfFin()
	src_cfgFin()
}

// Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
// AddRemapCharV parameter default value hint:
// overwrite_dst: true
func (self *Font) AddRemapCharV(dst Wchar, src Wchar, overwrite_dst bool) {
	selfArg, selfFin := self.Handle()
	C.ImFont_AddRemapChar(internal.ReinterpretCast[*C.ImFont](selfArg), C.ImWchar(dst), C.ImWchar(src), C.bool(overwrite_dst))

	selfFin()
}

func (self *Font) BuildLookupTable() {
	selfArg, selfFin := self.Handle()
	C.ImFont_BuildLookupTable(internal.ReinterpretCast[*C.ImFont](selfArg))

	selfFin()
}

// utf8
// CalcTextSizeAV parameter default value hint:
// remaining: NULL
func (self *Font) CalcTextSizeAV(size float32, max_width float32, wrap_width float32, text_begin string, remaining []string) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	remainingArg, remainingFin := internal.WrapStringList[C.char](remaining)
	C.wrap_ImFont_CalcTextSizeAV(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImFont](selfArg), C.float(size), C.float(max_width), C.float(wrap_width), text_beginArg, remainingArg)

	pOutFin()
	selfFin()
	text_beginFin()
	remainingFin()

	return *pOut
}

func (self *Font) CalcWordWrapPositionA(scale float32, text string, wrap_width float32) string {
	selfArg, selfFin := self.Handle()
	textArg, textFin := internal.WrapString[C.char](text)

	defer func() {
		selfFin()
		textFin()
	}()
	return func() string {
		result := C.wrap_ImFont_CalcWordWrapPositionA(internal.ReinterpretCast[*C.ImFont](selfArg), C.float(scale), textArg, C.int(len(text)), C.float(wrap_width))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func (self *Font) ClearOutputData() {
	selfArg, selfFin := self.Handle()
	C.ImFont_ClearOutputData(internal.ReinterpretCast[*C.ImFont](selfArg))

	selfFin()
}

func (self *Font) FindGlyph(c Wchar) *FontGlyph {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontGlyphFromC(C.ImFont_FindGlyph(internal.ReinterpretCast[*C.ImFont](selfArg), C.ImWchar(c)))
}

func (self *Font) FindGlyphNoFallback(c Wchar) *FontGlyph {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontGlyphFromC(C.ImFont_FindGlyphNoFallback(internal.ReinterpretCast[*C.ImFont](selfArg), C.ImWchar(c)))
}

func (self *Font) CharAdvance(c Wchar) float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImFont_GetCharAdvance(internal.ReinterpretCast[*C.ImFont](selfArg), C.ImWchar(c)))
}

func (self *Font) DebugName() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.ImFont_GetDebugName(internal.ReinterpretCast[*C.ImFont](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func (self *Font) GrowIndex(new_size int32) {
	selfArg, selfFin := self.Handle()
	C.ImFont_GrowIndex(internal.ReinterpretCast[*C.ImFont](selfArg), C.int(new_size))

	selfFin()
}

func NewFont() *Font {
	return NewFontFromC(C.ImFont_ImFont())
}

func (self *Font) IsGlyphRangeUnused(c_begin uint32, c_last uint32) bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImFont_IsGlyphRangeUnused(internal.ReinterpretCast[*C.ImFont](selfArg), C.uint(c_begin), C.uint(c_last)) == C.bool(true)
}

func (self *Font) IsLoaded() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImFont_IsLoaded(internal.ReinterpretCast[*C.ImFont](selfArg)) == C.bool(true)
}

func (self *Font) RenderChar(draw_list *DrawList, size float32, pos Vec2, col uint32, c Wchar) {
	selfArg, selfFin := self.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	C.ImFont_RenderChar(internal.ReinterpretCast[*C.ImFont](selfArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.float(size), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), C.ImWchar(c))

	selfFin()
	draw_listFin()
}

// RenderTextV parameter default value hint:
// wrap_width: 0.0f
// cpu_fine_clip: false
func (self *Font) RenderTextV(draw_list *DrawList, size float32, pos Vec2, col uint32, clip_rect Vec4, text_begin string, wrap_width float32, cpu_fine_clip bool) {
	selfArg, selfFin := self.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	C.wrap_ImFont_RenderTextV(internal.ReinterpretCast[*C.ImFont](selfArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.float(size), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), internal.ReinterpretCast[C.ImVec4](clip_rect.ToC()), text_beginArg, C.float(wrap_width), C.bool(cpu_fine_clip))

	selfFin()
	draw_listFin()
	text_beginFin()
}

func (self *Font) SetGlyphVisible(c Wchar, visible bool) {
	selfArg, selfFin := self.Handle()
	C.ImFont_SetGlyphVisible(internal.ReinterpretCast[*C.ImFont](selfArg), C.ImWchar(c), C.bool(visible))

	selfFin()
}

func (self *Font) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImFont_destroy(internal.ReinterpretCast[*C.ImFont](selfArg))

	selfFin()
}

func InternalNewBoxSelectState() *BoxSelectState {
	return NewBoxSelectStateFromC(C.ImGuiBoxSelectState_ImGuiBoxSelectState())
}

func (self *BoxSelectState) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiBoxSelectState_destroy(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))

	selfFin()
}

func InternalNewComboPreviewData() *ComboPreviewData {
	return NewComboPreviewDataFromC(C.ImGuiComboPreviewData_ImGuiComboPreviewData())
}

func (self *ComboPreviewData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiComboPreviewData_destroy(internal.ReinterpretCast[*C.ImGuiComboPreviewData](selfArg))

	selfFin()
}

func InternalNewContextHook() *ContextHook {
	return NewContextHookFromC(C.ImGuiContextHook_ImGuiContextHook())
}

func (self *ContextHook) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiContextHook_destroy(internal.ReinterpretCast[*C.ImGuiContextHook](selfArg))

	selfFin()
}

func InternalNewContext(shared_font_atlas *FontAtlas) *Context {
	shared_font_atlasArg, shared_font_atlasFin := shared_font_atlas.Handle()

	defer func() {
		shared_font_atlasFin()
	}()
	return NewContextFromC(C.ImGuiContext_ImGuiContext(internal.ReinterpretCast[*C.ImFontAtlas](shared_font_atlasArg)))
}

func (self *Context) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiContext_destroy(internal.ReinterpretCast[*C.ImGuiContext](selfArg))

	selfFin()
}

func (self *DataVarInfo) InternalVarPtr(parent uintptr) uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiDataVarInfo_GetVarPtr(internal.ReinterpretCast[*C.ImGuiDataVarInfo](selfArg), C.uintptr_t(parent)))
}

func InternalNewDebugAllocInfo() *DebugAllocInfo {
	return NewDebugAllocInfoFromC(C.ImGuiDebugAllocInfo_ImGuiDebugAllocInfo())
}

func (self *DebugAllocInfo) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiDebugAllocInfo_destroy(internal.ReinterpretCast[*C.ImGuiDebugAllocInfo](selfArg))

	selfFin()
}

func InternalNewDockContext() *DockContext {
	return NewDockContextFromC(C.ImGuiDockContext_ImGuiDockContext())
}

func (self *DockContext) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiDockContext_destroy(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg))

	selfFin()
}

func InternalNewDockNode(id ID) *DockNode {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewDockNodeFromC(C.ImGuiDockNode_ImGuiDockNode(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func (self *DockNode) InternalIsCentralNode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsCentralNode(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

func (self *DockNode) InternalIsDockSpace() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsDockSpace(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

func (self *DockNode) InternalIsEmpty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsEmpty(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

func (self *DockNode) InternalIsFloatingNode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsFloatingNode(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// Hidden tab bar can be shown back by clicking the small triangle
func (self *DockNode) InternalIsHiddenTabBar() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsHiddenTabBar(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

func (self *DockNode) InternalIsLeafNode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsLeafNode(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// Never show a tab bar
func (self *DockNode) InternalIsNoTabBar() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsNoTabBar(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

func (self *DockNode) InternalIsRootNode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsRootNode(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

func (self *DockNode) InternalIsSplitNode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiDockNode_IsSplitNode(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

func (self *DockNode) InternalRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiDockNode_Rect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *DockNode) InternalSetLocalFlags(flags DockNodeFlags) {
	selfArg, selfFin := self.Handle()
	C.ImGuiDockNode_SetLocalFlags(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg), C.ImGuiDockNodeFlags(flags))

	selfFin()
}

func (self *DockNode) InternalUpdateMergedFlags() {
	selfArg, selfFin := self.Handle()
	C.ImGuiDockNode_UpdateMergedFlags(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))

	selfFin()
}

func (self *DockNode) InternalDestroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiDockNode_destroy(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))

	selfFin()
}

func InternalNewErrorRecoveryState() *ErrorRecoveryState {
	return NewErrorRecoveryStateFromC(C.ImGuiErrorRecoveryState_ImGuiErrorRecoveryState())
}

func (self *ErrorRecoveryState) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiErrorRecoveryState_destroy(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg))

	selfFin()
}

func InternalNewIDStackTool() *IDStackTool {
	return NewIDStackToolFromC(C.ImGuiIDStackTool_ImGuiIDStackTool())
}

func (self *IDStackTool) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiIDStackTool_destroy(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg))

	selfFin()
}

// Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)
func (self *IO) AddFocusEvent(focused bool) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddFocusEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.bool(focused))

	selfFin()
}

// Queue a new character input
func (self *IO) AddInputCharacter(c uint32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddInputCharacter(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.uint(c))

	selfFin()
}

// Queue a new character input from a UTF-16 character, it can be a surrogate
func (self *IO) AddInputCharacterUTF16(c uint16) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddInputCharacterUTF16(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.ImWchar16(c))

	selfFin()
}

// Queue a new characters input from a UTF-8 string
func (self *IO) AddInputCharactersUTF8(str string) {
	selfArg, selfFin := self.Handle()
	strArg, strFin := internal.WrapString[C.char](str)
	C.ImGuiIO_AddInputCharactersUTF8(internal.ReinterpretCast[*C.ImGuiIO](selfArg), strArg)

	selfFin()
	strFin()
}

// Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.
func (self *IO) AddKeyAnalogEvent(key Key, down bool, v float32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddKeyAnalogEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.ImGuiKey(key), C.bool(down), C.float(v))

	selfFin()
}

// Queue a new key down/up event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
func (self *IO) AddKeyEvent(key Key, down bool) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddKeyEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.ImGuiKey(key), C.bool(down))

	selfFin()
}

// Queue a mouse button change
func (self *IO) AddMouseButtonEvent(button int32, down bool) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddMouseButtonEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.int(button), C.bool(down))

	selfFin()
}

// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)
func (self *IO) AddMousePosEvent(x float32, y float32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddMousePosEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.float(x), C.float(y))

	selfFin()
}

// Queue a mouse source change (Mouse/TouchScreen/Pen)
func (self *IO) AddMouseSourceEvent(source MouseSource) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddMouseSourceEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.ImGuiMouseSource(source))

	selfFin()
}

// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).
func (self *IO) AddMouseViewportEvent(id ID) {
	selfArg, selfFin := self.Handle()
	idArg, idFin := id.C()
	C.ImGuiIO_AddMouseViewportEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), internal.ReinterpretCast[C.ImGuiID](idArg))

	selfFin()
	idFin()
}

// Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.
func (self *IO) AddMouseWheelEvent(wheel_x float32, wheel_y float32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_AddMouseWheelEvent(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.float(wheel_x), C.float(wheel_y))

	selfFin()
}

// Clear all incoming events.
func (self *IO) ClearEventsQueue() {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_ClearEventsQueue(internal.ReinterpretCast[*C.ImGuiIO](selfArg))

	selfFin()
}

// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
func (self *IO) ClearInputKeys() {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_ClearInputKeys(internal.ReinterpretCast[*C.ImGuiIO](selfArg))

	selfFin()
}

// Clear current mouse state.
func (self *IO) ClearInputMouse() {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_ClearInputMouse(internal.ReinterpretCast[*C.ImGuiIO](selfArg))

	selfFin()
}

func NewIO() *IO {
	return NewIOFromC(C.ImGuiIO_ImGuiIO())
}

// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
func (self *IO) SetAppAcceptingEvents(accepting_events bool) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_SetAppAcceptingEvents(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.bool(accepting_events))

	selfFin()
}

// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.
// SetKeyEventNativeDataV parameter default value hint:
// native_legacy_index: -1
func (self *IO) SetKeyEventNativeDataV(key Key, native_keycode int32, native_scancode int32, native_legacy_index int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_SetKeyEventNativeData(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.ImGuiKey(key), C.int(native_keycode), C.int(native_scancode), C.int(native_legacy_index))

	selfFin()
}

func (self *IO) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiIO_destroy(internal.ReinterpretCast[*C.ImGuiIO](selfArg))

	selfFin()
}

func InternalNewInputEvent() *InputEvent {
	return NewInputEventFromC(C.ImGuiInputEvent_ImGuiInputEvent())
}

func (self *InputEvent) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputEvent_destroy(internal.ReinterpretCast[*C.ImGuiInputEvent](selfArg))

	selfFin()
}

func (self *InputTextCallbackData) ClearSelection() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextCallbackData_ClearSelection(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg))

	selfFin()
}

func (self *InputTextCallbackData) DeleteChars(pos int32, bytes_count int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextCallbackData_DeleteChars(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg), C.int(pos), C.int(bytes_count))

	selfFin()
}

func (self *InputTextCallbackData) HasSelection() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiInputTextCallbackData_HasSelection(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)) == C.bool(true)
}

func NewInputTextCallbackData() *InputTextCallbackData {
	return NewInputTextCallbackDataFromC(C.ImGuiInputTextCallbackData_ImGuiInputTextCallbackData())
}

// InsertCharsV parameter default value hint:
func (self *InputTextCallbackData) InsertCharsV(pos int32, text string) {
	selfArg, selfFin := self.Handle()
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_ImGuiInputTextCallbackData_InsertCharsV(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg), C.int(pos), textArg, C.int(len(text)))

	selfFin()
	textFin()
}

func (self *InputTextCallbackData) SelectAll() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextCallbackData_SelectAll(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg))

	selfFin()
}

func (self *InputTextCallbackData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextCallbackData_destroy(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg))

	selfFin()
}

func (self *InputTextDeactivatedState) InternalClearFreeMemory() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextDeactivatedState_ClearFreeMemory(internal.ReinterpretCast[*C.ImGuiInputTextDeactivatedState](selfArg))

	selfFin()
}

func InternalNewInputTextDeactivatedState() *InputTextDeactivatedState {
	return NewInputTextDeactivatedStateFromC(C.ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState())
}

func (self *InputTextDeactivatedState) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextDeactivatedState_destroy(internal.ReinterpretCast[*C.ImGuiInputTextDeactivatedState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalClearFreeMemory() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_ClearFreeMemory(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalClearSelection() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_ClearSelection(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalClearText() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_ClearText(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalCursorAnimReset() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_CursorAnimReset(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalCursorClamp() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_CursorClamp(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalCursorPos() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetCursorPos(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

func (self *InputTextState) InternalSelectionEnd() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetSelectionEnd(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

func (self *InputTextState) InternalSelectionStart() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiInputTextState_GetSelectionStart(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

func (self *InputTextState) InternalHasSelection() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiInputTextState_HasSelection(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)) == C.bool(true)
}

func InternalNewInputTextState() *InputTextState {
	return NewInputTextStateFromC(C.ImGuiInputTextState_ImGuiInputTextState())
}

func (self *InputTextState) InternalOnCharPressed(c uint32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_OnCharPressed(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg), C.uint(c))

	selfFin()
}

// Cannot be inline because we call in code in stb_textedit.h implementation
func (self *InputTextState) InternalOnKeyPressed(key int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_OnKeyPressed(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg), C.int(key))

	selfFin()
}

func (self *InputTextState) InternalReloadUserBufAndKeepSelection() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_ReloadUserBufAndKeepSelection(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalReloadUserBufAndMoveToEnd() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_ReloadUserBufAndMoveToEnd(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalReloadUserBufAndSelectAll() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_ReloadUserBufAndSelectAll(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalSelectAll() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_SelectAll(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func (self *InputTextState) InternalDestroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiInputTextState_destroy(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))

	selfFin()
}

func InternalNewKeyOwnerData() *KeyOwnerData {
	return NewKeyOwnerDataFromC(C.ImGuiKeyOwnerData_ImGuiKeyOwnerData())
}

func (self *KeyOwnerData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiKeyOwnerData_destroy(internal.ReinterpretCast[*C.ImGuiKeyOwnerData](selfArg))

	selfFin()
}

func InternalNewKeyRoutingData() *KeyRoutingData {
	return NewKeyRoutingDataFromC(C.ImGuiKeyRoutingData_ImGuiKeyRoutingData())
}

func (self *KeyRoutingData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiKeyRoutingData_destroy(internal.ReinterpretCast[*C.ImGuiKeyRoutingData](selfArg))

	selfFin()
}

func (self *KeyRoutingTable) InternalClear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiKeyRoutingTable_Clear(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg))

	selfFin()
}

func InternalNewKeyRoutingTable() *KeyRoutingTable {
	return NewKeyRoutingTableFromC(C.ImGuiKeyRoutingTable_ImGuiKeyRoutingTable())
}

func (self *KeyRoutingTable) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiKeyRoutingTable_destroy(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg))

	selfFin()
}

func InternalNewLastItemData() *LastItemData {
	return NewLastItemDataFromC(C.ImGuiLastItemData_ImGuiLastItemData())
}

func (self *LastItemData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiLastItemData_destroy(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg))

	selfFin()
}

func InternalNewListClipperData() *ListClipperData {
	return NewListClipperDataFromC(C.ImGuiListClipperData_ImGuiListClipperData())
}

func (self *ListClipperData) InternalReset(clipper *ListClipper) {
	selfArg, selfFin := self.Handle()
	clipperArg, clipperFin := clipper.Handle()
	C.ImGuiListClipperData_Reset(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg), internal.ReinterpretCast[*C.ImGuiListClipper](clipperArg))

	selfFin()
	clipperFin()
}

func (self *ListClipperData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiListClipperData_destroy(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg))

	selfFin()
}

func InternalListClipperRangeFromIndices(min int32, max int32) ListClipperRange {
	return *NewListClipperRangeFromC(func() *C.ImGuiListClipperRange {
		result := C.ImGuiListClipperRange_FromIndices(C.int(min), C.int(max))
		return &result
	}())
}

func InternalListClipperRangeFromPositions(y1 float32, y2 float32, off_min int32, off_max int32) ListClipperRange {
	return *NewListClipperRangeFromC(func() *C.ImGuiListClipperRange {
		result := C.ImGuiListClipperRange_FromPositions(C.float(y1), C.float(y2), C.int(off_min), C.int(off_max))
		return &result
	}())
}

// BeginV parameter default value hint:
// items_height: -1.0f
func (self *ListClipper) BeginV(items_count int32, items_height float32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiListClipper_Begin(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg), C.int(items_count), C.float(items_height))

	selfFin()
}

// Automatically called on the last call of Step() that returns false.
func (self *ListClipper) End() {
	selfArg, selfFin := self.Handle()
	C.ImGuiListClipper_End(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg))

	selfFin()
}

func NewListClipper() *ListClipper {
	return NewListClipperFromC(C.ImGuiListClipper_ImGuiListClipper())
}

func (self *ListClipper) IncludeItemByIndex(item_index int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiListClipper_IncludeItemByIndex(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg), C.int(item_index))

	selfFin()
}

// item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.
func (self *ListClipper) IncludeItemsByIndex(item_begin int32, item_end int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiListClipper_IncludeItemsByIndex(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg), C.int(item_begin), C.int(item_end))

	selfFin()
}

func (self *ListClipper) SeekCursorForItem(item_index int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiListClipper_SeekCursorForItem(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg), C.int(item_index))

	selfFin()
}

// Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
func (self *ListClipper) Step() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiListClipper_Step(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)) == C.bool(true)
}

func (self *ListClipper) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiListClipper_destroy(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg))

	selfFin()
}

func (self *MenuColumns) InternalCalcNextTotalWidth(update_offsets bool) {
	selfArg, selfFin := self.Handle()
	C.ImGuiMenuColumns_CalcNextTotalWidth(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg), C.bool(update_offsets))

	selfFin()
}

func (self *MenuColumns) InternalDeclColumns(w_icon float32, w_label float32, w_shortcut float32, w_mark float32) float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImGuiMenuColumns_DeclColumns(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg), C.float(w_icon), C.float(w_label), C.float(w_shortcut), C.float(w_mark)))
}

func InternalNewMenuColumns() *MenuColumns {
	return NewMenuColumnsFromC(C.ImGuiMenuColumns_ImGuiMenuColumns())
}

func (self *MenuColumns) InternalUpdate(spacing float32, window_reappearing bool) {
	selfArg, selfFin := self.Handle()
	C.ImGuiMenuColumns_Update(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg), C.float(spacing), C.bool(window_reappearing))

	selfFin()
}

func (self *MenuColumns) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiMenuColumns_destroy(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg))

	selfFin()
}

func InternalNewMultiSelectState() *MultiSelectState {
	return NewMultiSelectStateFromC(C.ImGuiMultiSelectState_ImGuiMultiSelectState())
}

func (self *MultiSelectState) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiMultiSelectState_destroy(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg))

	selfFin()
}

// Zero-clear except IO as we preserve IO.Requests[] buffer allocation.
func (self *MultiSelectTempData) InternalClear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiMultiSelectTempData_Clear(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))

	selfFin()
}

func (self *MultiSelectTempData) InternalClearIO() {
	selfArg, selfFin := self.Handle()
	C.ImGuiMultiSelectTempData_ClearIO(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))

	selfFin()
}

func InternalNewMultiSelectTempData() *MultiSelectTempData {
	return NewMultiSelectTempDataFromC(C.ImGuiMultiSelectTempData_ImGuiMultiSelectTempData())
}

func (self *MultiSelectTempData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiMultiSelectTempData_destroy(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))

	selfFin()
}

func (self *NavItemData) InternalClear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiNavItemData_Clear(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg))

	selfFin()
}

func InternalNewNavItemData() *NavItemData {
	return NewNavItemDataFromC(C.ImGuiNavItemData_ImGuiNavItemData())
}

func (self *NavItemData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiNavItemData_destroy(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg))

	selfFin()
}

// Also cleared manually by ItemAdd()!
func (self *NextItemData) InternalClearFlags() {
	selfArg, selfFin := self.Handle()
	C.ImGuiNextItemData_ClearFlags(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg))

	selfFin()
}

func InternalNewNextItemData() *NextItemData {
	return NewNextItemDataFromC(C.ImGuiNextItemData_ImGuiNextItemData())
}

func (self *NextItemData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiNextItemData_destroy(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg))

	selfFin()
}

func (self *NextWindowData) InternalClearFlags() {
	selfArg, selfFin := self.Handle()
	C.ImGuiNextWindowData_ClearFlags(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))

	selfFin()
}

func InternalNewNextWindowData() *NextWindowData {
	return NewNextWindowDataFromC(C.ImGuiNextWindowData_ImGuiNextWindowData())
}

func (self *NextWindowData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiNextWindowData_destroy(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))

	selfFin()
}

func InternalNewOldColumnData() *OldColumnData {
	return NewOldColumnDataFromC(C.ImGuiOldColumnData_ImGuiOldColumnData())
}

func (self *OldColumnData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiOldColumnData_destroy(internal.ReinterpretCast[*C.ImGuiOldColumnData](selfArg))

	selfFin()
}

func InternalNewOldColumns() *OldColumns {
	return NewOldColumnsFromC(C.ImGuiOldColumns_ImGuiOldColumns())
}

func (self *OldColumns) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiOldColumns_destroy(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg))

	selfFin()
}

func NewOnceUponAFrame() *OnceUponAFrame {
	return NewOnceUponAFrameFromC(C.ImGuiOnceUponAFrame_ImGuiOnceUponAFrame())
}

func (self *OnceUponAFrame) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiOnceUponAFrame_destroy(internal.ReinterpretCast[*C.ImGuiOnceUponAFrame](selfArg))

	selfFin()
}

func (self *Payload) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiPayload_Clear(internal.ReinterpretCast[*C.ImGuiPayload](selfArg))

	selfFin()
}

func NewPayload() *Payload {
	return NewPayloadFromC(C.ImGuiPayload_ImGuiPayload())
}

func (self *Payload) IsDataType(typeArg string) bool {
	selfArg, selfFin := self.Handle()
	typeArgArg, typeArgFin := internal.WrapString[C.char](typeArg)

	defer func() {
		selfFin()
		typeArgFin()
	}()
	return C.ImGuiPayload_IsDataType(internal.ReinterpretCast[*C.ImGuiPayload](selfArg), typeArgArg) == C.bool(true)
}

func (self *Payload) IsDelivery() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiPayload_IsDelivery(internal.ReinterpretCast[*C.ImGuiPayload](selfArg)) == C.bool(true)
}

func (self *Payload) IsPreview() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiPayload_IsPreview(internal.ReinterpretCast[*C.ImGuiPayload](selfArg)) == C.bool(true)
}

func (self *Payload) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiPayload_destroy(internal.ReinterpretCast[*C.ImGuiPayload](selfArg))

	selfFin()
}

func NewPlatformIO() *PlatformIO {
	return NewPlatformIOFromC(C.ImGuiPlatformIO_ImGuiPlatformIO())
}

func (self *PlatformIO) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiPlatformIO_destroy(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg))

	selfFin()
}

func NewPlatformImeData() *PlatformImeData {
	return NewPlatformImeDataFromC(C.ImGuiPlatformImeData_ImGuiPlatformImeData())
}

func (self *PlatformImeData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiPlatformImeData_destroy(internal.ReinterpretCast[*C.ImGuiPlatformImeData](selfArg))

	selfFin()
}

func NewPlatformMonitor() *PlatformMonitor {
	return NewPlatformMonitorFromC(C.ImGuiPlatformMonitor_ImGuiPlatformMonitor())
}

func (self *PlatformMonitor) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiPlatformMonitor_destroy(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](selfArg))

	selfFin()
}

func InternalNewPopupData() *PopupData {
	return NewPopupDataFromC(C.ImGuiPopupData_ImGuiPopupData())
}

func (self *PopupData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiPopupData_destroy(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg))

	selfFin()
}

func InternalNewPtrOrIndexInt(index int32) *PtrOrIndex {
	return NewPtrOrIndexFromC(C.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int(C.int(index)))
}

func InternalNewPtrOrIndexPtr(ptr uintptr) *PtrOrIndex {
	return NewPtrOrIndexFromC(C.wrap_ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr(C.uintptr_t(ptr)))
}

func (self *PtrOrIndex) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiPtrOrIndex_destroy(internal.ReinterpretCast[*C.ImGuiPtrOrIndex](selfArg))

	selfFin()
}

// Apply selection requests coming from BeginMultiSelect() and EndMultiSelect() functions. It uses 'items_count' passed to BeginMultiSelect()
func (self *SelectionBasicStorage) ApplyRequests(ms_io *MultiSelectIO) {
	selfArg, selfFin := self.Handle()
	ms_ioArg, ms_ioFin := ms_io.Handle()
	C.ImGuiSelectionBasicStorage_ApplyRequests(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg), internal.ReinterpretCast[*C.ImGuiMultiSelectIO](ms_ioArg))

	selfFin()
	ms_ioFin()
}

// Clear selection
func (self *SelectionBasicStorage) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiSelectionBasicStorage_Clear(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg))

	selfFin()
}

// Query if an item id is in selection.
func (self *SelectionBasicStorage) Contains(id ID) bool {
	selfArg, selfFin := self.Handle()
	idArg, idFin := id.C()

	defer func() {
		selfFin()
		idFin()
	}()
	return C.ImGuiSelectionBasicStorage_Contains(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](idArg)) == C.bool(true)
}

// Convert index to item id based on provided adapter.
func (self *SelectionBasicStorage) StorageIdFromIndex(idx int32) ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.ImGuiSelectionBasicStorage_GetStorageIdFromIndex(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg), C.int(idx))
		return &result
	}())
}

func NewSelectionBasicStorage() *SelectionBasicStorage {
	return NewSelectionBasicStorageFromC(C.ImGuiSelectionBasicStorage_ImGuiSelectionBasicStorage())
}

// Add/remove an item from selection (generally done by ApplyRequests() function)
func (self *SelectionBasicStorage) SetItemSelected(id ID, selected bool) {
	selfArg, selfFin := self.Handle()
	idArg, idFin := id.C()
	C.ImGuiSelectionBasicStorage_SetItemSelected(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](idArg), C.bool(selected))

	selfFin()
	idFin()
}

// Swap two selections
func (self *SelectionBasicStorage) Swap(r *SelectionBasicStorage) {
	selfArg, selfFin := self.Handle()
	rArg, rFin := r.Handle()
	C.ImGuiSelectionBasicStorage_Swap(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg), internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](rArg))

	selfFin()
	rFin()
}

func (self *SelectionBasicStorage) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiSelectionBasicStorage_destroy(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg))

	selfFin()
}

// Apply selection requests by using AdapterSetItemSelected() calls
func (self *SelectionExternalStorage) ApplyRequests(ms_io *MultiSelectIO) {
	selfArg, selfFin := self.Handle()
	ms_ioArg, ms_ioFin := ms_io.Handle()
	C.ImGuiSelectionExternalStorage_ApplyRequests(internal.ReinterpretCast[*C.ImGuiSelectionExternalStorage](selfArg), internal.ReinterpretCast[*C.ImGuiMultiSelectIO](ms_ioArg))

	selfFin()
	ms_ioFin()
}

func NewSelectionExternalStorage() *SelectionExternalStorage {
	return NewSelectionExternalStorageFromC(C.ImGuiSelectionExternalStorage_ImGuiSelectionExternalStorage())
}

func (self *SelectionExternalStorage) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiSelectionExternalStorage_destroy(internal.ReinterpretCast[*C.ImGuiSelectionExternalStorage](selfArg))

	selfFin()
}

func InternalNewSettingsHandler() *SettingsHandler {
	return NewSettingsHandlerFromC(C.ImGuiSettingsHandler_ImGuiSettingsHandler())
}

func (self *SettingsHandler) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiSettingsHandler_destroy(internal.ReinterpretCast[*C.ImGuiSettingsHandler](selfArg))

	selfFin()
}

func InternalNewStackLevelInfo() *StackLevelInfo {
	return NewStackLevelInfoFromC(C.ImGuiStackLevelInfo_ImGuiStackLevelInfo())
}

func (self *StackLevelInfo) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiStackLevelInfo_destroy(internal.ReinterpretCast[*C.ImGuiStackLevelInfo](selfArg))

	selfFin()
}

func NewStoragePairFloat(_key ID, _val float32) *StoragePair {
	_keyArg, _keyFin := _key.C()

	defer func() {
		_keyFin()
	}()
	return NewStoragePairFromC(C.ImGuiStoragePair_ImGuiStoragePair_Float(internal.ReinterpretCast[C.ImGuiID](_keyArg), C.float(_val)))
}

func NewStoragePairInt(_key ID, _val int32) *StoragePair {
	_keyArg, _keyFin := _key.C()

	defer func() {
		_keyFin()
	}()
	return NewStoragePairFromC(C.ImGuiStoragePair_ImGuiStoragePair_Int(internal.ReinterpretCast[C.ImGuiID](_keyArg), C.int(_val)))
}

func NewStoragePairPtr(_key ID, _val uintptr) *StoragePair {
	_keyArg, _keyFin := _key.C()

	defer func() {
		_keyFin()
	}()
	return NewStoragePairFromC(C.wrap_ImGuiStoragePair_ImGuiStoragePair_Ptr(internal.ReinterpretCast[C.ImGuiID](_keyArg), C.uintptr_t(_val)))
}

func (self *StoragePair) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiStoragePair_destroy(internal.ReinterpretCast[*C.ImGuiStoragePair](selfArg))

	selfFin()
}

func (self *Storage) BuildSortByKey() {
	selfArg, selfFin := self.Handle()
	C.ImGuiStorage_BuildSortByKey(internal.ReinterpretCast[*C.ImGuiStorage](selfArg))

	selfFin()
}

func (self *Storage) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiStorage_Clear(internal.ReinterpretCast[*C.ImGuiStorage](selfArg))

	selfFin()
}

// BoolV parameter default value hint:
// default_val: false
func (self *Storage) BoolV(key ID, default_val bool) bool {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return C.ImGuiStorage_GetBool(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.bool(default_val)) == C.bool(true)
}

// BoolRefV parameter default value hint:
// default_val: false
func (self *Storage) BoolRefV(key ID, default_val bool) *bool {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*bool)(C.ImGuiStorage_GetBoolRef(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.bool(default_val)))
}

// FloatV parameter default value hint:
// default_val: 0.0f
func (self *Storage) FloatV(key ID, default_val float32) float32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return float32(C.ImGuiStorage_GetFloat(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.float(default_val)))
}

// FloatRefV parameter default value hint:
// default_val: 0.0f
func (self *Storage) FloatRefV(key ID, default_val float32) *float32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*float32)(C.ImGuiStorage_GetFloatRef(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.float(default_val)))
}

// IntV parameter default value hint:
// default_val: 0
func (self *Storage) IntV(key ID, default_val int32) int32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return int32(C.ImGuiStorage_GetInt(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.int(default_val)))
}

// IntRefV parameter default value hint:
// default_val: 0
func (self *Storage) IntRefV(key ID, default_val int32) *int32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*int32)(C.ImGuiStorage_GetIntRef(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.int(default_val)))
}

// default_val is NULL
func (self *Storage) VoidPtr(key ID) uintptr {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return uintptr(C.wrap_ImGuiStorage_GetVoidPtr(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg)))
}

func (self *Storage) SetAllInt(val int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiStorage_SetAllInt(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), C.int(val))

	selfFin()
}

func (self *Storage) SetBool(key ID, val bool) {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()
	C.ImGuiStorage_SetBool(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.bool(val))

	selfFin()
	keyFin()
}

func (self *Storage) SetFloat(key ID, val float32) {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()
	C.ImGuiStorage_SetFloat(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.float(val))

	selfFin()
	keyFin()
}

func (self *Storage) SetInt(key ID, val int32) {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()
	C.ImGuiStorage_SetInt(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.int(val))

	selfFin()
	keyFin()
}

func (self *Storage) SetVoidPtr(key ID, val uintptr) {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()
	C.wrap_ImGuiStorage_SetVoidPtr(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg), C.uintptr_t(val))

	selfFin()
	keyFin()
}

func InternalNewStyleModFloat(idx StyleVar, v float32) *StyleMod {
	return NewStyleModFromC(C.ImGuiStyleMod_ImGuiStyleMod_Float(C.ImGuiStyleVar(idx), C.float(v)))
}

func InternalNewStyleModInt(idx StyleVar, v int32) *StyleMod {
	return NewStyleModFromC(C.ImGuiStyleMod_ImGuiStyleMod_Int(C.ImGuiStyleVar(idx), C.int(v)))
}

func InternalNewStyleModVec2(idx StyleVar, v Vec2) *StyleMod {
	return NewStyleModFromC(C.ImGuiStyleMod_ImGuiStyleMod_Vec2(C.ImGuiStyleVar(idx), internal.ReinterpretCast[C.ImVec2](v.ToC())))
}

func (self *StyleMod) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiStyleMod_destroy(internal.ReinterpretCast[*C.ImGuiStyleMod](selfArg))

	selfFin()
}

func NewStyle() *Style {
	return NewStyleFromC(C.ImGuiStyle_ImGuiStyle())
}

func (self *Style) ScaleAllSizes(scale_factor float32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiStyle_ScaleAllSizes(internal.ReinterpretCast[*C.ImGuiStyle](selfArg), C.float(scale_factor))

	selfFin()
}

func (self *Style) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiStyle_destroy(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))

	selfFin()
}

func InternalNewTabBar() *TabBar {
	return NewTabBarFromC(C.ImGuiTabBar_ImGuiTabBar())
}

func (self *TabBar) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTabBar_destroy(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))

	selfFin()
}

func InternalNewTabItem() *TabItem {
	return NewTabItemFromC(C.ImGuiTabItem_ImGuiTabItem())
}

func (self *TabItem) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTabItem_destroy(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg))

	selfFin()
}

func InternalNewTableColumnSettings() *TableColumnSettings {
	return NewTableColumnSettingsFromC(C.ImGuiTableColumnSettings_ImGuiTableColumnSettings())
}

func (self *TableColumnSettings) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTableColumnSettings_destroy(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg))

	selfFin()
}

func NewTableColumnSortSpecs() *TableColumnSortSpecs {
	return NewTableColumnSortSpecsFromC(C.ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs())
}

func (self *TableColumnSortSpecs) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTableColumnSortSpecs_destroy(internal.ReinterpretCast[*C.ImGuiTableColumnSortSpecs](selfArg))

	selfFin()
}

func InternalNewTableColumn() *TableColumn {
	return NewTableColumnFromC(C.ImGuiTableColumn_ImGuiTableColumn())
}

func (self *TableColumn) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTableColumn_destroy(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))

	selfFin()
}

func InternalNewTableInstanceData() *TableInstanceData {
	return NewTableInstanceDataFromC(C.ImGuiTableInstanceData_ImGuiTableInstanceData())
}

func (self *TableInstanceData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTableInstanceData_destroy(internal.ReinterpretCast[*C.ImGuiTableInstanceData](selfArg))

	selfFin()
}

func (self *TableSettings) InternalColumnSettings() *TableColumnSettings {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewTableColumnSettingsFromC(C.ImGuiTableSettings_GetColumnSettings(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg)))
}

func InternalNewTableSettings() *TableSettings {
	return NewTableSettingsFromC(C.ImGuiTableSettings_ImGuiTableSettings())
}

func (self *TableSettings) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTableSettings_destroy(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg))

	selfFin()
}

func NewTableSortSpecs() *TableSortSpecs {
	return NewTableSortSpecsFromC(C.ImGuiTableSortSpecs_ImGuiTableSortSpecs())
}

func (self *TableSortSpecs) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTableSortSpecs_destroy(internal.ReinterpretCast[*C.ImGuiTableSortSpecs](selfArg))

	selfFin()
}

func InternalNewTableTempData() *TableTempData {
	return NewTableTempDataFromC(C.ImGuiTableTempData_ImGuiTableTempData())
}

func (self *TableTempData) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTableTempData_destroy(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))

	selfFin()
}

func InternalNewTable() *Table {
	return NewTableFromC(C.ImGuiTable_ImGuiTable())
}

func (self *Table) InternalDestroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTable_destroy(internal.ReinterpretCast[*C.ImGuiTable](selfArg))

	selfFin()
}

func NewTextBuffer() *TextBuffer {
	return NewTextBufferFromC(C.ImGuiTextBuffer_ImGuiTextBuffer())
}

// AppendV parameter default value hint:
// str_end: NULL
func (self *TextBuffer) AppendV(str string, str_end string) {
	selfArg, selfFin := self.Handle()
	strArg, strFin := internal.WrapString[C.char](str)
	str_endArg, str_endFin := internal.WrapString[C.char](str_end)
	C.ImGuiTextBuffer_append(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg), strArg, str_endArg)

	selfFin()
	strFin()
	str_endFin()
}

func (self *TextBuffer) Begin() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.ImGuiTextBuffer_begin(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func (self *TextBuffer) cstr() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.ImGuiTextBuffer_c_str(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func (self *TextBuffer) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextBuffer_clear(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg))

	selfFin()
}

func (self *TextBuffer) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextBuffer_destroy(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg))

	selfFin()
}

func (self *TextBuffer) Empty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiTextBuffer_empty(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg)) == C.bool(true)
}

// Buf is zero-terminated, so end() will point on the zero-terminator
func (self *TextBuffer) End() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.ImGuiTextBuffer_end(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func (self *TextBuffer) Reserve(capacity int32) {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextBuffer_reserve(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg), C.int(capacity))

	selfFin()
}

func (self *TextBuffer) Size() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiTextBuffer_size(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg)))
}

func (self *TextFilter) Build() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextFilter_Build(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg))

	selfFin()
}

func (self *TextFilter) Clear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextFilter_Clear(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg))

	selfFin()
}

// Helper calling InputText+Build
// DrawV parameter default value hint:
// label: "Filter(inc,-exc)"
// width: 0.0f
func (self *TextFilter) DrawV(label string, width float32) bool {
	selfArg, selfFin := self.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		selfFin()
		labelFin()
	}()
	return C.ImGuiTextFilter_Draw(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg), labelArg, C.float(width)) == C.bool(true)
}

// NewTextFilter parameter default value hint:
// default_filter: ""
func NewTextFilter(default_filter string) *TextFilter {
	default_filterArg, default_filterFin := internal.WrapString[C.char](default_filter)

	defer func() {
		default_filterFin()
	}()
	return NewTextFilterFromC(C.ImGuiTextFilter_ImGuiTextFilter(default_filterArg))
}

func (self *TextFilter) IsActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiTextFilter_IsActive(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg)) == C.bool(true)
}

// PassFilterV parameter default value hint:
func (self *TextFilter) PassFilterV(text string) bool {
	selfArg, selfFin := self.Handle()
	textArg, textFin := internal.WrapString[C.char](text)

	defer func() {
		selfFin()
		textFin()
	}()
	return C.wrap_ImGuiTextFilter_PassFilterV(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg), textArg, C.int(len(text))) == C.bool(true)
}

func (self *TextFilter) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextFilter_destroy(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg))

	selfFin()
}

func (self *TextIndex) InternalAppend(base string, old_size int32, new_size int32) {
	selfArg, selfFin := self.Handle()
	baseArg, baseFin := internal.WrapString[C.char](base)
	C.ImGuiTextIndex_append(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg), baseArg, C.int(old_size), C.int(new_size))

	selfFin()
	baseFin()
}

func (self *TextIndex) InternalClear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextIndex_clear(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg))

	selfFin()
}

func (self *TextIndex) Internalgetlinebegin(base string, n int32) string {
	selfArg, selfFin := self.Handle()
	baseArg, baseFin := internal.WrapString[C.char](base)

	defer func() {
		selfFin()
		baseFin()
	}()
	return func() string {
		result := C.ImGuiTextIndex_get_line_begin(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg), baseArg, C.int(n))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func (self *TextIndex) Internalgetlineend(base string, n int32) string {
	selfArg, selfFin := self.Handle()
	baseArg, baseFin := internal.WrapString[C.char](base)

	defer func() {
		selfFin()
		baseFin()
	}()
	return func() string {
		result := C.ImGuiTextIndex_get_line_end(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg), baseArg, C.int(n))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func (self *TextIndex) InternalSize() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.ImGuiTextIndex_size(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg)))
}

func NewTextRangeNil() *TextRange {
	return NewTextRangeFromC(C.ImGuiTextRange_ImGuiTextRange_Nil())
}

func NewTextRangeStr(_b string, _e string) *TextRange {
	_bArg, _bFin := internal.WrapString[C.char](_b)
	_eArg, _eFin := internal.WrapString[C.char](_e)

	defer func() {
		_bFin()
		_eFin()
	}()
	return NewTextRangeFromC(C.ImGuiTextRange_ImGuiTextRange_Str(_bArg, _eArg))
}

func (self *TextRange) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTextRange_destroy(internal.ReinterpretCast[*C.ImGuiTextRange](selfArg))

	selfFin()
}

func (self *TextRange) Empty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.ImGuiTextRange_empty(internal.ReinterpretCast[*C.ImGuiTextRange](selfArg)) == C.bool(true)
}

// We preserve remaining data for easier debugging
func (self *TypingSelectState) InternalClear() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTypingSelectState_Clear(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg))

	selfFin()
}

func InternalNewTypingSelectState() *TypingSelectState {
	return NewTypingSelectStateFromC(C.ImGuiTypingSelectState_ImGuiTypingSelectState())
}

func (self *TypingSelectState) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiTypingSelectState_destroy(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg))

	selfFin()
}

func (self *ViewportP) InternalCalcWorkRectPos(inset_min Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_CalcWorkRectPos(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiViewportP](selfArg), internal.ReinterpretCast[C.ImVec2](inset_min.ToC()))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalCalcWorkRectSize(inset_min Vec2, inset_max Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_CalcWorkRectSize(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiViewportP](selfArg), internal.ReinterpretCast[C.ImVec2](inset_min.ToC()), internal.ReinterpretCast[C.ImVec2](inset_max.ToC()))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalClearRequestFlags() {
	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_ClearRequestFlags(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))

	selfFin()
}

func (self *ViewportP) InternalBuildWorkRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_GetBuildWorkRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalMainRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_GetMainRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *ViewportP) InternalWorkRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_GetWorkRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func InternalNewViewportP() *ViewportP {
	return NewViewportPFromC(C.ImGuiViewportP_ImGuiViewportP())
}

// Update public fields
func (self *ViewportP) InternalUpdateWorkRect() {
	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_UpdateWorkRect(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))

	selfFin()
}

func (self *ViewportP) InternalDestroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiViewportP_destroy(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))

	selfFin()
}

func (self *Viewport) Center() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiViewport_GetCenter(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiViewport](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Viewport) WorkCenter() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiViewport_GetWorkCenter(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiViewport](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func NewViewport() *Viewport {
	return NewViewportFromC(C.ImGuiViewport_ImGuiViewport())
}

func (self *Viewport) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiViewport_destroy(internal.ReinterpretCast[*C.ImGuiViewport](selfArg))

	selfFin()
}

func NewWindowClass() *WindowClass {
	return NewWindowClassFromC(C.ImGuiWindowClass_ImGuiWindowClass())
}

func (self *WindowClass) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiWindowClass_destroy(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg))

	selfFin()
}

func (self *WindowSettings) InternalName() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.ImGuiWindowSettings_GetName(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalNewWindowSettings() *WindowSettings {
	return NewWindowSettingsFromC(C.ImGuiWindowSettings_ImGuiWindowSettings())
}

func (self *WindowSettings) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiWindowSettings_destroy(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg))

	selfFin()
}

func (self *Window) InternalCalcFontSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.ImGuiWindow_CalcFontSize(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

func (self *Window) InternalIDFromPos(p_abs Vec2) ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.ImGuiWindow_GetIDFromPos(internal.ReinterpretCast[*C.ImGuiWindow](selfArg), internal.ReinterpretCast[C.ImVec2](p_abs.ToC()))
		return &result
	}())
}

func (self *Window) InternalIDFromRectangle(r_abs Rect) ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.ImGuiWindow_GetIDFromRectangle(internal.ReinterpretCast[*C.ImGuiWindow](selfArg), internal.ReinterpretCast[C.ImRect](r_abs.ToC()))
		return &result
	}())
}

func (self *Window) InternalIDInt(n int32) ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.ImGuiWindow_GetID_Int(internal.ReinterpretCast[*C.ImGuiWindow](selfArg), C.int(n))
		return &result
	}())
}

func (self *Window) InternalIDPtr(ptr uintptr) ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetID_Ptr(internal.ReinterpretCast[*C.ImGuiWindow](selfArg), C.uintptr_t(ptr))
		return &result
	}())
}

// InternalIDStrV parameter default value hint:
// str_end: NULL
func (self *Window) InternalIDStrV(str string, str_end string) ID {
	selfArg, selfFin := self.Handle()
	strArg, strFin := internal.WrapString[C.char](str)
	str_endArg, str_endFin := internal.WrapString[C.char](str_end)

	defer func() {
		selfFin()
		strFin()
		str_endFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.ImGuiWindow_GetID_Str(internal.ReinterpretCast[*C.ImGuiWindow](selfArg), strArg, str_endArg)
		return &result
	}())
}

func InternalNewWindow(context *Context, name string) *Window {
	contextArg, contextFin := context.Handle()
	nameArg, nameFin := internal.WrapString[C.char](name)

	defer func() {
		contextFin()
		nameFin()
	}()
	return NewWindowFromC(C.ImGuiWindow_ImGuiWindow(internal.ReinterpretCast[*C.ImGuiContext](contextArg), nameArg))
}

func (self *Window) InternalMenuBarRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiWindow_MenuBarRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Window) InternalRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiWindow_Rect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Window) InternalTitleBarRect() Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	C.ImGuiWindow_TitleBarRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Window) InternalDestroy() {
	selfArg, selfFin := self.Handle()
	C.ImGuiWindow_destroy(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))

	selfFin()
}

func (self *Rect) InternalAddRect(r Rect) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_Add_Rect(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImRect](r.ToC()))

	selfFin()
}

func (self *Rect) InternalAddVec2(p Vec2) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_Add_Vec2(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImVec2](p.ToC()))

	selfFin()
}

// Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
func (self *Rect) InternalClipWith(r Rect) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_ClipWith(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImRect](r.ToC()))

	selfFin()
}

// Full version, ensure both points are fully clipped.
func (self *Rect) InternalClipWithFull(r Rect) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_ClipWithFull(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImRect](r.ToC()))

	selfFin()
}

func (self *Rect) InternalContainsWithPad(p Vec2, pad Vec2) bool {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_ContainsWithPad(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImVec2](p.ToC()), internal.ReinterpretCast[C.ImVec2](pad.ToC())) == C.bool(true)
}

func (self *Rect) InternalContainsRect(r Rect) bool {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_Contains_Rect(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImRect](r.ToC())) == C.bool(true)
}

func (self *Rect) InternalContainsVec2(p Vec2) bool {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_Contains_Vec2(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImVec2](p.ToC())) == C.bool(true)
}

func (self *Rect) InternalExpandFloat(amount float32) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_Expand_Float(internal.ReinterpretCast[*C.ImRect](selfArg), C.float(amount))

	selfFin()
}

func (self *Rect) InternalExpandVec2(amount Vec2) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_Expand_Vec2(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImVec2](amount.ToC()))

	selfFin()
}

func (self *Rect) InternalFloor() {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_Floor(internal.ReinterpretCast[*C.ImRect](selfArg))

	selfFin()
}

func (self *Rect) InternalArea() float32 {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return float32(C.ImRect_GetArea(internal.ReinterpretCast[*C.ImRect](selfArg)))
}

// Bottom-left
func (self *Rect) InternalBL() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_GetBL(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImRect](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

// Bottom-right
func (self *Rect) InternalBR() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_GetBR(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImRect](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalCenter() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_GetCenter(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImRect](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalHeight() float32 {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return float32(C.ImRect_GetHeight(internal.ReinterpretCast[*C.ImRect](selfArg)))
}

func (self *Rect) InternalSize() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_GetSize(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImRect](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

// Top-left
func (self *Rect) InternalTL() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_GetTL(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImRect](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

// Top-right
func (self *Rect) InternalTR() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_GetTR(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImRect](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalWidth() float32 {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return float32(C.ImRect_GetWidth(internal.ReinterpretCast[*C.ImRect](selfArg)))
}

func (self *Rect) InternalIsInverted() bool {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_IsInverted(internal.ReinterpretCast[*C.ImRect](selfArg)) == C.bool(true)
}

func (self *Rect) InternalOverlaps(r Rect) bool {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return C.ImRect_Overlaps(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImRect](r.ToC())) == C.bool(true)
}

func (self *Rect) InternalToVec4() Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_ToVec4(internal.ReinterpretCast[*C.ImVec4](pOutArg), internal.ReinterpretCast[*C.ImRect](selfArg))

	pOutFin()
	selfFin()

	return *pOut
}

func (self *Rect) InternalTranslate(d Vec2) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_Translate(internal.ReinterpretCast[*C.ImRect](selfArg), internal.ReinterpretCast[C.ImVec2](d.ToC()))

	selfFin()
}

func (self *Rect) InternalTranslateX(dx float32) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_TranslateX(internal.ReinterpretCast[*C.ImRect](selfArg), C.float(dx))

	selfFin()
}

func (self *Rect) InternalTranslateY(dy float32) {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_TranslateY(internal.ReinterpretCast[*C.ImRect](selfArg), C.float(dy))

	selfFin()
}

func (self *Rect) Destroy() {
	selfArg, selfFin := internal.Wrap(self)
	C.ImRect_destroy(internal.ReinterpretCast[*C.ImRect](selfArg))

	selfFin()
}

func InternalNewVec1Float(_x float32) *Vec1 {
	return NewVec1FromC(C.ImVec1_ImVec1_Float(C.float(_x)))
}

func InternalNewVec1Nil() *Vec1 {
	return NewVec1FromC(C.ImVec1_ImVec1_Nil())
}

func (self *Vec1) Destroy() {
	selfArg, selfFin := self.Handle()
	C.ImVec1_destroy(internal.ReinterpretCast[*C.ImVec1](selfArg))

	selfFin()
}

func (self *Vec2) Destroy() {
	selfArg, selfFin := internal.Wrap(self)
	C.ImVec2_destroy(internal.ReinterpretCast[*C.ImVec2](selfArg))

	selfFin()
}

func (self *Vec4) Destroy() {
	selfArg, selfFin := internal.Wrap(self)
	C.ImVec4_destroy(internal.ReinterpretCast[*C.ImVec4](selfArg))

	selfFin()
}

// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
// AcceptDragDropPayloadV parameter default value hint:
// flags: 0
func AcceptDragDropPayloadV(typeArg string, flags DragDropFlags) *Payload {
	typeArgArg, typeArgFin := internal.WrapString[C.char](typeArg)

	defer func() {
		typeArgFin()
	}()
	return NewPayloadFromC(C.igAcceptDragDropPayload(typeArgArg, C.ImGuiDragDropFlags(flags)))
}

// Activate an item by ID (button, checkbox, tree node etc.). Activation is queued and processed on the next frame when the item is encountered again.
func InternalActivateItemByID(id ID) {
	idArg, idFin := id.C()
	C.igActivateItemByID(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

func InternalAddContextHook(context *Context, hook *ContextHook) ID {
	contextArg, contextFin := context.Handle()
	hookArg, hookFin := hook.Handle()

	defer func() {
		contextFin()
		hookFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igAddContextHook(internal.ReinterpretCast[*C.ImGuiContext](contextArg), internal.ReinterpretCast[*C.ImGuiContextHook](hookArg))
		return &result
	}())
}

func InternalAddSettingsHandler(handler *SettingsHandler) {
	handlerArg, handlerFin := handler.Handle()
	C.igAddSettingsHandler(internal.ReinterpretCast[*C.ImGuiSettingsHandler](handlerArg))

	handlerFin()
}

// vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
func AlignTextToFramePadding() {
	C.igAlignTextToFramePadding()
}

// square button with an arrow shape
func ArrowButton(str_id string, dir Dir) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igArrowButton(str_idArg, C.ImGuiDir(dir)) == C.bool(true)
}

// InternalArrowButtonExV parameter default value hint:
// flags: 0
func InternalArrowButtonExV(str_id string, dir Dir, size_arg Vec2, flags ButtonFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igArrowButtonEx(str_idArg, C.ImGuiDir(dir), internal.ReinterpretCast[C.ImVec2](size_arg.ToC()), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

// BeginV parameter default value hint:
// p_open: NULL
// flags: 0
func BeginV(name string, p_open *bool, flags WindowFlags) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)

	defer func() {
		nameFin()
		p_openFin()
	}()
	return C.igBegin(nameArg, p_openArg, C.ImGuiWindowFlags(flags)) == C.bool(true)
}

func InternalBeginBoxSelect(scope_rect Rect, window *Window, box_select_id ID, ms_flags MultiSelectFlags) bool {
	windowArg, windowFin := window.Handle()
	box_select_idArg, box_select_idFin := box_select_id.C()

	defer func() {
		windowFin()
		box_select_idFin()
	}()
	return C.igBeginBoxSelect(internal.ReinterpretCast[C.ImRect](scope_rect.ToC()), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImGuiID](box_select_idArg), C.ImGuiMultiSelectFlags(ms_flags)) == C.bool(true)
}

func InternalBeginChildEx(name string, id ID, size_arg Vec2, child_flags ChildFlags, window_flags WindowFlags) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)
	idArg, idFin := id.C()

	defer func() {
		nameFin()
		idFin()
	}()
	return C.igBeginChildEx(nameArg, internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[C.ImVec2](size_arg.ToC()), C.ImGuiChildFlags(child_flags), C.ImGuiWindowFlags(window_flags)) == C.bool(true)
}

// BeginChildIDV parameter default value hint:
// size: ImVec2(0,0)
// child_flags: 0
// window_flags: 0
func BeginChildIDV(id ID, size Vec2, child_flags ChildFlags, window_flags WindowFlags) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igBeginChild_ID(internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiChildFlags(child_flags), C.ImGuiWindowFlags(window_flags)) == C.bool(true)
}

// BeginChildStrV parameter default value hint:
// size: ImVec2(0,0)
// child_flags: 0
// window_flags: 0
func BeginChildStrV(str_id string, size Vec2, child_flags ChildFlags, window_flags WindowFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginChild_Str(str_idArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiChildFlags(child_flags), C.ImGuiWindowFlags(window_flags)) == C.bool(true)
}

// setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
// InternalBeginColumnsV parameter default value hint:
// flags: 0
func InternalBeginColumnsV(str_id string, count int32, flags OldColumnFlags) {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	C.igBeginColumns(str_idArg, C.int(count), C.ImGuiOldColumnFlags(flags))

	str_idFin()
}

// BeginComboV parameter default value hint:
// flags: 0
func BeginComboV(label string, preview_value string, flags ComboFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	preview_valueArg, preview_valueFin := internal.WrapString[C.char](preview_value)

	defer func() {
		labelFin()
		preview_valueFin()
	}()
	return C.igBeginCombo(labelArg, preview_valueArg, C.ImGuiComboFlags(flags)) == C.bool(true)
}

func InternalBeginComboPopup(popup_id ID, bb Rect, flags ComboFlags) bool {
	popup_idArg, popup_idFin := popup_id.C()

	defer func() {
		popup_idFin()
	}()
	return C.igBeginComboPopup(internal.ReinterpretCast[C.ImGuiID](popup_idArg), internal.ReinterpretCast[C.ImRect](bb.ToC()), C.ImGuiComboFlags(flags)) == C.bool(true)
}

func InternalBeginComboPreview() bool {
	return C.igBeginComboPreview() == C.bool(true)
}

// BeginDisabledV parameter default value hint:
// disabled: true
func BeginDisabledV(disabled bool) {
	C.igBeginDisabled(C.bool(disabled))
}

func InternalBeginDisabledOverrideReenable() {
	C.igBeginDisabledOverrideReenable()
}

func InternalBeginDockableDragDropSource(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igBeginDockableDragDropSource(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalBeginDockableDragDropTarget(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igBeginDockableDragDropTarget(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalBeginDocked(window *Window, p_open *bool) {
	windowArg, windowFin := window.Handle()
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)
	C.igBeginDocked(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), p_openArg)

	windowFin()
	p_openFin()
}

// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()
// BeginDragDropSourceV parameter default value hint:
// flags: 0
func BeginDragDropSourceV(flags DragDropFlags) bool {
	return C.igBeginDragDropSource(C.ImGuiDragDropFlags(flags)) == C.bool(true)
}

// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
func BeginDragDropTarget() bool {
	return C.igBeginDragDropTarget() == C.bool(true)
}

func InternalBeginDragDropTargetCustom(bb Rect, id ID) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igBeginDragDropTargetCustom(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg)) == C.bool(true)
}

func InternalBeginErrorTooltip() bool {
	return C.igBeginErrorTooltip() == C.bool(true)
}

// lock horizontal starting position
func BeginGroup() {
	C.igBeginGroup()
}

// begin/append a tooltip window if preceding item was hovered.
func BeginItemTooltip() bool {
	return C.igBeginItemTooltip() == C.bool(true)
}

// open a framed scrolling region
// BeginListBoxV parameter default value hint:
// size: ImVec2(0,0)
func BeginListBoxV(label string, size Vec2) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igBeginListBox(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC())) == C.bool(true)
}

// create and append to a full screen menu-bar.
func BeginMainMenuBar() bool {
	return C.igBeginMainMenuBar() == C.bool(true)
}

// create a sub-menu entry. only call EndMenu() if this returns true!
// BeginMenuV parameter default value hint:
// enabled: true
func BeginMenuV(label string, enabled bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igBeginMenu(labelArg, C.bool(enabled)) == C.bool(true)
}

// append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
func BeginMenuBar() bool {
	return C.igBeginMenuBar() == C.bool(true)
}

// InternalBeginMenuExV parameter default value hint:
// enabled: true
func InternalBeginMenuExV(label string, icon string, enabled bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	iconArg, iconFin := internal.WrapString[C.char](icon)

	defer func() {
		labelFin()
		iconFin()
	}()
	return C.igBeginMenuEx(labelArg, iconArg, C.bool(enabled)) == C.bool(true)
}

// BeginMultiSelectV parameter default value hint:
// selection_size: -1
// items_count: -1
func BeginMultiSelectV(flags MultiSelectFlags, selection_size int32, items_count int32) *MultiSelectIO {
	return NewMultiSelectIOFromC(C.igBeginMultiSelect(C.ImGuiMultiSelectFlags(flags), C.int(selection_size), C.int(items_count)))
}

// return true if the popup is open, and you can start outputting to it.
// BeginPopupV parameter default value hint:
// flags: 0
func BeginPopupV(str_id string, flags WindowFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopup(str_idArg, C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// open+begin popup when clicked on last item. Use str_id==NULL to associate the popup to previous item. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
// BeginPopupContextItemV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func BeginPopupContextItemV(str_id string, popup_flags PopupFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopupContextItem(str_idArg, C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

// open+begin popup when clicked in void (where there are no windows).
// BeginPopupContextVoidV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func BeginPopupContextVoidV(str_id string, popup_flags PopupFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopupContextVoid(str_idArg, C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

// open+begin popup when clicked on current window.
// BeginPopupContextWindowV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func BeginPopupContextWindowV(str_id string, popup_flags PopupFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginPopupContextWindow(str_idArg, C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

func InternalBeginPopupEx(id ID, extra_window_flags WindowFlags) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igBeginPopupEx(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiWindowFlags(extra_window_flags)) == C.bool(true)
}

// return true if the modal is open, and you can start outputting to it.
// BeginPopupModalV parameter default value hint:
// p_open: NULL
// flags: 0
func BeginPopupModalV(name string, p_open *bool, flags WindowFlags) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)

	defer func() {
		nameFin()
		p_openFin()
	}()
	return C.igBeginPopupModal(nameArg, p_openArg, C.ImGuiWindowFlags(flags)) == C.bool(true)
}

// create and append into a TabBar
// BeginTabBarV parameter default value hint:
// flags: 0
func BeginTabBarV(str_id string, flags TabBarFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginTabBar(str_idArg, C.ImGuiTabBarFlags(flags)) == C.bool(true)
}

func InternalBeginTabBarEx(tab_bar *TabBar, bb Rect, flags TabBarFlags) bool {
	tab_barArg, tab_barFin := tab_bar.Handle()

	defer func() {
		tab_barFin()
	}()
	return C.igBeginTabBarEx(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[C.ImRect](bb.ToC()), C.ImGuiTabBarFlags(flags)) == C.bool(true)
}

// create a Tab. Returns true if the Tab is selected.
// BeginTabItemV parameter default value hint:
// p_open: NULL
// flags: 0
func BeginTabItemV(label string, p_open *bool, flags TabItemFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)

	defer func() {
		labelFin()
		p_openFin()
	}()
	return C.igBeginTabItem(labelArg, p_openArg, C.ImGuiTabItemFlags(flags)) == C.bool(true)
}

// BeginTableV parameter default value hint:
// flags: 0
// outer_size: ImVec2(0.0f,0.0f)
// inner_width: 0.0f
func BeginTableV(str_id string, columns int32, flags TableFlags, outer_size Vec2, inner_width float32) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igBeginTable(str_idArg, C.int(columns), C.ImGuiTableFlags(flags), internal.ReinterpretCast[C.ImVec2](outer_size.ToC()), C.float(inner_width)) == C.bool(true)
}

// InternalBeginTableExV parameter default value hint:
// flags: 0
// outer_size: ImVec2(0,0)
// inner_width: 0.0f
func InternalBeginTableExV(name string, id ID, columns_count int32, flags TableFlags, outer_size Vec2, inner_width float32) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)
	idArg, idFin := id.C()

	defer func() {
		nameFin()
		idFin()
	}()
	return C.igBeginTableEx(nameArg, internal.ReinterpretCast[C.ImGuiID](idArg), C.int(columns_count), C.ImGuiTableFlags(flags), internal.ReinterpretCast[C.ImVec2](outer_size.ToC()), C.float(inner_width)) == C.bool(true)
}

// begin/append a tooltip window.
func BeginTooltip() bool {
	return C.igBeginTooltip() == C.bool(true)
}

func InternalBeginTooltipEx(tooltip_flags TooltipFlags, extra_window_flags WindowFlags) bool {
	return C.igBeginTooltipEx(C.ImGuiTooltipFlags(tooltip_flags), C.ImGuiWindowFlags(extra_window_flags)) == C.bool(true)
}

func InternalBeginTooltipHidden() bool {
	return C.igBeginTooltipHidden() == C.bool(true)
}

func InternalBeginViewportSideBar(name string, viewport *Viewport, dir Dir, size float32, window_flags WindowFlags) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)
	viewportArg, viewportFin := viewport.Handle()

	defer func() {
		nameFin()
		viewportFin()
	}()
	return C.igBeginViewportSideBar(nameArg, internal.ReinterpretCast[*C.ImGuiViewport](viewportArg), C.ImGuiDir(dir), C.float(size), C.ImGuiWindowFlags(window_flags)) == C.bool(true)
}

func InternalBringWindowToDisplayBack(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igBringWindowToDisplayBack(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalBringWindowToDisplayBehind(window *Window, above_window *Window) {
	windowArg, windowFin := window.Handle()
	above_windowArg, above_windowFin := above_window.Handle()
	C.igBringWindowToDisplayBehind(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiWindow](above_windowArg))

	windowFin()
	above_windowFin()
}

func InternalBringWindowToDisplayFront(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igBringWindowToDisplayFront(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalBringWindowToFocusFront(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igBringWindowToFocusFront(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

// draw a small circle + keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses
func Bullet() {
	C.igBullet()
}

// shortcut for Bullet()+Text()
func BulletText(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igBulletText(fmtArg)

	fmtFin()
}

// button
// ButtonV parameter default value hint:
// size: ImVec2(0,0)
func ButtonV(label string, size Vec2) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igButton(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC())) == C.bool(true)
}

// InternalButtonBehaviorV parameter default value hint:
// flags: 0
func InternalButtonBehaviorV(bb Rect, id ID, out_hovered *bool, out_held *bool, flags ButtonFlags) bool {
	idArg, idFin := id.C()
	out_hoveredArg, out_hoveredFin := internal.WrapNumberPtr[C.bool, bool](out_hovered)
	out_heldArg, out_heldFin := internal.WrapNumberPtr[C.bool, bool](out_held)

	defer func() {
		idFin()
		out_hoveredFin()
		out_heldFin()
	}()
	return C.igButtonBehavior(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), out_hoveredArg, out_heldArg, C.ImGuiButtonFlags(flags)) == C.bool(true)
}

// InternalButtonExV parameter default value hint:
// size_arg: ImVec2(0,0)
// flags: 0
func InternalButtonExV(label string, size_arg Vec2, flags ButtonFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igButtonEx(labelArg, internal.ReinterpretCast[C.ImVec2](size_arg.ToC()), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

func InternalCalcItemSize(size Vec2, default_w float32, default_h float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igCalcItemSize(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](size.ToC()), C.float(default_w), C.float(default_h))

	pOutFin()

	return *pOut
}

// width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
func CalcItemWidth() float32 {
	return float32(C.igCalcItemWidth())
}

func InternalCalcRoundingFlagsForRectInRect(r_in Rect, r_outer Rect, threshold float32) DrawFlags {
	return DrawFlags(C.igCalcRoundingFlagsForRectInRect(internal.ReinterpretCast[C.ImRect](r_in.ToC()), internal.ReinterpretCast[C.ImRect](r_outer.ToC()), C.float(threshold)))
}

// CalcTextSizeV parameter default value hint:
// hide_text_after_double_hash: false
// wrap_width: -1.0f
func CalcTextSizeV(text string, hide_text_after_double_hash bool, wrap_width float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igCalcTextSizeV(internal.ReinterpretCast[*C.ImVec2](pOutArg), textArg, C.int(len(text)), C.bool(hide_text_after_double_hash), C.float(wrap_width))

	pOutFin()
	textFin()

	return *pOut
}

func InternalCalcTypematicRepeatAmount(t0 float32, t1 float32, repeat_delay float32, repeat_rate float32) int32 {
	return int32(C.igCalcTypematicRepeatAmount(C.float(t0), C.float(t1), C.float(repeat_delay), C.float(repeat_rate)))
}

func InternalCalcWindowNextAutoFitSize(window *Window) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igCalcWindowNextAutoFitSize(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalCalcWrapWidthForPos(pos Vec2, wrap_pos_x float32) float32 {
	return float32(C.igCalcWrapWidthForPos(internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.float(wrap_pos_x)))
}

func InternalCallContextHooks(context *Context, typeArg ContextHookType) {
	contextArg, contextFin := context.Handle()
	C.igCallContextHooks(internal.ReinterpretCast[*C.ImGuiContext](contextArg), C.ImGuiContextHookType(typeArg))

	contextFin()
}

func Checkbox(label string, v *bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.bool, bool](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.igCheckbox(labelArg, vArg) == C.bool(true)
}

func CheckboxFlagsIntPtr(label string, flags *int32, flags_value int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	flagsArg, flagsFin := internal.WrapNumberPtr[C.int, int32](flags)

	defer func() {
		labelFin()
		flagsFin()
	}()
	return C.igCheckboxFlags_IntPtr(labelArg, flagsArg, C.int(flags_value)) == C.bool(true)
}

func InternalCheckboxFlagsS64Ptr(label string, flags *int64, flags_value int64) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	flagsArg, flagsFin := internal.WrapNumberPtr[C.ImS64, int64](flags)

	defer func() {
		labelFin()
		flagsFin()
	}()
	return C.igCheckboxFlags_S64Ptr(labelArg, flagsArg, C.ImS64(flags_value)) == C.bool(true)
}

func InternalCheckboxFlagsU64Ptr(label string, flags *uint64, flags_value uint64) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	flagsArg, flagsFin := internal.WrapNumberPtr[C.ImU64, uint64](flags)

	defer func() {
		labelFin()
		flagsFin()
	}()
	return C.igCheckboxFlags_U64Ptr(labelArg, flagsArg, C.ImU64(flags_value)) == C.bool(true)
}

func CheckboxFlagsUintPtr(label string, flags *uint32, flags_value uint32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	flagsArg, flagsFin := internal.WrapNumberPtr[C.uint, uint32](flags)

	defer func() {
		labelFin()
		flagsFin()
	}()
	return C.igCheckboxFlags_UintPtr(labelArg, flagsArg, C.uint(flags_value)) == C.bool(true)
}

func InternalClearActiveID() {
	C.igClearActiveID()
}

func InternalClearDragDrop() {
	C.igClearDragDrop()
}

func InternalClearIniSettings() {
	C.igClearIniSettings()
}

func InternalClearWindowSettings(name string) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.igClearWindowSettings(nameArg)

	nameFin()
}

func InternalCloseButton(id ID, pos Vec2) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igCloseButton(internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[C.ImVec2](pos.ToC())) == C.bool(true)
}

// manually close the popup we have begin-ed into.
func CloseCurrentPopup() {
	C.igCloseCurrentPopup()
}

func InternalClosePopupToLevel(remaining int32, restore_focus_to_window_under_popup bool) {
	C.igClosePopupToLevel(C.int(remaining), C.bool(restore_focus_to_window_under_popup))
}

func InternalClosePopupsExceptModals() {
	C.igClosePopupsExceptModals()
}

func InternalClosePopupsOverWindow(ref_window *Window, restore_focus_to_window_under_popup bool) {
	ref_windowArg, ref_windowFin := ref_window.Handle()
	C.igClosePopupsOverWindow(internal.ReinterpretCast[*C.ImGuiWindow](ref_windowArg), C.bool(restore_focus_to_window_under_popup))

	ref_windowFin()
}

func InternalCollapseButton(id ID, pos Vec2, dock_node *DockNode) bool {
	idArg, idFin := id.C()
	dock_nodeArg, dock_nodeFin := dock_node.Handle()

	defer func() {
		idFin()
		dock_nodeFin()
	}()
	return C.igCollapseButton(internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), internal.ReinterpretCast[*C.ImGuiDockNode](dock_nodeArg)) == C.bool(true)
}

// when 'p_visible != NULL': if '*p_visible==true' display an additional small close button on upper right of the header which will set the bool to false when clicked, if '*p_visible==false' don't display the header.
// CollapsingHeaderBoolPtrV parameter default value hint:
// flags: 0
func CollapsingHeaderBoolPtrV(label string, p_visible *bool, flags TreeNodeFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	p_visibleArg, p_visibleFin := internal.WrapNumberPtr[C.bool, bool](p_visible)

	defer func() {
		labelFin()
		p_visibleFin()
	}()
	return C.igCollapsingHeader_BoolPtr(labelArg, p_visibleArg, C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

// if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
// CollapsingHeaderTreeNodeFlagsV parameter default value hint:
// flags: 0
func CollapsingHeaderTreeNodeFlagsV(label string, flags TreeNodeFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igCollapsingHeader_TreeNodeFlags(labelArg, C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

// display a color square/button, hover for details, return true when pressed.
// ColorButtonV parameter default value hint:
// flags: 0
// size: ImVec2(0,0)
func ColorButtonV(desc_id string, col Vec4, flags ColorEditFlags, size Vec2) bool {
	desc_idArg, desc_idFin := internal.WrapString[C.char](desc_id)

	defer func() {
		desc_idFin()
	}()
	return C.igColorButton(desc_idArg, internal.ReinterpretCast[C.ImVec4](col.ToC()), C.ImGuiColorEditFlags(flags), internal.ReinterpretCast[C.ImVec2](size.ToC())) == C.bool(true)
}

func ColorConvertFloat4ToU32(in Vec4) uint32 {
	return uint32(C.igColorConvertFloat4ToU32(internal.ReinterpretCast[C.ImVec4](in.ToC())))
}

func ColorConvertHSVtoRGB(h float32, s float32, v float32, out_r *float32, out_g *float32, out_b *float32) {
	out_rArg, out_rFin := internal.WrapNumberPtr[C.float, float32](out_r)
	out_gArg, out_gFin := internal.WrapNumberPtr[C.float, float32](out_g)
	out_bArg, out_bFin := internal.WrapNumberPtr[C.float, float32](out_b)
	C.igColorConvertHSVtoRGB(C.float(h), C.float(s), C.float(v), out_rArg, out_gArg, out_bArg)

	out_rFin()
	out_gFin()
	out_bFin()
}

func ColorConvertRGBtoHSV(r float32, g float32, b float32, out_h *float32, out_s *float32, out_v *float32) {
	out_hArg, out_hFin := internal.WrapNumberPtr[C.float, float32](out_h)
	out_sArg, out_sFin := internal.WrapNumberPtr[C.float, float32](out_s)
	out_vArg, out_vFin := internal.WrapNumberPtr[C.float, float32](out_v)
	C.igColorConvertRGBtoHSV(C.float(r), C.float(g), C.float(b), out_hArg, out_sArg, out_vArg)

	out_hFin()
	out_sFin()
	out_vFin()
}

func ColorConvertU32ToFloat4(in uint32) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igColorConvertU32ToFloat4(internal.ReinterpretCast[*C.ImVec4](pOutArg), C.ImU32(in))

	pOutFin()

	return *pOut
}

// ColorEdit3V parameter default value hint:
// flags: 0
func ColorEdit3V(label string, col *[3]float32, flags ColorEditFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.igColorEdit3(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags)) == C.bool(true)
}

// ColorEdit4V parameter default value hint:
// flags: 0
func ColorEdit4V(label string, col *[4]float32, flags ColorEditFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.igColorEdit4(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags)) == C.bool(true)
}

func InternalColorEditOptionsPopup(col *float32, flags ColorEditFlags) {
	colArg, colFin := internal.WrapNumberPtr[C.float, float32](col)
	C.igColorEditOptionsPopup(colArg, C.ImGuiColorEditFlags(flags))

	colFin()
}

// ColorPicker3V parameter default value hint:
// flags: 0
func ColorPicker3V(label string, col *[3]float32, flags ColorEditFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.igColorPicker3(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags)) == C.bool(true)
}

// ColorPicker4V parameter default value hint:
// flags: 0
// ref_col: NULL
func ColorPicker4V(label string, col *[4]float32, flags ColorEditFlags, ref_col *float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}
	ref_colArg, ref_colFin := internal.WrapNumberPtr[C.float, float32](ref_col)

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}

		ref_colFin()
	}()
	return C.igColorPicker4(labelArg, (*C.float)(&colArg[0]), C.ImGuiColorEditFlags(flags), ref_colArg) == C.bool(true)
}

func InternalColorPickerOptionsPopup(ref_col *float32, flags ColorEditFlags) {
	ref_colArg, ref_colFin := internal.WrapNumberPtr[C.float, float32](ref_col)
	C.igColorPickerOptionsPopup(ref_colArg, C.ImGuiColorEditFlags(flags))

	ref_colFin()
}

func InternalColorTooltip(text string, col *float32, flags ColorEditFlags) {
	textArg, textFin := internal.WrapString[C.char](text)
	colArg, colFin := internal.WrapNumberPtr[C.float, float32](col)
	C.igColorTooltip(textArg, colArg, C.ImGuiColorEditFlags(flags))

	textFin()
	colFin()
}

// ColumnsV parameter default value hint:
// count: 1
// id: NULL
// borders: true
func ColumnsV(count int32, id string, borders bool) {
	idArg, idFin := internal.WrapString[C.char](id)
	C.igColumns(C.int(count), idArg, C.bool(borders))

	idFin()
}

// Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
// ComboStrV parameter default value hint:
// popup_max_height_in_items: -1
func ComboStrV(label string, current_item *int32, items_separated_by_zeros string, popup_max_height_in_items int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	current_itemArg, current_itemFin := internal.WrapNumberPtr[C.int, int32](current_item)
	items_separated_by_zerosArg, items_separated_by_zerosFin := internal.WrapString[C.char](items_separated_by_zeros)

	defer func() {
		labelFin()
		current_itemFin()
		items_separated_by_zerosFin()
	}()
	return C.igCombo_Str(labelArg, current_itemArg, items_separated_by_zerosArg, C.int(popup_max_height_in_items)) == C.bool(true)
}

// ComboStrarrV parameter default value hint:
// popup_max_height_in_items: -1
func ComboStrarrV(label string, current_item *int32, items []string, items_count int32, popup_max_height_in_items int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	current_itemArg, current_itemFin := internal.WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := internal.WrapStringList[C.char](items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.igCombo_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count), C.int(popup_max_height_in_items)) == C.bool(true)
}

func InternalConvertSingleModFlagToKey(key Key) Key {
	return Key(C.igConvertSingleModFlagToKey(C.ImGuiKey(key)))
}

// CreateContextV parameter default value hint:
// shared_font_atlas: NULL
func CreateContextV(shared_font_atlas *FontAtlas) *Context {
	shared_font_atlasArg, shared_font_atlasFin := shared_font_atlas.Handle()

	defer func() {
		shared_font_atlasFin()
	}()
	return NewContextFromC(C.igCreateContext(internal.ReinterpretCast[*C.ImFontAtlas](shared_font_atlasArg)))
}

func InternalCreateNewWindowSettings(name string) *WindowSettings {
	nameArg, nameFin := internal.WrapString[C.char](name)

	defer func() {
		nameFin()
	}()
	return NewWindowSettingsFromC(C.igCreateNewWindowSettings(nameArg))
}

// InternalDataTypeApplyFromTextV parameter default value hint:
// p_data_when_empty: NULL
func InternalDataTypeApplyFromTextV(buf string, data_type DataType, p_data uintptr, format string, p_data_when_empty uintptr) bool {
	bufArg, bufFin := internal.WrapString[C.char](buf)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		bufFin()
		formatFin()
	}()
	return C.wrap_igDataTypeApplyFromTextV(bufArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), formatArg, C.uintptr_t(p_data_when_empty)) == C.bool(true)
}

func InternalDataTypeApplyOp(data_type DataType, op int32, output uintptr, arg_1 uintptr, arg_2 uintptr) {
	C.wrap_igDataTypeApplyOp(C.ImGuiDataType(data_type), C.int(op), C.uintptr_t(output), C.uintptr_t(arg_1), C.uintptr_t(arg_2))
}

func InternalDataTypeClamp(data_type DataType, p_data uintptr, p_min uintptr, p_max uintptr) bool {
	return C.wrap_igDataTypeClamp(C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.uintptr_t(p_min), C.uintptr_t(p_max)) == C.bool(true)
}

func InternalDataTypeCompare(data_type DataType, arg_1 uintptr, arg_2 uintptr) int32 {
	return int32(C.wrap_igDataTypeCompare(C.ImGuiDataType(data_type), C.uintptr_t(arg_1), C.uintptr_t(arg_2)))
}

func InternalDataTypeFormatString(buf string, buf_size int32, data_type DataType, p_data uintptr, format string) int32 {
	bufArg, bufFin := internal.WrapString[C.char](buf)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		bufFin()
		formatFin()
	}()
	return int32(C.wrap_igDataTypeFormatString(bufArg, C.int(buf_size), C.ImGuiDataType(data_type), C.uintptr_t(p_data), formatArg))
}

func InternalDataTypeGetInfo(data_type DataType) *DataTypeInfo {
	return NewDataTypeInfoFromC(C.igDataTypeGetInfo(C.ImGuiDataType(data_type)))
}

func InternalDataTypeIsZero(data_type DataType, p_data uintptr) bool {
	return C.wrap_igDataTypeIsZero(C.ImGuiDataType(data_type), C.uintptr_t(p_data)) == C.bool(true)
}

// size >= 0 : alloc, size = -1 : free
func InternalDebugAllocHook(info *DebugAllocInfo, frame_count int32, ptr uintptr, size uint64) {
	infoArg, infoFin := info.Handle()
	C.wrap_igDebugAllocHook(internal.ReinterpretCast[*C.ImGuiDebugAllocInfo](infoArg), C.int(frame_count), C.uintptr_t(ptr), C.xulong(size))

	infoFin()
}

func InternalDebugBreakButton(label string, description_of_location string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	description_of_locationArg, description_of_locationFin := internal.WrapString[C.char](description_of_location)

	defer func() {
		labelFin()
		description_of_locationFin()
	}()
	return C.igDebugBreakButton(labelArg, description_of_locationArg) == C.bool(true)
}

func InternalDebugBreakButtonTooltip(keyboard_only bool, description_of_location string) {
	description_of_locationArg, description_of_locationFin := internal.WrapString[C.char](description_of_location)
	C.igDebugBreakButtonTooltip(C.bool(keyboard_only), description_of_locationArg)

	description_of_locationFin()
}

func InternalDebugBreakClearData() {
	C.igDebugBreakClearData()
}

// This is called by IMGUI_CHECKVERSION() macro.
func DebugCheckVersionAndDataLayout(version_str string, sz_io uint64, sz_style uint64, sz_vec2 uint64, sz_vec4 uint64, sz_drawvert uint64, sz_drawidx uint64) bool {
	version_strArg, version_strFin := internal.WrapString[C.char](version_str)

	defer func() {
		version_strFin()
	}()
	return C.igDebugCheckVersionAndDataLayout(version_strArg, C.xulong(sz_io), C.xulong(sz_style), C.xulong(sz_vec2), C.xulong(sz_vec4), C.xulong(sz_drawvert), C.xulong(sz_drawidx)) == C.bool(true)
}

// InternalDebugDrawCursorPosV parameter default value hint:
// col: 4278190335
func InternalDebugDrawCursorPosV(col uint32) {
	C.igDebugDrawCursorPos(C.ImU32(col))
}

// InternalDebugDrawItemRectV parameter default value hint:
// col: 4278190335
func InternalDebugDrawItemRectV(col uint32) {
	C.igDebugDrawItemRect(C.ImU32(col))
}

// InternalDebugDrawLineExtentsV parameter default value hint:
// col: 4278190335
func InternalDebugDrawLineExtentsV(col uint32) {
	C.igDebugDrawLineExtents(C.ImU32(col))
}

func DebugFlashStyleColor(idx Col) {
	C.igDebugFlashStyleColor(C.ImGuiCol(idx))
}

func InternalDebugHookIdInfo(id ID, data_type DataType, data_id uintptr, data_id_end uintptr) {
	idArg, idFin := id.C()
	C.wrap_igDebugHookIdInfo(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiDataType(data_type), C.uintptr_t(data_id), C.uintptr_t(data_id_end))

	idFin()
}

// Call sparingly: only 1 at the same time!
func InternalDebugLocateItem(target_id ID) {
	target_idArg, target_idFin := target_id.C()
	C.igDebugLocateItem(internal.ReinterpretCast[C.ImGuiID](target_idArg))

	target_idFin()
}

// Only call on reaction to a mouse Hover: because only 1 at the same time!
func InternalDebugLocateItemOnHover(target_id ID) {
	target_idArg, target_idFin := target_id.C()
	C.igDebugLocateItemOnHover(internal.ReinterpretCast[C.ImGuiID](target_idArg))

	target_idFin()
}

func InternalDebugLocateItemResolveWithLastItem() {
	C.igDebugLocateItemResolveWithLastItem()
}

// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!
func DebugLog(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igDebugLog(fmtArg)

	fmtFin()
}

func InternalDebugNodeColumns(columns *OldColumns) {
	columnsArg, columnsFin := columns.Handle()
	C.igDebugNodeColumns(internal.ReinterpretCast[*C.ImGuiOldColumns](columnsArg))

	columnsFin()
}

func InternalDebugNodeDockNode(node *DockNode, label string) {
	nodeArg, nodeFin := node.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igDebugNodeDockNode(internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg), labelArg)

	nodeFin()
	labelFin()
}

func InternalDebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list *DrawList, draw_list *DrawList, draw_cmd *DrawCmd, show_mesh bool, show_aabb bool) {
	out_draw_listArg, out_draw_listFin := out_draw_list.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	draw_cmdArg, draw_cmdFin := draw_cmd.Handle()
	C.igDebugNodeDrawCmdShowMeshAndBoundingBox(internal.ReinterpretCast[*C.ImDrawList](out_draw_listArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[*C.ImDrawCmd](draw_cmdArg), C.bool(show_mesh), C.bool(show_aabb))

	out_draw_listFin()
	draw_listFin()
	draw_cmdFin()
}

func InternalDebugNodeDrawList(window *Window, viewport *ViewportP, draw_list *DrawList, label string) {
	windowArg, windowFin := window.Handle()
	viewportArg, viewportFin := viewport.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igDebugNodeDrawList(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg), labelArg)

	windowFin()
	viewportFin()
	draw_listFin()
	labelFin()
}

func InternalDebugNodeFont(font *Font) {
	fontArg, fontFin := font.Handle()
	C.igDebugNodeFont(internal.ReinterpretCast[*C.ImFont](fontArg))

	fontFin()
}

func InternalDebugNodeFontGlyph(font *Font, glyph *FontGlyph) {
	fontArg, fontFin := font.Handle()
	glyphArg, glyphFin := glyph.Handle()
	C.igDebugNodeFontGlyph(internal.ReinterpretCast[*C.ImFont](fontArg), internal.ReinterpretCast[*C.ImFontGlyph](glyphArg))

	fontFin()
	glyphFin()
}

func InternalDebugNodeInputTextState(state *InputTextState) {
	stateArg, stateFin := state.Handle()
	C.igDebugNodeInputTextState(internal.ReinterpretCast[*C.ImGuiInputTextState](stateArg))

	stateFin()
}

func InternalDebugNodeMultiSelectState(state *MultiSelectState) {
	stateArg, stateFin := state.Handle()
	C.igDebugNodeMultiSelectState(internal.ReinterpretCast[*C.ImGuiMultiSelectState](stateArg))

	stateFin()
}

func InternalDebugNodePlatformMonitor(monitor *PlatformMonitor, label string, idx int32) {
	monitorArg, monitorFin := monitor.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igDebugNodePlatformMonitor(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](monitorArg), labelArg, C.int(idx))

	monitorFin()
	labelFin()
}

func InternalDebugNodeStorage(storage *Storage, label string) {
	storageArg, storageFin := storage.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igDebugNodeStorage(internal.ReinterpretCast[*C.ImGuiStorage](storageArg), labelArg)

	storageFin()
	labelFin()
}

func InternalDebugNodeTabBar(tab_bar *TabBar, label string) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igDebugNodeTabBar(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), labelArg)

	tab_barFin()
	labelFin()
}

func InternalDebugNodeTable(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igDebugNodeTable(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalDebugNodeTableSettings(settings *TableSettings) {
	settingsArg, settingsFin := settings.Handle()
	C.igDebugNodeTableSettings(internal.ReinterpretCast[*C.ImGuiTableSettings](settingsArg))

	settingsFin()
}

func InternalDebugNodeTypingSelectState(state *TypingSelectState) {
	stateArg, stateFin := state.Handle()
	C.igDebugNodeTypingSelectState(internal.ReinterpretCast[*C.ImGuiTypingSelectState](stateArg))

	stateFin()
}

func InternalDebugNodeViewport(viewport *ViewportP) {
	viewportArg, viewportFin := viewport.Handle()
	C.igDebugNodeViewport(internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg))

	viewportFin()
}

func InternalDebugNodeWindow(window *Window, label string) {
	windowArg, windowFin := window.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igDebugNodeWindow(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), labelArg)

	windowFin()
	labelFin()
}

func InternalDebugNodeWindowSettings(settings *WindowSettings) {
	settingsArg, settingsFin := settings.Handle()
	C.igDebugNodeWindowSettings(internal.ReinterpretCast[*C.ImGuiWindowSettings](settingsArg))

	settingsFin()
}

func InternalDebugRenderKeyboardPreview(draw_list *DrawList) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igDebugRenderKeyboardPreview(internal.ReinterpretCast[*C.ImDrawList](draw_listArg))

	draw_listFin()
}

func InternalDebugRenderViewportThumbnail(draw_list *DrawList, viewport *ViewportP, bb Rect) {
	draw_listArg, draw_listFin := draw_list.Handle()
	viewportArg, viewportFin := viewport.Handle()
	C.igDebugRenderViewportThumbnail(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg), internal.ReinterpretCast[C.ImRect](bb.ToC()))

	draw_listFin()
	viewportFin()
}

func DebugStartItemPicker() {
	C.igDebugStartItemPicker()
}

func DebugTextEncoding(text string) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.igDebugTextEncoding(textArg)

	textFin()
}

func InternalDebugTextUnformattedWithLocateItem(line_begin string, line_end string) {
	line_beginArg, line_beginFin := internal.WrapString[C.char](line_begin)
	line_endArg, line_endFin := internal.WrapString[C.char](line_end)
	C.igDebugTextUnformattedWithLocateItem(line_beginArg, line_endArg)

	line_beginFin()
	line_endFin()
}

// NULL = destroy current context
// DestroyContextV parameter default value hint:
// ctx: NULL
func DestroyContextV(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igDestroyContext(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalDestroyPlatformWindow(viewport *ViewportP) {
	viewportArg, viewportFin := viewport.Handle()
	C.igDestroyPlatformWindow(internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg))

	viewportFin()
}

// call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().
func DestroyPlatformWindows() {
	C.igDestroyPlatformWindows()
}

// InternalDockBuilderAddNodeV parameter default value hint:
// node_id: 0
// flags: 0
func InternalDockBuilderAddNodeV(node_id ID, flags DockNodeFlags) ID {
	node_idArg, node_idFin := node_id.C()

	defer func() {
		node_idFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igDockBuilderAddNode(internal.ReinterpretCast[C.ImGuiID](node_idArg), C.ImGuiDockNodeFlags(flags))
		return &result
	}())
}

func InternalDockBuilderCopyWindowSettings(src_name string, dst_name string) {
	src_nameArg, src_nameFin := internal.WrapString[C.char](src_name)
	dst_nameArg, dst_nameFin := internal.WrapString[C.char](dst_name)
	C.igDockBuilderCopyWindowSettings(src_nameArg, dst_nameArg)

	src_nameFin()
	dst_nameFin()
}

func InternalDockBuilderDockWindow(window_name string, node_id ID) {
	window_nameArg, window_nameFin := internal.WrapString[C.char](window_name)
	node_idArg, node_idFin := node_id.C()
	C.igDockBuilderDockWindow(window_nameArg, internal.ReinterpretCast[C.ImGuiID](node_idArg))

	window_nameFin()
	node_idFin()
}

func InternalDockBuilderFinish(node_id ID) {
	node_idArg, node_idFin := node_id.C()
	C.igDockBuilderFinish(internal.ReinterpretCast[C.ImGuiID](node_idArg))

	node_idFin()
}

func InternalDockBuilderGetCentralNode(node_id ID) *DockNode {
	node_idArg, node_idFin := node_id.C()

	defer func() {
		node_idFin()
	}()
	return NewDockNodeFromC(C.igDockBuilderGetCentralNode(internal.ReinterpretCast[C.ImGuiID](node_idArg)))
}

func InternalDockBuilderGetNode(node_id ID) *DockNode {
	node_idArg, node_idFin := node_id.C()

	defer func() {
		node_idFin()
	}()
	return NewDockNodeFromC(C.igDockBuilderGetNode(internal.ReinterpretCast[C.ImGuiID](node_idArg)))
}

// Remove node and all its child, undock all windows
func InternalDockBuilderRemoveNode(node_id ID) {
	node_idArg, node_idFin := node_id.C()
	C.igDockBuilderRemoveNode(internal.ReinterpretCast[C.ImGuiID](node_idArg))

	node_idFin()
}

// Remove all split/hierarchy. All remaining docked windows will be re-docked to the remaining root node (node_id).
func InternalDockBuilderRemoveNodeChildNodes(node_id ID) {
	node_idArg, node_idFin := node_id.C()
	C.igDockBuilderRemoveNodeChildNodes(internal.ReinterpretCast[C.ImGuiID](node_idArg))

	node_idFin()
}

// InternalDockBuilderRemoveNodeDockedWindowsV parameter default value hint:
// clear_settings_refs: true
func InternalDockBuilderRemoveNodeDockedWindowsV(node_id ID, clear_settings_refs bool) {
	node_idArg, node_idFin := node_id.C()
	C.igDockBuilderRemoveNodeDockedWindows(internal.ReinterpretCast[C.ImGuiID](node_idArg), C.bool(clear_settings_refs))

	node_idFin()
}

func InternalDockBuilderSetNodePos(node_id ID, pos Vec2) {
	node_idArg, node_idFin := node_id.C()
	C.igDockBuilderSetNodePos(internal.ReinterpretCast[C.ImGuiID](node_idArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()))

	node_idFin()
}

func InternalDockBuilderSetNodeSize(node_id ID, size Vec2) {
	node_idArg, node_idFin := node_id.C()
	C.igDockBuilderSetNodeSize(internal.ReinterpretCast[C.ImGuiID](node_idArg), internal.ReinterpretCast[C.ImVec2](size.ToC()))

	node_idFin()
}

// Create 2 child nodes in this parent node.
func InternalDockBuilderSplitNode(node_id ID, split_dir Dir, size_ratio_for_node_at_dir float32, out_id_at_dir *ID, out_id_at_opposite_dir *ID) ID {
	node_idArg, node_idFin := node_id.C()
	out_id_at_dirArg, out_id_at_dirFin := out_id_at_dir.Handle()
	out_id_at_opposite_dirArg, out_id_at_opposite_dirFin := out_id_at_opposite_dir.Handle()

	defer func() {
		node_idFin()
		out_id_at_dirFin()
		out_id_at_opposite_dirFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igDockBuilderSplitNode(internal.ReinterpretCast[C.ImGuiID](node_idArg), C.ImGuiDir(split_dir), C.float(size_ratio_for_node_at_dir), internal.ReinterpretCast[*C.ImGuiID](out_id_at_dirArg), internal.ReinterpretCast[*C.ImGuiID](out_id_at_opposite_dirArg))
		return &result
	}())
}

func InternalDockContextCalcDropPosForDocking(target *Window, target_node *DockNode, payload_window *Window, payload_node *DockNode, split_dir Dir, split_outer bool, out_pos *Vec2) bool {
	targetArg, targetFin := target.Handle()
	target_nodeArg, target_nodeFin := target_node.Handle()
	payload_windowArg, payload_windowFin := payload_window.Handle()
	payload_nodeArg, payload_nodeFin := payload_node.Handle()
	out_posArg, out_posFin := internal.Wrap(out_pos)

	defer func() {
		targetFin()
		target_nodeFin()
		payload_windowFin()
		payload_nodeFin()
		out_posFin()
	}()
	return C.igDockContextCalcDropPosForDocking(internal.ReinterpretCast[*C.ImGuiWindow](targetArg), internal.ReinterpretCast[*C.ImGuiDockNode](target_nodeArg), internal.ReinterpretCast[*C.ImGuiWindow](payload_windowArg), internal.ReinterpretCast[*C.ImGuiDockNode](payload_nodeArg), C.ImGuiDir(split_dir), C.bool(split_outer), internal.ReinterpretCast[*C.ImVec2](out_posArg)) == C.bool(true)
}

// Use root_id==0 to clear all
func InternalDockContextClearNodes(ctx *Context, root_id ID, clear_settings_refs bool) {
	ctxArg, ctxFin := ctx.Handle()
	root_idArg, root_idFin := root_id.C()
	C.igDockContextClearNodes(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[C.ImGuiID](root_idArg), C.bool(clear_settings_refs))

	ctxFin()
	root_idFin()
}

func InternalDockContextEndFrame(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igDockContextEndFrame(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalDockContextFindNodeByID(ctx *Context, id ID) *DockNode {
	ctxArg, ctxFin := ctx.Handle()
	idArg, idFin := id.C()

	defer func() {
		ctxFin()
		idFin()
	}()
	return NewDockNodeFromC(C.igDockContextFindNodeByID(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func InternalDockContextGenNodeID(ctx *Context) ID {
	ctxArg, ctxFin := ctx.Handle()

	defer func() {
		ctxFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igDockContextGenNodeID(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))
		return &result
	}())
}

func InternalDockContextInitialize(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igDockContextInitialize(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalDockContextNewFrameUpdateDocking(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igDockContextNewFrameUpdateDocking(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalDockContextNewFrameUpdateUndocking(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igDockContextNewFrameUpdateUndocking(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalDockContextProcessUndockNode(ctx *Context, node *DockNode) {
	ctxArg, ctxFin := ctx.Handle()
	nodeArg, nodeFin := node.Handle()
	C.igDockContextProcessUndockNode(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg))

	ctxFin()
	nodeFin()
}

// InternalDockContextProcessUndockWindowV parameter default value hint:
// clear_persistent_docking_ref: true
func InternalDockContextProcessUndockWindowV(ctx *Context, window *Window, clear_persistent_docking_ref bool) {
	ctxArg, ctxFin := ctx.Handle()
	windowArg, windowFin := window.Handle()
	C.igDockContextProcessUndockWindow(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.bool(clear_persistent_docking_ref))

	ctxFin()
	windowFin()
}

func InternalDockContextQueueDock(ctx *Context, target *Window, target_node *DockNode, payload *Window, split_dir Dir, split_ratio float32, split_outer bool) {
	ctxArg, ctxFin := ctx.Handle()
	targetArg, targetFin := target.Handle()
	target_nodeArg, target_nodeFin := target_node.Handle()
	payloadArg, payloadFin := payload.Handle()
	C.igDockContextQueueDock(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[*C.ImGuiWindow](targetArg), internal.ReinterpretCast[*C.ImGuiDockNode](target_nodeArg), internal.ReinterpretCast[*C.ImGuiWindow](payloadArg), C.ImGuiDir(split_dir), C.float(split_ratio), C.bool(split_outer))

	ctxFin()
	targetFin()
	target_nodeFin()
	payloadFin()
}

func InternalDockContextQueueUndockNode(ctx *Context, node *DockNode) {
	ctxArg, ctxFin := ctx.Handle()
	nodeArg, nodeFin := node.Handle()
	C.igDockContextQueueUndockNode(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg))

	ctxFin()
	nodeFin()
}

func InternalDockContextQueueUndockWindow(ctx *Context, window *Window) {
	ctxArg, ctxFin := ctx.Handle()
	windowArg, windowFin := window.Handle()
	C.igDockContextQueueUndockWindow(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	ctxFin()
	windowFin()
}

func InternalDockContextRebuildNodes(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igDockContextRebuildNodes(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalDockContextShutdown(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igDockContextShutdown(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalDockNodeBeginAmendTabBar(node *DockNode) bool {
	nodeArg, nodeFin := node.Handle()

	defer func() {
		nodeFin()
	}()
	return C.igDockNodeBeginAmendTabBar(internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg)) == C.bool(true)
}

func InternalDockNodeEndAmendTabBar() {
	C.igDockNodeEndAmendTabBar()
}

func InternalDockNodeGetDepth(node *DockNode) int32 {
	nodeArg, nodeFin := node.Handle()

	defer func() {
		nodeFin()
	}()
	return int32(C.igDockNodeGetDepth(internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg)))
}

func InternalDockNodeGetRootNode(node *DockNode) *DockNode {
	nodeArg, nodeFin := node.Handle()

	defer func() {
		nodeFin()
	}()
	return NewDockNodeFromC(C.igDockNodeGetRootNode(internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg)))
}

func InternalDockNodeGetWindowMenuButtonId(node *DockNode) ID {
	nodeArg, nodeFin := node.Handle()

	defer func() {
		nodeFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igDockNodeGetWindowMenuButtonId(internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg))
		return &result
	}())
}

func InternalDockNodeIsInHierarchyOf(node *DockNode, parent *DockNode) bool {
	nodeArg, nodeFin := node.Handle()
	parentArg, parentFin := parent.Handle()

	defer func() {
		nodeFin()
		parentFin()
	}()
	return C.igDockNodeIsInHierarchyOf(internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg), internal.ReinterpretCast[*C.ImGuiDockNode](parentArg)) == C.bool(true)
}

func InternalDockNodeWindowMenuHandlerDefault(ctx *Context, node *DockNode, tab_bar *TabBar) {
	ctxArg, ctxFin := ctx.Handle()
	nodeArg, nodeFin := node.Handle()
	tab_barArg, tab_barFin := tab_bar.Handle()
	C.igDockNodeWindowMenuHandler_Default(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg), internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg))

	ctxFin()
	nodeFin()
	tab_barFin()
}

// DockSpaceV parameter default value hint:
// size: ImVec2(0,0)
// flags: 0
// window_class: NULL
func DockSpaceV(dockspace_id ID, size Vec2, flags DockNodeFlags, window_class *WindowClass) ID {
	dockspace_idArg, dockspace_idFin := dockspace_id.C()
	window_classArg, window_classFin := window_class.Handle()

	defer func() {
		dockspace_idFin()
		window_classFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igDockSpace(internal.ReinterpretCast[C.ImGuiID](dockspace_idArg), internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiDockNodeFlags(flags), internal.ReinterpretCast[*C.ImGuiWindowClass](window_classArg))
		return &result
	}())
}

// DockSpaceOverViewportV parameter default value hint:
// dockspace_id: 0
// viewport: NULL
// flags: 0
// window_class: NULL
func DockSpaceOverViewportV(dockspace_id ID, viewport *Viewport, flags DockNodeFlags, window_class *WindowClass) ID {
	dockspace_idArg, dockspace_idFin := dockspace_id.C()
	viewportArg, viewportFin := viewport.Handle()
	window_classArg, window_classFin := window_class.Handle()

	defer func() {
		dockspace_idFin()
		viewportFin()
		window_classFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igDockSpaceOverViewport(internal.ReinterpretCast[C.ImGuiID](dockspace_idArg), internal.ReinterpretCast[*C.ImGuiViewport](viewportArg), C.ImGuiDockNodeFlags(flags), internal.ReinterpretCast[*C.ImGuiWindowClass](window_classArg))
		return &result
	}())
}

func InternalDragBehavior(id ID, data_type DataType, p_v uintptr, v_speed float32, p_min uintptr, p_max uintptr, format string, flags SliderFlags) bool {
	idArg, idFin := id.C()
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		idFin()
		formatFin()
	}()
	return C.wrap_igDragBehavior(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiDataType(data_type), C.uintptr_t(p_v), C.float(v_speed), C.uintptr_t(p_min), C.uintptr_t(p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// If v_min >= v_max we have no bound
// DragFloatV parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloatV(label string, v *float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igDragFloat(labelArg, vArg, C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloat2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloat2V(label string, v *[2]float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igDragFloat2(labelArg, (*C.float)(&vArg[0]), C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloat3V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloat3V(label string, v *[3]float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igDragFloat3(labelArg, (*C.float)(&vArg[0]), C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloat4V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// flags: 0
func DragFloat4V(label string, v *[4]float32, v_speed float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igDragFloat4(labelArg, (*C.float)(&vArg[0]), C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragFloatRange2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0.0f
// v_max: 0.0f
// format: "%.3f"
// format_max: NULL
// flags: 0
func DragFloatRange2V(label string, v_current_min *float32, v_current_max *float32, v_speed float32, v_min float32, v_max float32, format string, format_max string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	v_current_minArg, v_current_minFin := internal.WrapNumberPtr[C.float, float32](v_current_min)
	v_current_maxArg, v_current_maxFin := internal.WrapNumberPtr[C.float, float32](v_current_max)
	formatArg, formatFin := internal.WrapString[C.char](format)
	format_maxArg, format_maxFin := internal.WrapString[C.char](format_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
		formatFin()
		format_maxFin()
	}()
	return C.igDragFloatRange2(labelArg, v_current_minArg, v_current_maxArg, C.float(v_speed), C.float(v_min), C.float(v_max), formatArg, format_maxArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// If v_min >= v_max we have no bound
// DragIntV parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragIntV(label string, v *int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igDragInt(labelArg, vArg, C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragInt2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragInt2V(label string, v *[2]int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igDragInt2(labelArg, (*C.int)(&vArg[0]), C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragInt3V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragInt3V(label string, v *[3]int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igDragInt3(labelArg, (*C.int)(&vArg[0]), C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragInt4V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// flags: 0
func DragInt4V(label string, v *[4]int32, v_speed float32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igDragInt4(labelArg, (*C.int)(&vArg[0]), C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragIntRange2V parameter default value hint:
// v_speed: 1.0f
// v_min: 0
// v_max: 0
// format: "%d"
// format_max: NULL
// flags: 0
func DragIntRange2V(label string, v_current_min *int32, v_current_max *int32, v_speed float32, v_min int32, v_max int32, format string, format_max string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	v_current_minArg, v_current_minFin := internal.WrapNumberPtr[C.int, int32](v_current_min)
	v_current_maxArg, v_current_maxFin := internal.WrapNumberPtr[C.int, int32](v_current_max)
	formatArg, formatFin := internal.WrapString[C.char](format)
	format_maxArg, format_maxFin := internal.WrapString[C.char](format_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
		formatFin()
		format_maxFin()
	}()
	return C.igDragIntRange2(labelArg, v_current_minArg, v_current_maxArg, C.float(v_speed), C.int(v_min), C.int(v_max), formatArg, format_maxArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragScalarV parameter default value hint:
// v_speed: 1.0f
// p_min: NULL
// p_max: NULL
// format: NULL
// flags: 0
func DragScalarV(label string, data_type DataType, p_data uintptr, v_speed float32, p_min uintptr, p_max uintptr, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		formatFin()
	}()
	return C.wrap_igDragScalarV(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.float(v_speed), C.uintptr_t(p_min), C.uintptr_t(p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// DragScalarNV parameter default value hint:
// v_speed: 1.0f
// p_min: NULL
// p_max: NULL
// format: NULL
// flags: 0
func DragScalarNV(label string, data_type DataType, p_data uintptr, components int32, v_speed float32, p_min uintptr, p_max uintptr, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		formatFin()
	}()
	return C.wrap_igDragScalarNV(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.int(components), C.float(v_speed), C.uintptr_t(p_min), C.uintptr_t(p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into.
func Dummy(size Vec2) {
	C.igDummy(internal.ReinterpretCast[C.ImVec2](size.ToC()))
}

func End() {
	C.igEnd()
}

func InternalEndBoxSelect(scope_rect Rect, ms_flags MultiSelectFlags) {
	C.igEndBoxSelect(internal.ReinterpretCast[C.ImRect](scope_rect.ToC()), C.ImGuiMultiSelectFlags(ms_flags))
}

func EndChild() {
	C.igEndChild()
}

// close columns
func InternalEndColumns() {
	C.igEndColumns()
}

// only call EndCombo() if BeginCombo() returns true!
func EndCombo() {
	C.igEndCombo()
}

func InternalEndComboPreview() {
	C.igEndComboPreview()
}

func EndDisabled() {
	C.igEndDisabled()
}

func InternalEndDisabledOverrideReenable() {
	C.igEndDisabledOverrideReenable()
}

// only call EndDragDropSource() if BeginDragDropSource() returns true!
func EndDragDropSource() {
	C.igEndDragDropSource()
}

// only call EndDragDropTarget() if BeginDragDropTarget() returns true!
func EndDragDropTarget() {
	C.igEndDragDropTarget()
}

func InternalEndErrorTooltip() {
	C.igEndErrorTooltip()
}

// ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
func EndFrame() {
	C.igEndFrame()
}

// unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
func EndGroup() {
	C.igEndGroup()
}

// only call EndListBox() if BeginListBox() returned true!
func EndListBox() {
	C.igEndListBox()
}

// only call EndMainMenuBar() if BeginMainMenuBar() returns true!
func EndMainMenuBar() {
	C.igEndMainMenuBar()
}

// only call EndMenu() if BeginMenu() returns true!
func EndMenu() {
	C.igEndMenu()
}

// only call EndMenuBar() if BeginMenuBar() returns true!
func EndMenuBar() {
	C.igEndMenuBar()
}

func EndMultiSelect() *MultiSelectIO {
	return NewMultiSelectIOFromC(C.igEndMultiSelect())
}

// only call EndPopup() if BeginPopupXXX() returns true!
func EndPopup() {
	C.igEndPopup()
}

// only call EndTabBar() if BeginTabBar() returns true!
func EndTabBar() {
	C.igEndTabBar()
}

// only call EndTabItem() if BeginTabItem() returns true!
func EndTabItem() {
	C.igEndTabItem()
}

// only call EndTable() if BeginTable() returns true!
func EndTable() {
	C.igEndTable()
}

// only call EndTooltip() if BeginTooltip()/BeginItemTooltip() returns true!
func EndTooltip() {
	C.igEndTooltip()
}

func InternalErrorCheckEndFrameFinalizeErrorTooltip() {
	C.igErrorCheckEndFrameFinalizeErrorTooltip()
}

func InternalErrorCheckUsingSetCursorPosToExtendParentBoundaries() {
	C.igErrorCheckUsingSetCursorPosToExtendParentBoundaries()
}

func InternalErrorLog(msg string) bool {
	msgArg, msgFin := internal.WrapString[C.char](msg)

	defer func() {
		msgFin()
	}()
	return C.igErrorLog(msgArg) == C.bool(true)
}

func InternalErrorRecoveryStoreState(state_out *ErrorRecoveryState) {
	state_outArg, state_outFin := state_out.Handle()
	C.igErrorRecoveryStoreState(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](state_outArg))

	state_outFin()
}

func InternalErrorRecoveryTryToRecoverState(state_in *ErrorRecoveryState) {
	state_inArg, state_inFin := state_in.Handle()
	C.igErrorRecoveryTryToRecoverState(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](state_inArg))

	state_inFin()
}

func InternalErrorRecoveryTryToRecoverWindowState(state_in *ErrorRecoveryState) {
	state_inArg, state_inFin := state_in.Handle()
	C.igErrorRecoveryTryToRecoverWindowState(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](state_inArg))

	state_inFin()
}

func InternalFindBestWindowPosForPopup(window *Window) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igFindBestWindowPosForPopup(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalFindBestWindowPosForPopupEx(ref_pos Vec2, size Vec2, last_dir *Dir, r_outer Rect, r_avoid Rect, policy PopupPositionPolicy) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igFindBestWindowPosForPopupEx(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](ref_pos.ToC()), internal.ReinterpretCast[C.ImVec2](size.ToC()), (*C.ImGuiDir)(last_dir), internal.ReinterpretCast[C.ImRect](r_outer.ToC()), internal.ReinterpretCast[C.ImRect](r_avoid.ToC()), C.ImGuiPopupPositionPolicy(policy))

	pOutFin()

	return *pOut
}

func InternalFindBlockingModal(window *Window) *Window {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return NewWindowFromC(C.igFindBlockingModal(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)))
}

func InternalFindBottomMostVisibleWindowWithinBeginStack(window *Window) *Window {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return NewWindowFromC(C.igFindBottomMostVisibleWindowWithinBeginStack(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)))
}

func InternalFindHoveredViewportFromPlatformWindowStack(mouse_platform_pos Vec2) *ViewportP {
	return NewViewportPFromC(C.igFindHoveredViewportFromPlatformWindowStack(internal.ReinterpretCast[C.ImVec2](mouse_platform_pos.ToC())))
}

func InternalFindOrCreateColumns(window *Window, id ID) *OldColumns {
	windowArg, windowFin := window.Handle()
	idArg, idFin := id.C()

	defer func() {
		windowFin()
		idFin()
	}()
	return NewOldColumnsFromC(C.igFindOrCreateColumns(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImGuiID](idArg)))
}

// Find the optional ## from which we stop displaying text.
// InternalFindRenderedTextEndV parameter default value hint:
func InternalFindRenderedTextEndV(text string) string {
	textArg, textFin := internal.WrapString[C.char](text)

	defer func() {
		textFin()
	}()
	return func() string {
		result := C.wrap_igFindRenderedTextEndV(textArg, C.int(len(text)))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalFindSettingsHandler(type_name string) *SettingsHandler {
	type_nameArg, type_nameFin := internal.WrapString[C.char](type_name)

	defer func() {
		type_nameFin()
	}()
	return NewSettingsHandlerFromC(C.igFindSettingsHandler(type_nameArg))
}

// this is a helper for backends.
func FindViewportByID(id ID) *Viewport {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewViewportFromC(C.igFindViewportByID(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

// this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)
func FindViewportByPlatformHandle(platform_handle uintptr) *Viewport {
	return NewViewportFromC(C.wrap_igFindViewportByPlatformHandle(C.uintptr_t(platform_handle)))
}

func InternalFindWindowByID(id ID) *Window {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewWindowFromC(C.igFindWindowByID(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func InternalFindWindowByName(name string) *Window {
	nameArg, nameFin := internal.WrapString[C.char](name)

	defer func() {
		nameFin()
	}()
	return NewWindowFromC(C.igFindWindowByName(nameArg))
}

func InternalFindWindowDisplayIndex(window *Window) int32 {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return int32(C.igFindWindowDisplayIndex(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)))
}

func InternalFindWindowSettingsByID(id ID) *WindowSettings {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewWindowSettingsFromC(C.igFindWindowSettingsByID(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func InternalFindWindowSettingsByWindow(window *Window) *WindowSettings {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return NewWindowSettingsFromC(C.igFindWindowSettingsByWindow(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)))
}

func InternalFixupKeyChord(key_chord KeyChord) KeyChord {
	key_chordArg, key_chordFin := key_chord.C()

	defer func() {
		key_chordFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.igFixupKeyChord(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg))
		return &result
	}())
}

// Focus last item (no selection/activation).
func InternalFocusItem() {
	C.igFocusItem()
}

func InternalFocusTopMostWindowUnderOne(under_this_window *Window, ignore_window *Window, filter_viewport *Viewport, flags FocusRequestFlags) {
	under_this_windowArg, under_this_windowFin := under_this_window.Handle()
	ignore_windowArg, ignore_windowFin := ignore_window.Handle()
	filter_viewportArg, filter_viewportFin := filter_viewport.Handle()
	C.igFocusTopMostWindowUnderOne(internal.ReinterpretCast[*C.ImGuiWindow](under_this_windowArg), internal.ReinterpretCast[*C.ImGuiWindow](ignore_windowArg), internal.ReinterpretCast[*C.ImGuiViewport](filter_viewportArg), C.ImGuiFocusRequestFlags(flags))

	under_this_windowFin()
	ignore_windowFin()
	filter_viewportFin()
}

// InternalFocusWindowV parameter default value hint:
// flags: 0
func InternalFocusWindowV(window *Window, flags FocusRequestFlags) {
	windowArg, windowFin := window.Handle()
	C.igFocusWindow(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.ImGuiFocusRequestFlags(flags))

	windowFin()
}

func InternalGcAwakeTransientWindowBuffers(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igGcAwakeTransientWindowBuffers(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalGcCompactTransientMiscBuffers() {
	C.igGcCompactTransientMiscBuffers()
}

func InternalGcCompactTransientWindowBuffers(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igGcCompactTransientWindowBuffers(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalActiveID() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetActiveID(); return &result }())
}

// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
// BackgroundDrawListV parameter default value hint:
// viewport: NULL
func BackgroundDrawListV(viewport *Viewport) *DrawList {
	viewportArg, viewportFin := viewport.Handle()

	defer func() {
		viewportFin()
	}()
	return NewDrawListFromC(C.igGetBackgroundDrawList(internal.ReinterpretCast[*C.ImGuiViewport](viewportArg)))
}

func InternalBoxSelectState(id ID) *BoxSelectState {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewBoxSelectStateFromC(C.igGetBoxSelectState(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func ClipboardText() string {
	return func() string {
		result := C.igGetClipboardText()
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList
// ColorU32ColV parameter default value hint:
// alpha_mul: 1.0f
func ColorU32ColV(idx Col, alpha_mul float32) uint32 {
	return uint32(C.igGetColorU32_Col(C.ImGuiCol(idx), C.float(alpha_mul)))
}

// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
// ColorU32U32V parameter default value hint:
// alpha_mul: 1.0f
func ColorU32U32V(col uint32, alpha_mul float32) uint32 {
	return uint32(C.igGetColorU32_U32(C.ImU32(col), C.float(alpha_mul)))
}

// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
func ColorU32Vec4(col Vec4) uint32 {
	return uint32(C.igGetColorU32_Vec4(internal.ReinterpretCast[C.ImVec4](col.ToC())))
}

// get current column index
func ColumnIndex() int32 {
	return int32(C.igGetColumnIndex())
}

func InternalColumnNormFromOffset(columns *OldColumns, offset float32) float32 {
	columnsArg, columnsFin := columns.Handle()

	defer func() {
		columnsFin()
	}()
	return float32(C.igGetColumnNormFromOffset(internal.ReinterpretCast[*C.ImGuiOldColumns](columnsArg), C.float(offset)))
}

// get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
// ColumnOffsetV parameter default value hint:
// column_index: -1
func ColumnOffsetV(column_index int32) float32 {
	return float32(C.igGetColumnOffset(C.int(column_index)))
}

func InternalColumnOffsetFromNorm(columns *OldColumns, offset_norm float32) float32 {
	columnsArg, columnsFin := columns.Handle()

	defer func() {
		columnsFin()
	}()
	return float32(C.igGetColumnOffsetFromNorm(internal.ReinterpretCast[*C.ImGuiOldColumns](columnsArg), C.float(offset_norm)))
}

// get column width (in pixels). pass -1 to use current column
// ColumnWidthV parameter default value hint:
// column_index: -1
func ColumnWidthV(column_index int32) float32 {
	return float32(C.igGetColumnWidth(C.int(column_index)))
}

func ColumnsCount() int32 {
	return int32(C.igGetColumnsCount())
}

func InternalColumnsID(str_id string, count int32) ID {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetColumnsID(str_idArg, C.int(count)); return &result }())
}

// available space from current position. THIS IS YOUR BEST FRIEND.
func ContentRegionAvail() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetContentRegionAvail(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

func CurrentContext() *Context {
	return NewContextFromC(C.igGetCurrentContext())
}

// Focus scope we are outputting into, set by PushFocusScope()
func InternalCurrentFocusScope() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetCurrentFocusScope(); return &result }())
}

func InternalCurrentTabBar() *TabBar {
	return NewTabBarFromC(C.igGetCurrentTabBar())
}

func InternalCurrentTable() *Table {
	return NewTableFromC(C.igGetCurrentTable())
}

func InternalCurrentWindow() *Window {
	return NewWindowFromC(C.igGetCurrentWindow())
}

func InternalCurrentWindowRead() *Window {
	return NewWindowFromC(C.igGetCurrentWindowRead())
}

// [window-local] cursor position in window-local coordinates. This is not your best friend.
func CursorPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetCursorPos(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

// [window-local] "
func CursorPosX() float32 {
	return float32(C.igGetCursorPosX())
}

// [window-local] "
func CursorPosY() float32 {
	return float32(C.igGetCursorPosY())
}

// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).
func CursorScreenPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetCursorScreenPos(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.
func CursorStartPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetCursorStartPos(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

func InternalDefaultFont() *Font {
	return NewFontFromC(C.igGetDefaultFont())
}

// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.
func DragDropPayload() *Payload {
	return NewPayloadFromC(C.igGetDragDropPayload())
}

// valid after Render() and until the next call to NewFrame(). this is what you have to render.
func CurrentDrawData() *DrawData {
	return NewDrawDataFromC(C.igGetDrawData())
}

// you may use this when creating your own ImDrawList instances.
func CurrentDrawListSharedData() *DrawListSharedData {
	return NewDrawListSharedDataFromC(C.igGetDrawListSharedData())
}

func InternalFocusID() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetFocusID(); return &result }())
}

// get current font
func CurrentFont() *Font {
	return NewFontFromC(C.igGetFont())
}

// get current font size (= height in pixels) of current font with current scale applied
func FontSize() float32 {
	return float32(C.igGetFontSize())
}

// get UV coordinate for a white pixel, useful to draw custom shapes via the ImDrawList API
func FontTexUvWhitePixel() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetFontTexUvWhitePixel(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapes/text over dear imgui contents.
// ForegroundDrawListViewportPtrV parameter default value hint:
// viewport: NULL
func ForegroundDrawListViewportPtrV(viewport *Viewport) *DrawList {
	viewportArg, viewportFin := viewport.Handle()

	defer func() {
		viewportFin()
	}()
	return NewDrawListFromC(C.igGetForegroundDrawList_ViewportPtr(internal.ReinterpretCast[*C.ImGuiViewport](viewportArg)))
}

func InternalForegroundDrawListWindowPtr(window *Window) *DrawList {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return NewDrawListFromC(C.igGetForegroundDrawList_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)))
}

// get global imgui frame count. incremented by 1 every frame.
func FrameCount() int32 {
	return int32(C.igGetFrameCount())
}

// ~ FontSize + style.FramePadding.y * 2
func FrameHeight() float32 {
	return float32(C.igGetFrameHeight())
}

// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)
func FrameHeightWithSpacing() float32 {
	return float32(C.igGetFrameHeightWithSpacing())
}

func InternalHoveredID() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetHoveredID(); return &result }())
}

func InternalIDWithSeedInt(n int32, seed ID) ID {
	seedArg, seedFin := seed.C()

	defer func() {
		seedFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igGetIDWithSeed_Int(C.int(n), internal.ReinterpretCast[C.ImGuiID](seedArg))
		return &result
	}())
}

func InternalIDWithSeedStr(str_id_begin string, str_id_end string, seed ID) ID {
	str_id_beginArg, str_id_beginFin := internal.WrapString[C.char](str_id_begin)
	str_id_endArg, str_id_endFin := internal.WrapString[C.char](str_id_end)
	seedArg, seedFin := seed.C()

	defer func() {
		str_id_beginFin()
		str_id_endFin()
		seedFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igGetIDWithSeed_Str(str_id_beginArg, str_id_endArg, internal.ReinterpretCast[C.ImGuiID](seedArg))
		return &result
	}())
}

func IDInt(int_id int32) ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetID_Int(C.int(int_id)); return &result }())
}

func IDPtr(ptr_id uintptr) ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.wrap_igGetID_Ptr(C.uintptr_t(ptr_id)); return &result }())
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
func IDStr(str_id string) ID {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetID_Str(str_idArg); return &result }())
}

func IDStrStr(str_id_begin string, str_id_end string) ID {
	str_id_beginArg, str_id_beginFin := internal.WrapString[C.char](str_id_begin)
	str_id_endArg, str_id_endFin := internal.WrapString[C.char](str_id_end)

	defer func() {
		str_id_beginFin()
		str_id_endFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetID_StrStr(str_id_beginArg, str_id_endArg); return &result }())
}

// access the ImGuiIO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
func CurrentIO() *IO {
	return NewIOFromC(C.igGetIO())
}

func InternalIOEx(ctx *Context) *IO {
	ctxArg, ctxFin := ctx.Handle()

	defer func() {
		ctxFin()
	}()
	return NewIOFromC(C.igGetIOEx(internal.ReinterpretCast[*C.ImGuiContext](ctxArg)))
}

// Get input text state if active
func InternalInputTextState(id ID) *InputTextState {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewInputTextStateFromC(C.igGetInputTextState(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func InternalItemFlags() ItemFlags {
	return ItemFlags(C.igGetItemFlags())
}

// get ID of last item (~~ often same ImGui::GetID(label) beforehand)
func ItemID() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetItemID(); return &result }())
}

// get lower-right bounding rectangle of the last item (screen space)
func ItemRectMax() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetItemRectMax(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

// get upper-left bounding rectangle of the last item (screen space)
func ItemRectMin() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetItemRectMin(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

// get size of last item
func ItemRectSize() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetItemRectSize(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

func InternalItemStatusFlags() ItemStatusFlags {
	return ItemStatusFlags(C.igGetItemStatusFlags())
}

func InternalKeyChordName(key_chord KeyChord) string {
	key_chordArg, key_chordFin := key_chord.C()

	defer func() {
		key_chordFin()
	}()
	return func() string {
		result := C.igGetKeyChordName(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalKeyDataContextPtr(ctx *Context, key Key) *KeyData {
	ctxArg, ctxFin := ctx.Handle()

	defer func() {
		ctxFin()
	}()
	return NewKeyDataFromC(C.igGetKeyData_ContextPtr(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), C.ImGuiKey(key)))
}

func InternalKeyDataKey(key Key) *KeyData {
	return NewKeyDataFromC(C.igGetKeyData_Key(C.ImGuiKey(key)))
}

func InternalKeyMagnitude2d(key_left Key, key_right Key, key_up Key, key_down Key) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetKeyMagnitude2d(internal.ReinterpretCast[*C.ImVec2](pOutArg), C.ImGuiKey(key_left), C.ImGuiKey(key_right), C.ImGuiKey(key_up), C.ImGuiKey(key_down))

	pOutFin()

	return *pOut
}

// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
func KeyName(key Key) string {
	return func() string {
		result := C.igGetKeyName(C.ImGuiKey(key))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalKeyOwner(key Key) ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetKeyOwner(C.ImGuiKey(key)); return &result }())
}

func InternalKeyOwnerData(ctx *Context, key Key) *KeyOwnerData {
	ctxArg, ctxFin := ctx.Handle()

	defer func() {
		ctxFin()
	}()
	return NewKeyOwnerDataFromC(C.igGetKeyOwnerData(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), C.ImGuiKey(key)))
}

// uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
func KeyPressedAmount(key Key, repeat_delay float32, rate float32) int32 {
	return int32(C.igGetKeyPressedAmount(C.ImGuiKey(key), C.float(repeat_delay), C.float(rate)))
}

// return primary/default viewport. This can never be NULL.
func MainViewport() *Viewport {
	return NewViewportFromC(C.igGetMainViewport())
}

// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).
func MouseClickedCount(button MouseButton) int32 {
	return int32(C.igGetMouseClickedCount(C.ImGuiMouseButton(button)))
}

// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
func CurrentMouseCursor() MouseCursor {
	return MouseCursor(C.igGetMouseCursor())
}

// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
// MouseDragDeltaV parameter default value hint:
// button: 0
// lock_threshold: -1.0f
func MouseDragDeltaV(button MouseButton, lock_threshold float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetMouseDragDelta(internal.ReinterpretCast[*C.ImVec2](pOutArg), C.ImGuiMouseButton(button), C.float(lock_threshold))

	pOutFin()

	return *pOut
}

// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
func MousePos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetMousePos(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
func MousePosOnOpeningCurrentPopup() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetMousePosOnOpeningCurrentPopup(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

func InternalMultiSelectState(id ID) *MultiSelectState {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewMultiSelectStateFromC(C.igGetMultiSelectState(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func InternalNavTweakPressedAmount(axis Axis) float32 {
	return float32(C.igGetNavTweakPressedAmount(C.ImGuiAxis(axis)))
}

// access the ImGuiPlatformIO structure (mostly hooks/functions to connect to platform/renderer and OS Clipboard, IME etc.)
func CurrentPlatformIO() *PlatformIO {
	return NewPlatformIOFromC(C.igGetPlatformIO())
}

func InternalPopupAllowedExtentRect(window *Window) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igGetPopupAllowedExtentRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	pOutFin()
	windowFin()

	return *pOut
}

// get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x
func ScrollMaxX() float32 {
	return float32(C.igGetScrollMaxX())
}

// get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y
func ScrollMaxY() float32 {
	return float32(C.igGetScrollMaxY())
}

// get scrolling amount [0 .. GetScrollMaxX()]
func ScrollX() float32 {
	return float32(C.igGetScrollX())
}

// get scrolling amount [0 .. GetScrollMaxY()]
func ScrollY() float32 {
	return float32(C.igGetScrollY())
}

func InternalShortcutRoutingData(key_chord KeyChord) *KeyRoutingData {
	key_chordArg, key_chordFin := key_chord.C()

	defer func() {
		key_chordFin()
	}()
	return NewKeyRoutingDataFromC(C.igGetShortcutRoutingData(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg)))
}

func StateStorage() *Storage {
	return NewStorageFromC(C.igGetStateStorage())
}

// access the Style structure (colors, sizes). Always use PushStyleColor(), PushStyleVar() to modify style mid-frame!
func CurrentStyle() *Style {
	return NewStyleFromC(C.igGetStyle())
}

// get a string corresponding to the enum value (for display, saving, etc.).
func StyleColorName(idx Col) string {
	return func() string {
		result := C.igGetStyleColorName(C.ImGuiCol(idx))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
func StyleColorVec4(idx Col) *Vec4 {
	return (&Vec4{}).FromC(unsafe.Pointer(C.igGetStyleColorVec4(C.ImGuiCol(idx))))
}

func InternalStyleVarInfo(idx StyleVar) *DataVarInfo {
	return NewDataVarInfoFromC(C.igGetStyleVarInfo(C.ImGuiStyleVar(idx)))
}

// ~ FontSize
func TextLineHeight() float32 {
	return float32(C.igGetTextLineHeight())
}

// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
func TextLineHeightWithSpacing() float32 {
	return float32(C.igGetTextLineHeightWithSpacing())
}

// get global imgui time. incremented by io.DeltaTime every frame.
func Time() float64 {
	return float64(C.igGetTime())
}

func InternalTopMostAndVisiblePopupModal() *Window {
	return NewWindowFromC(C.igGetTopMostAndVisiblePopupModal())
}

func InternalTopMostPopupModal() *Window {
	return NewWindowFromC(C.igGetTopMostPopupModal())
}

// horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
func TreeNodeToLabelSpacing() float32 {
	return float32(C.igGetTreeNodeToLabelSpacing())
}

func InternalTypematicRepeatRate(flags InputFlags, repeat_delay *float32, repeat_rate *float32) {
	repeat_delayArg, repeat_delayFin := internal.WrapNumberPtr[C.float, float32](repeat_delay)
	repeat_rateArg, repeat_rateFin := internal.WrapNumberPtr[C.float, float32](repeat_rate)
	C.igGetTypematicRepeatRate(C.ImGuiInputFlags(flags), repeat_delayArg, repeat_rateArg)

	repeat_delayFin()
	repeat_rateFin()
}

// InternalTypingSelectRequestV parameter default value hint:
// flags: ImGuiTypingSelectFlags_None
func InternalTypingSelectRequestV(flags TypingSelectFlags) *TypingSelectRequest {
	return NewTypingSelectRequestFromC(C.igGetTypingSelectRequest(C.ImGuiTypingSelectFlags(flags)))
}

// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)
func Version() string {
	return func() string {
		result := C.igGetVersion()
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalViewportPlatformMonitor(viewport *Viewport) *PlatformMonitor {
	viewportArg, viewportFin := viewport.Handle()

	defer func() {
		viewportFin()
	}()
	return NewPlatformMonitorFromC(C.igGetViewportPlatformMonitor(internal.ReinterpretCast[*C.ImGuiViewport](viewportArg)))
}

func InternalWindowAlwaysWantOwnTabBar(window *Window) bool {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return C.igGetWindowAlwaysWantOwnTabBar(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)) == C.bool(true)
}

func WindowDockID() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.igGetWindowDockID(); return &result }())
}

func InternalWindowDockNode() *DockNode {
	return NewDockNodeFromC(C.igGetWindowDockNode())
}

// get DPI scale currently associated to the current window's viewport.
func WindowDpiScale() float32 {
	return float32(C.igGetWindowDpiScale())
}

// get draw list associated to the current window, to append your own drawing primitives
func WindowDrawList() *DrawList {
	return NewDrawListFromC(C.igGetWindowDrawList())
}

// get current window height (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().y.
func WindowHeight() float32 {
	return float32(C.igGetWindowHeight())
}

// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
func WindowPos() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetWindowPos(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

func InternalWindowResizeBorderID(window *Window, dir Dir) ID {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igGetWindowResizeBorderID(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.ImGuiDir(dir))
		return &result
	}())
}

// 0..3: corners
func InternalWindowResizeCornerID(window *Window, n int32) ID {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igGetWindowResizeCornerID(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.int(n))
		return &result
	}())
}

func InternalWindowScrollbarID(window *Window, axis Axis) ID {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igGetWindowScrollbarID(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.ImGuiAxis(axis))
		return &result
	}())
}

func InternalWindowScrollbarRect(window *Window, axis Axis) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igGetWindowScrollbarRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.ImGuiAxis(axis))

	pOutFin()
	windowFin()

	return *pOut
}

// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
func WindowSize() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igGetWindowSize(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

// get viewport currently associated to the current window.
func WindowViewport() *Viewport {
	return NewViewportFromC(C.igGetWindowViewport())
}

// get current window width (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().x.
func WindowWidth() float32 {
	return float32(C.igGetWindowWidth())
}

func InternalImAbsFloat(x float32) float32 {
	return float32(C.igImAbs_Float(C.float(x)))
}

func InternalImAbsInt(x int32) int32 {
	return int32(C.igImAbs_Int(C.int(x)))
}

func InternalImAbsDouble(x float64) float64 {
	return float64(C.igImAbs_double(C.double(x)))
}

func InternalImAlphaBlendColors(col_a uint32, col_b uint32) uint32 {
	return uint32(C.igImAlphaBlendColors(C.ImU32(col_a), C.ImU32(col_b)))
}

func InternalImBezierCubicCalc(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, t float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImBezierCubicCalc(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), C.float(t))

	pOutFin()

	return *pOut
}

// For curves with explicit number of segments
func InternalImBezierCubicClosestPoint(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, p Vec2, num_segments int32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImBezierCubicClosestPoint(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), internal.ReinterpretCast[C.ImVec2](p.ToC()), C.int(num_segments))

	pOutFin()

	return *pOut
}

// For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
func InternalImBezierCubicClosestPointCasteljau(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, p Vec2, tess_tol float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImBezierCubicClosestPointCasteljau(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), internal.ReinterpretCast[C.ImVec2](p.ToC()), C.float(tess_tol))

	pOutFin()

	return *pOut
}

func InternalImBezierQuadraticCalc(p1 Vec2, p2 Vec2, p3 Vec2, t float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImBezierQuadraticCalc(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), C.float(t))

	pOutFin()

	return *pOut
}

func InternalImBitArrayClearAllBits(arr *uint32, bitcount int32) {
	arrArg, arrFin := internal.WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArrayClearAllBits(arrArg, C.int(bitcount))

	arrFin()
}

func InternalImBitArrayClearBit(arr *uint32, n int32) {
	arrArg, arrFin := internal.WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArrayClearBit(arrArg, C.int(n))

	arrFin()
}

func InternalImBitArrayGetStorageSizeInBytes(bitcount int32) uint64 {
	return uint64(C.igImBitArrayGetStorageSizeInBytes(C.int(bitcount)))
}

func InternalImBitArraySetBit(arr *uint32, n int32) {
	arrArg, arrFin := internal.WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArraySetBit(arrArg, C.int(n))

	arrFin()
}

func InternalImBitArraySetBitRange(arr *uint32, n int32, n2 int32) {
	arrArg, arrFin := internal.WrapNumberPtr[C.ImU32, uint32](arr)
	C.igImBitArraySetBitRange(arrArg, C.int(n), C.int(n2))

	arrFin()
}

func InternalImBitArrayTestBit(arr *uint32, n int32) bool {
	arrArg, arrFin := internal.WrapNumberPtr[C.ImU32, uint32](arr)

	defer func() {
		arrFin()
	}()
	return C.igImBitArrayTestBit(arrArg, C.int(n)) == C.bool(true)
}

func InternalImCharIsBlankA(c rune) bool {
	return C.igImCharIsBlankA(C.char(c)) == C.bool(true)
}

func InternalImCharIsBlankW(c uint32) bool {
	return C.igImCharIsBlankW(C.uint(c)) == C.bool(true)
}

func InternalImCharIsXdigitA(c rune) bool {
	return C.igImCharIsXdigitA(C.char(c)) == C.bool(true)
}

func InternalImClamp(v Vec2, mn Vec2, mx Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImClamp(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](v.ToC()), internal.ReinterpretCast[C.ImVec2](mn.ToC()), internal.ReinterpretCast[C.ImVec2](mx.ToC()))

	pOutFin()

	return *pOut
}

func InternalImDot(a Vec2, b Vec2) float32 {
	return float32(C.igImDot(internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC())))
}

func InternalImExponentialMovingAverage(avg float32, sample float32, n int32) float32 {
	return float32(C.igImExponentialMovingAverage(C.float(avg), C.float(sample), C.int(n)))
}

// InternalImFileLoadToMemoryV parameter default value hint:
// out_file_size: NULL
// padding_bytes: 0
func InternalImFileLoadToMemoryV(filename string, mode string, out_file_size *uint64, padding_bytes int32) uintptr {
	filenameArg, filenameFin := internal.WrapString[C.char](filename)
	modeArg, modeFin := internal.WrapString[C.char](mode)

	defer func() {
		filenameFin()
		modeFin()
	}()
	return uintptr(C.wrap_igImFileLoadToMemoryV(filenameArg, modeArg, (*C.xulong)(out_file_size), C.int(padding_bytes)))
}

// Decent replacement for floorf()
func InternalImFloorFloat(f float32) float32 {
	return float32(C.igImFloor_Float(C.float(f)))
}

func InternalImFloorVec2(v Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImFloor_Vec2(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](v.ToC()))

	pOutFin()

	return *pOut
}

func InternalImFontAtlasBuildFinish(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.Handle()
	C.igImFontAtlasBuildFinish(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg))

	atlasFin()
}

func InternalImFontAtlasBuildInit(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.Handle()
	C.igImFontAtlasBuildInit(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg))

	atlasFin()
}

func InternalImFontAtlasBuildMultiplyCalcLookupTable(out_table *[256]uint, in_multiply_factor float32) {
	out_tableArg := make([]C.uchar, len(out_table))
	for i, out_tableV := range out_table {
		out_tableArg[i] = C.uchar(out_tableV)
	}
	C.igImFontAtlasBuildMultiplyCalcLookupTable((*C.uchar)(&out_tableArg[0]), C.float(in_multiply_factor))

	for i, out_tableV := range out_tableArg {
		(*out_table)[i] = uint(out_tableV)
	}
}

func InternalImFontAtlasBuildMultiplyRectAlpha8(table *[256]uint, pixels *uint, x int32, y int32, w int32, h int32, stride int32) {
	tableArg := make([]C.uchar, len(table))
	for i, tableV := range table {
		tableArg[i] = C.uchar(tableV)
	}
	pixelsArg, pixelsFin := internal.WrapNumberPtr[C.uchar, uint](pixels)
	C.igImFontAtlasBuildMultiplyRectAlpha8((*C.uchar)(&tableArg[0]), pixelsArg, C.int(x), C.int(y), C.int(w), C.int(h), C.int(stride))

	for i, tableV := range tableArg {
		(*table)[i] = uint(tableV)
	}

	pixelsFin()
}

func InternalImFontAtlasBuildPackCustomRects(atlas *FontAtlas, stbrp_context_opaque uintptr) {
	atlasArg, atlasFin := atlas.Handle()
	C.wrap_igImFontAtlasBuildPackCustomRects(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg), C.uintptr_t(stbrp_context_opaque))

	atlasFin()
}

func InternalImFontAtlasBuildRender32bppRectFromString(atlas *FontAtlas, x int32, y int32, w int32, h int32, in_str string, in_marker_char rune, in_marker_pixel_value uint32) {
	atlasArg, atlasFin := atlas.Handle()
	in_strArg, in_strFin := internal.WrapString[C.char](in_str)
	C.igImFontAtlasBuildRender32bppRectFromString(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg), C.int(x), C.int(y), C.int(w), C.int(h), in_strArg, C.char(in_marker_char), C.uint(in_marker_pixel_value))

	atlasFin()
	in_strFin()
}

func InternalImFontAtlasBuildRender8bppRectFromString(atlas *FontAtlas, x int32, y int32, w int32, h int32, in_str string, in_marker_char rune, in_marker_pixel_value uint) {
	atlasArg, atlasFin := atlas.Handle()
	in_strArg, in_strFin := internal.WrapString[C.char](in_str)
	C.igImFontAtlasBuildRender8bppRectFromString(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg), C.int(x), C.int(y), C.int(w), C.int(h), in_strArg, C.char(in_marker_char), C.uchar(in_marker_pixel_value))

	atlasFin()
	in_strFin()
}

func InternalImFontAtlasBuildSetupFont(atlas *FontAtlas, font *Font, font_config *FontConfig, ascent float32, descent float32) {
	atlasArg, atlasFin := atlas.Handle()
	fontArg, fontFin := font.Handle()
	font_configArg, font_configFin := font_config.Handle()
	C.igImFontAtlasBuildSetupFont(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg), internal.ReinterpretCast[*C.ImFont](fontArg), internal.ReinterpretCast[*C.ImFontConfig](font_configArg), C.float(ascent), C.float(descent))

	atlasFin()
	fontFin()
	font_configFin()
}

func InternalImFontAtlasGetBuilderForStbTruetype() *FontBuilderIO {
	return NewFontBuilderIOFromC(C.igImFontAtlasGetBuilderForStbTruetype())
}

func InternalImFontAtlasUpdateConfigDataPointers(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.Handle()
	C.igImFontAtlasUpdateConfigDataPointers(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg))

	atlasFin()
}

func InternalImFormatString(buf string, buf_size uint64, fmt string) int32 {
	bufArg, bufFin := internal.WrapString[C.char](buf)
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)

	defer func() {
		bufFin()
		fmtFin()
	}()
	return int32(C.wrap_igImFormatString(bufArg, C.xulong(buf_size), fmtArg))
}

func InternalImFormatStringToTempBuffer(out_buf []string, out_buf_end []string, fmt string) {
	out_bufArg, out_bufFin := internal.WrapStringList[C.char](out_buf)
	out_buf_endArg, out_buf_endFin := internal.WrapStringList[C.char](out_buf_end)
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igImFormatStringToTempBuffer(out_bufArg, out_buf_endArg, fmtArg)

	out_bufFin()
	out_buf_endFin()
	fmtFin()
}

// InternalImHashDataV parameter default value hint:
// seed: 0
func InternalImHashDataV(data uintptr, data_size uint64, seed ID) ID {
	seedArg, seedFin := seed.C()

	defer func() {
		seedFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_igImHashDataV(C.uintptr_t(data), C.xulong(data_size), internal.ReinterpretCast[C.ImGuiID](seedArg))
		return &result
	}())
}

// InternalImHashStrV parameter default value hint:
// data_size: 0
// seed: 0
func InternalImHashStrV(data string, data_size uint64, seed ID) ID {
	dataArg, dataFin := internal.WrapString[C.char](data)
	seedArg, seedFin := seed.C()

	defer func() {
		dataFin()
		seedFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igImHashStr(dataArg, C.xulong(data_size), internal.ReinterpretCast[C.ImGuiID](seedArg))
		return &result
	}())
}

func InternalImInvLength(lhs Vec2, fail_value float32) float32 {
	return float32(C.igImInvLength(internal.ReinterpretCast[C.ImVec2](lhs.ToC()), C.float(fail_value)))
}

func InternalImIsFloatAboveGuaranteedIntegerPrecision(f float32) bool {
	return C.igImIsFloatAboveGuaranteedIntegerPrecision(C.float(f)) == C.bool(true)
}

func InternalImIsPowerOfTwoInt(v int32) bool {
	return C.igImIsPowerOfTwo_Int(C.int(v)) == C.bool(true)
}

func InternalImIsPowerOfTwoU64(v uint64) bool {
	return C.igImIsPowerOfTwo_U64(C.ImU64(v)) == C.bool(true)
}

func InternalImLengthSqrVec2(lhs Vec2) float32 {
	return float32(C.igImLengthSqr_Vec2(internal.ReinterpretCast[C.ImVec2](lhs.ToC())))
}

func InternalImLengthSqrVec4(lhs Vec4) float32 {
	return float32(C.igImLengthSqr_Vec4(internal.ReinterpretCast[C.ImVec4](lhs.ToC())))
}

func InternalImLerpVec2Float(a Vec2, b Vec2, t float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImLerp_Vec2Float(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), C.float(t))

	pOutFin()

	return *pOut
}

func InternalImLerpVec2Vec2(a Vec2, b Vec2, t Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImLerp_Vec2Vec2(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](t.ToC()))

	pOutFin()

	return *pOut
}

func InternalImLerpVec4(a Vec4, b Vec4, t float32) Vec4 {
	pOut := new(Vec4)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImLerp_Vec4(internal.ReinterpretCast[*C.ImVec4](pOutArg), internal.ReinterpretCast[C.ImVec4](a.ToC()), internal.ReinterpretCast[C.ImVec4](b.ToC()), C.float(t))

	pOutFin()

	return *pOut
}

func InternalImLineClosestPoint(a Vec2, b Vec2, p Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImLineClosestPoint(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](p.ToC()))

	pOutFin()

	return *pOut
}

func InternalImLinearRemapClamp(s0 float32, s1 float32, d0 float32, d1 float32, x float32) float32 {
	return float32(C.igImLinearRemapClamp(C.float(s0), C.float(s1), C.float(d0), C.float(d1), C.float(x)))
}

func InternalImLinearSweep(current float32, target float32, speed float32) float32 {
	return float32(C.igImLinearSweep(C.float(current), C.float(target), C.float(speed)))
}

// DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision
func InternalImLogFloat(x float32) float32 {
	return float32(C.igImLog_Float(C.float(x)))
}

func InternalImLogDouble(x float64) float64 {
	return float64(C.igImLog_double(C.double(x)))
}

func InternalImLowerBound(in_begin *StoragePair, in_end *StoragePair, key ID) *StoragePair {
	in_beginArg, in_beginFin := in_begin.Handle()
	in_endArg, in_endFin := in_end.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		in_beginFin()
		in_endFin()
		keyFin()
	}()
	return NewStoragePairFromC(C.igImLowerBound(internal.ReinterpretCast[*C.ImGuiStoragePair](in_beginArg), internal.ReinterpretCast[*C.ImGuiStoragePair](in_endArg), internal.ReinterpretCast[C.ImGuiID](keyArg)))
}

func InternalImMax(lhs Vec2, rhs Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImMax(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](lhs.ToC()), internal.ReinterpretCast[C.ImVec2](rhs.ToC()))

	pOutFin()

	return *pOut
}

func InternalImMin(lhs Vec2, rhs Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImMin(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](lhs.ToC()), internal.ReinterpretCast[C.ImVec2](rhs.ToC()))

	pOutFin()

	return *pOut
}

func InternalImModPositive(a int32, b int32) int32 {
	return int32(C.igImModPositive(C.int(a), C.int(b)))
}

func InternalImMul(lhs Vec2, rhs Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImMul(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](lhs.ToC()), internal.ReinterpretCast[C.ImVec2](rhs.ToC()))

	pOutFin()

	return *pOut
}

func InternalImParseFormatFindEnd(format string) string {
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		formatFin()
	}()
	return func() string {
		result := C.igImParseFormatFindEnd(formatArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalImParseFormatFindStart(format string) string {
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		formatFin()
	}()
	return func() string {
		result := C.igImParseFormatFindStart(formatArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalImParseFormatPrecision(format string, default_value int32) int32 {
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		formatFin()
	}()
	return int32(C.igImParseFormatPrecision(formatArg, C.int(default_value)))
}

func InternalImParseFormatSanitizeForPrinting(fmt_in string, fmt_out string, fmt_out_size uint64) {
	fmt_inArg, fmt_inFin := internal.WrapString[C.char](fmt_in)
	fmt_outArg, fmt_outFin := internal.WrapString[C.char](fmt_out)
	C.igImParseFormatSanitizeForPrinting(fmt_inArg, fmt_outArg, C.xulong(fmt_out_size))

	fmt_inFin()
	fmt_outFin()
}

func InternalImParseFormatSanitizeForScanning(fmt_in string, fmt_out string, fmt_out_size uint64) string {
	fmt_inArg, fmt_inFin := internal.WrapString[C.char](fmt_in)
	fmt_outArg, fmt_outFin := internal.WrapString[C.char](fmt_out)

	defer func() {
		fmt_inFin()
		fmt_outFin()
	}()
	return func() string {
		result := C.igImParseFormatSanitizeForScanning(fmt_inArg, fmt_outArg, C.xulong(fmt_out_size))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalImParseFormatTrimDecorations(format string, buf string, buf_size uint64) string {
	formatArg, formatFin := internal.WrapString[C.char](format)
	bufArg, bufFin := internal.WrapString[C.char](buf)

	defer func() {
		formatFin()
		bufFin()
	}()
	return func() string {
		result := C.igImParseFormatTrimDecorations(formatArg, bufArg, C.xulong(buf_size))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
func InternalImPowFloat(x float32, y float32) float32 {
	return float32(C.igImPow_Float(C.float(x), C.float(y)))
}

func InternalImPowDouble(x float64, y float64) float64 {
	return float64(C.igImPow_double(C.double(x), C.double(y)))
}

func InternalImRotate(v Vec2, cos_a float32, sin_a float32) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImRotate(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](v.ToC()), C.float(cos_a), C.float(sin_a))

	pOutFin()

	return *pOut
}

func InternalImRsqrtFloat(x float32) float32 {
	return float32(C.igImRsqrt_Float(C.float(x)))
}

func InternalImRsqrtDouble(x float64) float64 {
	return float64(C.igImRsqrt_double(C.double(x)))
}

func InternalImSaturate(f float32) float32 {
	return float32(C.igImSaturate(C.float(f)))
}

// Sign operator - returns -1, 0 or 1 based on sign of argument
func InternalImSignFloat(x float32) float32 {
	return float32(C.igImSign_Float(C.float(x)))
}

func InternalImSignDouble(x float64) float64 {
	return float64(C.igImSign_double(C.double(x)))
}

// Find first non-blank character.
func InternalImStrSkipBlank(str string) string {
	strArg, strFin := internal.WrapString[C.char](str)

	defer func() {
		strFin()
	}()
	return func() string {
		result := C.igImStrSkipBlank(strArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// Remove leading and trailing blanks from a buffer.
func InternalImStrTrimBlanks(str string) {
	strArg, strFin := internal.WrapString[C.char](str)
	C.igImStrTrimBlanks(strArg)

	strFin()
}

// Find beginning-of-line
func InternalImStrbol(buf_mid_line string, buf_begin string) string {
	buf_mid_lineArg, buf_mid_lineFin := internal.WrapString[C.char](buf_mid_line)
	buf_beginArg, buf_beginFin := internal.WrapString[C.char](buf_begin)

	defer func() {
		buf_mid_lineFin()
		buf_beginFin()
	}()
	return func() string {
		result := C.igImStrbol(buf_mid_lineArg, buf_beginArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// Find first occurrence of 'c' in string range.
func InternalImStrchrRange(str_begin string, str_end string, c rune) string {
	str_beginArg, str_beginFin := internal.WrapString[C.char](str_begin)
	str_endArg, str_endFin := internal.WrapString[C.char](str_end)

	defer func() {
		str_beginFin()
		str_endFin()
	}()
	return func() string {
		result := C.igImStrchrRange(str_beginArg, str_endArg, C.char(c))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// Duplicate a string.
func InternalImStrdup(str string) string {
	strArg, strFin := internal.WrapString[C.char](str)

	defer func() {
		strFin()
	}()
	return func() string {
		result := C.igImStrdup(strArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// Copy in provided buffer, recreate buffer if needed.
func InternalImStrdupcpy(dst string, p_dst_size *uint64, str string) string {
	dstArg, dstFin := internal.WrapString[C.char](dst)
	strArg, strFin := internal.WrapString[C.char](str)

	defer func() {
		dstFin()
		strFin()
	}()
	return func() string {
		result := C.igImStrdupcpy(dstArg, (*C.xulong)(p_dst_size), strArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// End end-of-line
func InternalImStreolRange(str string, str_end string) string {
	strArg, strFin := internal.WrapString[C.char](str)
	str_endArg, str_endFin := internal.WrapString[C.char](str_end)

	defer func() {
		strFin()
		str_endFin()
	}()
	return func() string {
		result := C.igImStreolRange(strArg, str_endArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// Case insensitive compare.
func InternalImStricmp(str1 string, str2 string) int32 {
	str1Arg, str1Fin := internal.WrapString[C.char](str1)
	str2Arg, str2Fin := internal.WrapString[C.char](str2)

	defer func() {
		str1Fin()
		str2Fin()
	}()
	return int32(C.igImStricmp(str1Arg, str2Arg))
}

// Find a substring in a string range.
func InternalImStristr(haystack string, haystack_end string, needle string, needle_end string) string {
	haystackArg, haystackFin := internal.WrapString[C.char](haystack)
	haystack_endArg, haystack_endFin := internal.WrapString[C.char](haystack_end)
	needleArg, needleFin := internal.WrapString[C.char](needle)
	needle_endArg, needle_endFin := internal.WrapString[C.char](needle_end)

	defer func() {
		haystackFin()
		haystack_endFin()
		needleFin()
		needle_endFin()
	}()
	return func() string {
		result := C.igImStristr(haystackArg, haystack_endArg, needleArg, needle_endArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// Computer string length (ImWchar string)
func InternalImStrlenW(str *Wchar) int32 {
	return int32(C.igImStrlenW((*C.ImWchar)(str)))
}

// Copy to a certain count and always zero terminate (strncpy doesn't).
func InternalImStrncpy(dst string, src string, count uint64) {
	dstArg, dstFin := internal.WrapString[C.char](dst)
	srcArg, srcFin := internal.WrapString[C.char](src)
	C.igImStrncpy(dstArg, srcArg, C.xulong(count))

	dstFin()
	srcFin()
}

// Case insensitive compare to a certain count.
func InternalImStrnicmp(str1 string, str2 string, count uint64) int32 {
	str1Arg, str1Fin := internal.WrapString[C.char](str1)
	str2Arg, str2Fin := internal.WrapString[C.char](str2)

	defer func() {
		str1Fin()
		str2Fin()
	}()
	return int32(C.igImStrnicmp(str1Arg, str2Arg, C.xulong(count)))
}

// read one character. return input UTF-8 bytes count
func InternalImTextCharFromUtf8(out_char *uint32, in_text string, in_text_end string) int32 {
	out_charArg, out_charFin := internal.WrapNumberPtr[C.uint, uint32](out_char)
	in_textArg, in_textFin := internal.WrapString[C.char](in_text)
	in_text_endArg, in_text_endFin := internal.WrapString[C.char](in_text_end)

	defer func() {
		out_charFin()
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.igImTextCharFromUtf8(out_charArg, in_textArg, in_text_endArg))
}

// return out_buf
func InternalImTextCharToUtf8(out_buf *[5]rune, c uint32) string {
	out_bufArg := make([]C.char, len(out_buf))
	for i, out_bufV := range out_buf {
		out_bufArg[i] = C.char(out_bufV)
	}

	defer func() {
		for i, out_bufV := range out_bufArg {
			(*out_buf)[i] = rune(out_bufV)
		}
	}()
	return func() string {
		result := C.igImTextCharToUtf8((*C.char)(&out_bufArg[0]), C.uint(c))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// return number of UTF-8 code-points (NOT bytes count)
func InternalImTextCountCharsFromUtf8(in_text string, in_text_end string) int32 {
	in_textArg, in_textFin := internal.WrapString[C.char](in_text)
	in_text_endArg, in_text_endFin := internal.WrapString[C.char](in_text_end)

	defer func() {
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.igImTextCountCharsFromUtf8(in_textArg, in_text_endArg))
}

// return number of lines taken by text. trailing carriage return doesn't count as an extra line.
func InternalImTextCountLines(in_text string, in_text_end string) int32 {
	in_textArg, in_textFin := internal.WrapString[C.char](in_text)
	in_text_endArg, in_text_endFin := internal.WrapString[C.char](in_text_end)

	defer func() {
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.igImTextCountLines(in_textArg, in_text_endArg))
}

// return number of bytes to express one char in UTF-8
func InternalImTextCountUtf8BytesFromChar(in_text string, in_text_end string) int32 {
	in_textArg, in_textFin := internal.WrapString[C.char](in_text)
	in_text_endArg, in_text_endFin := internal.WrapString[C.char](in_text_end)

	defer func() {
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.igImTextCountUtf8BytesFromChar(in_textArg, in_text_endArg))
}

// return number of bytes to express string in UTF-8
func InternalImTextCountUtf8BytesFromStr(in_text *Wchar, in_text_end *Wchar) int32 {
	return int32(C.igImTextCountUtf8BytesFromStr((*C.ImWchar)(in_text), (*C.ImWchar)(in_text_end)))
}

// return previous UTF-8 code-point.
func InternalImTextFindPreviousUtf8Codepoint(in_text_start string, in_text_curr string) string {
	in_text_startArg, in_text_startFin := internal.WrapString[C.char](in_text_start)
	in_text_currArg, in_text_currFin := internal.WrapString[C.char](in_text_curr)

	defer func() {
		in_text_startFin()
		in_text_currFin()
	}()
	return func() string {
		result := C.igImTextFindPreviousUtf8Codepoint(in_text_startArg, in_text_currArg)
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// return input UTF-8 bytes count
// InternalImTextStrFromUtf8V parameter default value hint:
// in_remaining: NULL
func InternalImTextStrFromUtf8V(out_buf *Wchar, out_buf_size int32, in_text string, in_text_end string, in_remaining []string) int32 {
	in_textArg, in_textFin := internal.WrapString[C.char](in_text)
	in_text_endArg, in_text_endFin := internal.WrapString[C.char](in_text_end)
	in_remainingArg, in_remainingFin := internal.WrapStringList[C.char](in_remaining)

	defer func() {
		in_textFin()
		in_text_endFin()
		in_remainingFin()
	}()
	return int32(C.igImTextStrFromUtf8((*C.ImWchar)(out_buf), C.int(out_buf_size), in_textArg, in_text_endArg, in_remainingArg))
}

// return output UTF-8 bytes count
func InternalImTextStrToUtf8(out_buf string, out_buf_size int32, in_text *Wchar, in_text_end *Wchar) int32 {
	out_bufArg, out_bufFin := internal.WrapString[C.char](out_buf)

	defer func() {
		out_bufFin()
	}()
	return int32(C.igImTextStrToUtf8(out_bufArg, C.int(out_buf_size), (*C.ImWchar)(in_text), (*C.ImWchar)(in_text_end)))
}

func InternalImToUpper(c rune) rune {
	return rune(C.igImToUpper(C.char(c)))
}

func InternalImTriangleArea(a Vec2, b Vec2, c Vec2) float32 {
	return float32(C.igImTriangleArea(internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](c.ToC())))
}

func InternalImTriangleBarycentricCoords(a Vec2, b Vec2, c Vec2, p Vec2, out_u *float32, out_v *float32, out_w *float32) {
	out_uArg, out_uFin := internal.WrapNumberPtr[C.float, float32](out_u)
	out_vArg, out_vFin := internal.WrapNumberPtr[C.float, float32](out_v)
	out_wArg, out_wFin := internal.WrapNumberPtr[C.float, float32](out_w)
	C.igImTriangleBarycentricCoords(internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](c.ToC()), internal.ReinterpretCast[C.ImVec2](p.ToC()), out_uArg, out_vArg, out_wArg)

	out_uFin()
	out_vFin()
	out_wFin()
}

func InternalImTriangleClosestPoint(a Vec2, b Vec2, c Vec2, p Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImTriangleClosestPoint(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](c.ToC()), internal.ReinterpretCast[C.ImVec2](p.ToC()))

	pOutFin()

	return *pOut
}

func InternalImTriangleContainsPoint(a Vec2, b Vec2, c Vec2, p Vec2) bool {
	return C.igImTriangleContainsPoint(internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](c.ToC()), internal.ReinterpretCast[C.ImVec2](p.ToC())) == C.bool(true)
}

func InternalImTriangleIsClockwise(a Vec2, b Vec2, c Vec2) bool {
	return C.igImTriangleIsClockwise(internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](c.ToC())) == C.bool(true)
}

func InternalImTruncFloat(f float32) float32 {
	return float32(C.igImTrunc_Float(C.float(f)))
}

func InternalImTruncVec2(v Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.igImTrunc_Vec2(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[C.ImVec2](v.ToC()))

	pOutFin()

	return *pOut
}

func InternalImUpperPowerOfTwo(v int32) int32 {
	return int32(C.igImUpperPowerOfTwo(C.int(v)))
}

// ImageV parameter default value hint:
// uv0: ImVec2(0,0)
// uv1: ImVec2(1,1)
// tint_col: ImVec4(1,1,1,1)
// border_col: ImVec4(0,0,0,0)
func ImageV(user_texture_id TextureID, image_size Vec2, uv0 Vec2, uv1 Vec2, tint_col Vec4, border_col Vec4) {
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.igImage(internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](image_size.ToC()), internal.ReinterpretCast[C.ImVec2](uv0.ToC()), internal.ReinterpretCast[C.ImVec2](uv1.ToC()), internal.ReinterpretCast[C.ImVec4](tint_col.ToC()), internal.ReinterpretCast[C.ImVec4](border_col.ToC()))

	user_texture_idFin()
}

// ImageButtonV parameter default value hint:
// uv0: ImVec2(0,0)
// uv1: ImVec2(1,1)
// bg_col: ImVec4(0,0,0,0)
// tint_col: ImVec4(1,1,1,1)
func ImageButtonV(str_id string, user_texture_id TextureID, image_size Vec2, uv0 Vec2, uv1 Vec2, bg_col Vec4, tint_col Vec4) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	user_texture_idArg, user_texture_idFin := user_texture_id.C()

	defer func() {
		str_idFin()
		user_texture_idFin()
	}()
	return C.igImageButton(str_idArg, internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](image_size.ToC()), internal.ReinterpretCast[C.ImVec2](uv0.ToC()), internal.ReinterpretCast[C.ImVec2](uv1.ToC()), internal.ReinterpretCast[C.ImVec4](bg_col.ToC()), internal.ReinterpretCast[C.ImVec4](tint_col.ToC())) == C.bool(true)
}

// InternalImageButtonExV parameter default value hint:
// flags: 0
func InternalImageButtonExV(id ID, texture_id TextureID, image_size Vec2, uv0 Vec2, uv1 Vec2, bg_col Vec4, tint_col Vec4, flags ButtonFlags) bool {
	idArg, idFin := id.C()
	texture_idArg, texture_idFin := texture_id.C()

	defer func() {
		idFin()
		texture_idFin()
	}()
	return C.igImageButtonEx(internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[C.ImTextureID](texture_idArg), internal.ReinterpretCast[C.ImVec2](image_size.ToC()), internal.ReinterpretCast[C.ImVec2](uv0.ToC()), internal.ReinterpretCast[C.ImVec2](uv1.ToC()), internal.ReinterpretCast[C.ImVec4](bg_col.ToC()), internal.ReinterpretCast[C.ImVec4](tint_col.ToC()), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0
// IndentV parameter default value hint:
// indent_w: 0.0f
func IndentV(indent_w float32) {
	C.igIndent(C.float(indent_w))
}

func InternalInitialize() {
	C.igInitialize()
}

// InputDoubleV parameter default value hint:
// step: 0.0
// step_fast: 0.0
// format: "%.6f"
// flags: 0
func InputDoubleV(label string, v *float64, step float64, step_fast float64, format string, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.double, float64](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igInputDouble(labelArg, vArg, C.double(step), C.double(step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloatV parameter default value hint:
// step: 0.0f
// step_fast: 0.0f
// format: "%.3f"
// flags: 0
func InputFloatV(label string, v *float32, step float32, step_fast float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igInputFloat(labelArg, vArg, C.float(step), C.float(step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloat2V parameter default value hint:
// format: "%.3f"
// flags: 0
func InputFloat2V(label string, v *[2]float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igInputFloat2(labelArg, (*C.float)(&vArg[0]), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloat3V parameter default value hint:
// format: "%.3f"
// flags: 0
func InputFloat3V(label string, v *[3]float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igInputFloat3(labelArg, (*C.float)(&vArg[0]), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputFloat4V parameter default value hint:
// format: "%.3f"
// flags: 0
func InputFloat4V(label string, v *[4]float32, format string, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igInputFloat4(labelArg, (*C.float)(&vArg[0]), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputIntV parameter default value hint:
// step: 1
// step_fast: 100
// flags: 0
func InputIntV(label string, v *int32, step int32, step_fast int32, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.igInputInt(labelArg, vArg, C.int(step), C.int(step_fast), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputInt2V parameter default value hint:
// flags: 0
func InputInt2V(label string, v *[2]int32, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.igInputInt2(labelArg, (*C.int)(&vArg[0]), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputInt3V parameter default value hint:
// flags: 0
func InputInt3V(label string, v *[3]int32, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.igInputInt3(labelArg, (*C.int)(&vArg[0]), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputInt4V parameter default value hint:
// flags: 0
func InputInt4V(label string, v *[4]int32, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.igInputInt4(labelArg, (*C.int)(&vArg[0]), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputScalarV parameter default value hint:
// p_step: NULL
// p_step_fast: NULL
// format: NULL
// flags: 0
func InputScalarV(label string, data_type DataType, p_data uintptr, p_step uintptr, p_step_fast uintptr, format string, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		formatFin()
	}()
	return C.wrap_igInputScalarV(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.uintptr_t(p_step), C.uintptr_t(p_step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// InputScalarNV parameter default value hint:
// p_step: NULL
// p_step_fast: NULL
// format: NULL
// flags: 0
func InputScalarNV(label string, data_type DataType, p_data uintptr, components int32, p_step uintptr, p_step_fast uintptr, format string, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		formatFin()
	}()
	return C.wrap_igInputScalarNV(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.int(components), C.uintptr_t(p_step), C.uintptr_t(p_step_fast), formatArg, C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

func InternalInputTextDeactivateHook(id ID) {
	idArg, idFin := id.C()
	C.igInputTextDeactivateHook(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

// flexible button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
// InvisibleButtonV parameter default value hint:
// flags: 0
func InvisibleButtonV(str_id string, size Vec2, flags ButtonFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igInvisibleButton(str_idArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiButtonFlags(flags)) == C.bool(true)
}

func InternalIsActiveIdUsingNavDir(dir Dir) bool {
	return C.igIsActiveIdUsingNavDir(C.ImGuiDir(dir)) == C.bool(true)
}

func InternalIsAliasKey(key Key) bool {
	return C.igIsAliasKey(C.ImGuiKey(key)) == C.bool(true)
}

// is any item active?
func IsAnyItemActive() bool {
	return C.igIsAnyItemActive() == C.bool(true)
}

// is any item focused?
func IsAnyItemFocused() bool {
	return C.igIsAnyItemFocused() == C.bool(true)
}

// is any item hovered?
func IsAnyItemHovered() bool {
	return C.igIsAnyItemHovered() == C.bool(true)
}

// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
func IsAnyMouseDown() bool {
	return C.igIsAnyMouseDown() == C.bool(true)
}

func InternalIsClippedEx(bb Rect, id ID) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igIsClippedEx(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg)) == C.bool(true)
}

func InternalIsDragDropActive() bool {
	return C.igIsDragDropActive() == C.bool(true)
}

func InternalIsDragDropPayloadBeingAccepted() bool {
	return C.igIsDragDropPayloadBeingAccepted() == C.bool(true)
}

func InternalIsGamepadKey(key Key) bool {
	return C.igIsGamepadKey(C.ImGuiKey(key)) == C.bool(true)
}

// was the last item just made active (item was previously inactive).
func IsItemActivated() bool {
	return C.igIsItemActivated() == C.bool(true)
}

// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
func IsItemActive() bool {
	return C.igIsItemActive() == C.bool(true)
}

// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) && IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.
// IsItemClickedV parameter default value hint:
// mouse_button: 0
func IsItemClickedV(mouse_button MouseButton) bool {
	return C.igIsItemClicked(C.ImGuiMouseButton(mouse_button)) == C.bool(true)
}

// was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that require continuous editing.
func IsItemDeactivated() bool {
	return C.igIsItemDeactivated() == C.bool(true)
}

// was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
func IsItemDeactivatedAfterEdit() bool {
	return C.igIsItemDeactivatedAfterEdit() == C.bool(true)
}

// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
func IsItemEdited() bool {
	return C.igIsItemEdited() == C.bool(true)
}

// is the last item focused for keyboard/gamepad navigation?
func IsItemFocused() bool {
	return C.igIsItemFocused() == C.bool(true)
}

// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
// IsItemHoveredV parameter default value hint:
// flags: 0
func IsItemHoveredV(flags HoveredFlags) bool {
	return C.igIsItemHovered(C.ImGuiHoveredFlags(flags)) == C.bool(true)
}

// was the last item open state toggled? set by TreeNode().
func IsItemToggledOpen() bool {
	return C.igIsItemToggledOpen() == C.bool(true)
}

// Was the last item selection state toggled? Useful if you need the per-item information _before_ reaching EndMultiSelect(). We only returns toggle _event_ in order to handle clipping correctly.
func IsItemToggledSelection() bool {
	return C.igIsItemToggledSelection() == C.bool(true)
}

// is the last item visible? (items may be out of sight because of clipping/scrolling)
func IsItemVisible() bool {
	return C.igIsItemVisible() == C.bool(true)
}

// InternalIsKeyChordPressedInputFlagsV parameter default value hint:
// owner_id: 0
func InternalIsKeyChordPressedInputFlagsV(key_chord KeyChord, flags InputFlags, owner_id ID) bool {
	key_chordArg, key_chordFin := key_chord.C()
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		key_chordFin()
		owner_idFin()
	}()
	return C.igIsKeyChordPressed_InputFlags(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg), C.ImGuiInputFlags(flags), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.
func IsKeyChordPressed(key_chord KeyChord) bool {
	key_chordArg, key_chordFin := key_chord.C()

	defer func() {
		key_chordFin()
	}()
	return C.igIsKeyChordPressed_Nil(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg)) == C.bool(true)
}

func InternalIsKeyDownID(key Key, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igIsKeyDown_ID(C.ImGuiKey(key), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// is key being held.
func IsKeyDown(key Key) bool {
	return C.igIsKeyDown_Nil(C.ImGuiKey(key)) == C.bool(true)
}

// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
// IsKeyPressedBoolV parameter default value hint:
// repeat: true
func IsKeyPressedBoolV(key Key, repeat bool) bool {
	return C.igIsKeyPressed_Bool(C.ImGuiKey(key), C.bool(repeat)) == C.bool(true)
}

// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
// InternalIsKeyPressedInputFlagsV parameter default value hint:
// owner_id: 0
func InternalIsKeyPressedInputFlagsV(key Key, flags InputFlags, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igIsKeyPressed_InputFlags(C.ImGuiKey(key), C.ImGuiInputFlags(flags), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

func InternalIsKeyReleasedID(key Key, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igIsKeyReleased_ID(C.ImGuiKey(key), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// was key released (went from Down to !Down)?
func IsKeyReleased(key Key) bool {
	return C.igIsKeyReleased_Nil(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsKeyboardKey(key Key) bool {
	return C.igIsKeyboardKey(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsLRModKey(key Key) bool {
	return C.igIsLRModKey(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsLegacyKey(key Key) bool {
	return C.igIsLegacyKey(C.ImGuiKey(key)) == C.bool(true)
}

// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.
// IsMouseClickedBoolV parameter default value hint:
// repeat: false
func IsMouseClickedBoolV(button MouseButton, repeat bool) bool {
	return C.igIsMouseClicked_Bool(C.ImGuiMouseButton(button), C.bool(repeat)) == C.bool(true)
}

// InternalIsMouseClickedInputFlagsV parameter default value hint:
// owner_id: 0
func InternalIsMouseClickedInputFlagsV(button MouseButton, flags InputFlags, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igIsMouseClicked_InputFlags(C.ImGuiMouseButton(button), C.ImGuiInputFlags(flags), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

func InternalIsMouseDoubleClickedID(button MouseButton, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igIsMouseDoubleClicked_ID(C.ImGuiMouseButton(button), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)
func IsMouseDoubleClicked(button MouseButton) bool {
	return C.igIsMouseDoubleClicked_Nil(C.ImGuiMouseButton(button)) == C.bool(true)
}

func InternalIsMouseDownID(button MouseButton, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igIsMouseDown_ID(C.ImGuiMouseButton(button), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// is mouse button held?
func IsMouseDown(button MouseButton) bool {
	return C.igIsMouseDown_Nil(C.ImGuiMouseButton(button)) == C.bool(true)
}

// InternalIsMouseDragPastThresholdV parameter default value hint:
// lock_threshold: -1.0f
func InternalIsMouseDragPastThresholdV(button MouseButton, lock_threshold float32) bool {
	return C.igIsMouseDragPastThreshold(C.ImGuiMouseButton(button), C.float(lock_threshold)) == C.bool(true)
}

// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
// IsMouseDraggingV parameter default value hint:
// lock_threshold: -1.0f
func IsMouseDraggingV(button MouseButton, lock_threshold float32) bool {
	return C.igIsMouseDragging(C.ImGuiMouseButton(button), C.float(lock_threshold)) == C.bool(true)
}

// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
// IsMouseHoveringRectV parameter default value hint:
// clip: true
func IsMouseHoveringRectV(r_min Vec2, r_max Vec2, clip bool) bool {
	return C.igIsMouseHoveringRect(internal.ReinterpretCast[C.ImVec2](r_min.ToC()), internal.ReinterpretCast[C.ImVec2](r_max.ToC()), C.bool(clip)) == C.bool(true)
}

func InternalIsMouseKey(key Key) bool {
	return C.igIsMouseKey(C.ImGuiKey(key)) == C.bool(true)
}

// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
// IsMousePosValidV parameter default value hint:
// mouse_pos: NULL
func IsMousePosValidV(mouse_pos *Vec2) bool {
	mouse_posArg, mouse_posFin := internal.Wrap(mouse_pos)

	defer func() {
		mouse_posFin()
	}()
	return C.igIsMousePosValid(internal.ReinterpretCast[*C.ImVec2](mouse_posArg)) == C.bool(true)
}

func InternalIsMouseReleasedID(button MouseButton, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igIsMouseReleased_ID(C.ImGuiMouseButton(button), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// did mouse button released? (went from Down to !Down)
func IsMouseReleased(button MouseButton) bool {
	return C.igIsMouseReleased_Nil(C.ImGuiMouseButton(button)) == C.bool(true)
}

func InternalIsNamedKey(key Key) bool {
	return C.igIsNamedKey(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsNamedKeyOrMod(key Key) bool {
	return C.igIsNamedKeyOrMod(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsPopupOpenID(id ID, popup_flags PopupFlags) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igIsPopupOpen_ID(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiPopupFlags(popup_flags)) == C.bool(true)
}

// return true if the popup is open.
// IsPopupOpenStrV parameter default value hint:
// flags: 0
func IsPopupOpenStrV(str_id string, flags PopupFlags) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.igIsPopupOpen_Str(str_idArg, C.ImGuiPopupFlags(flags)) == C.bool(true)
}

// test if rectangle (of given size, starting from cursor position) is visible / not clipped.
func IsRectVisible(size Vec2) bool {
	return C.igIsRectVisible_Nil(internal.ReinterpretCast[C.ImVec2](size.ToC())) == C.bool(true)
}

// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
func IsRectVisibleVec2(rect_min Vec2, rect_max Vec2) bool {
	return C.igIsRectVisible_Vec2(internal.ReinterpretCast[C.ImVec2](rect_min.ToC()), internal.ReinterpretCast[C.ImVec2](rect_max.ToC())) == C.bool(true)
}

func InternalIsWindowAbove(potential_above *Window, potential_below *Window) bool {
	potential_aboveArg, potential_aboveFin := potential_above.Handle()
	potential_belowArg, potential_belowFin := potential_below.Handle()

	defer func() {
		potential_aboveFin()
		potential_belowFin()
	}()
	return C.igIsWindowAbove(internal.ReinterpretCast[*C.ImGuiWindow](potential_aboveArg), internal.ReinterpretCast[*C.ImGuiWindow](potential_belowArg)) == C.bool(true)
}

func IsWindowAppearing() bool {
	return C.igIsWindowAppearing() == C.bool(true)
}

func InternalIsWindowChildOf(window *Window, potential_parent *Window, popup_hierarchy bool, dock_hierarchy bool) bool {
	windowArg, windowFin := window.Handle()
	potential_parentArg, potential_parentFin := potential_parent.Handle()

	defer func() {
		windowFin()
		potential_parentFin()
	}()
	return C.igIsWindowChildOf(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiWindow](potential_parentArg), C.bool(popup_hierarchy), C.bool(dock_hierarchy)) == C.bool(true)
}

func IsWindowCollapsed() bool {
	return C.igIsWindowCollapsed() == C.bool(true)
}

// InternalIsWindowContentHoverableV parameter default value hint:
// flags: 0
func InternalIsWindowContentHoverableV(window *Window, flags HoveredFlags) bool {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return C.igIsWindowContentHoverable(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.ImGuiHoveredFlags(flags)) == C.bool(true)
}

// is current window docked into another window?
func IsWindowDocked() bool {
	return C.igIsWindowDocked() == C.bool(true)
}

// is current window focused? or its root/child, depending on flags. see flags for options.
// IsWindowFocusedV parameter default value hint:
// flags: 0
func IsWindowFocusedV(flags FocusedFlags) bool {
	return C.igIsWindowFocused(C.ImGuiFocusedFlags(flags)) == C.bool(true)
}

// is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
// IsWindowHoveredV parameter default value hint:
// flags: 0
func IsWindowHoveredV(flags HoveredFlags) bool {
	return C.igIsWindowHovered(C.ImGuiHoveredFlags(flags)) == C.bool(true)
}

func InternalIsWindowNavFocusable(window *Window) bool {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return C.igIsWindowNavFocusable(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)) == C.bool(true)
}

func InternalIsWindowWithinBeginStackOf(window *Window, potential_parent *Window) bool {
	windowArg, windowFin := window.Handle()
	potential_parentArg, potential_parentFin := potential_parent.Handle()

	defer func() {
		windowFin()
		potential_parentFin()
	}()
	return C.igIsWindowWithinBeginStackOf(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiWindow](potential_parentArg)) == C.bool(true)
}

// InternalItemAddV parameter default value hint:
// nav_bb: NULL
// extra_flags: 0
func InternalItemAddV(bb Rect, id ID, nav_bb *Rect, extra_flags ItemFlags) bool {
	idArg, idFin := id.C()
	nav_bbArg, nav_bbFin := internal.Wrap(nav_bb)

	defer func() {
		idFin()
		nav_bbFin()
	}()
	return C.igItemAdd(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[*C.ImRect](nav_bbArg), C.ImGuiItemFlags(extra_flags)) == C.bool(true)
}

func InternalItemHoverable(bb Rect, id ID, item_flags ItemFlags) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igItemHoverable(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiItemFlags(item_flags)) == C.bool(true)
}

// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
// InternalItemSizeRectV parameter default value hint:
// text_baseline_y: -1.0f
func InternalItemSizeRectV(bb Rect, text_baseline_y float32) {
	C.igItemSize_Rect(internal.ReinterpretCast[C.ImRect](bb.ToC()), C.float(text_baseline_y))
}

// InternalItemSizeVec2V parameter default value hint:
// text_baseline_y: -1.0f
func InternalItemSizeVec2V(size Vec2, text_baseline_y float32) {
	C.igItemSize_Vec2(internal.ReinterpretCast[C.ImVec2](size.ToC()), C.float(text_baseline_y))
}

func InternalKeepAliveID(id ID) {
	idArg, idFin := id.C()
	C.igKeepAliveID(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

// display text+label aligned the same way as value+label widgets
func LabelText(label string, fmt string) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igLabelText(labelArg, fmtArg)

	labelFin()
	fmtFin()
}

// ListBoxStrarrV parameter default value hint:
// height_in_items: -1
func ListBoxStrarrV(label string, current_item *int32, items []string, items_count int32, height_in_items int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	current_itemArg, current_itemFin := internal.WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := internal.WrapStringList[C.char](items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.igListBox_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count), C.int(height_in_items)) == C.bool(true)
}

// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
func LoadIniSettingsFromDisk(ini_filename string) {
	ini_filenameArg, ini_filenameFin := internal.WrapString[C.char](ini_filename)
	C.igLoadIniSettingsFromDisk(ini_filenameArg)

	ini_filenameFin()
}

// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
// LoadIniSettingsFromMemoryV parameter default value hint:
// ini_size: 0
func LoadIniSettingsFromMemoryV(ini_data string, ini_size uint64) {
	ini_dataArg, ini_dataFin := internal.WrapString[C.char](ini_data)
	C.igLoadIniSettingsFromMemory(ini_dataArg, C.xulong(ini_size))

	ini_dataFin()
}

func InternalLocalizeGetMsg(key LocKey) string {
	return func() string {
		result := C.igLocalizeGetMsg(C.ImGuiLocKey(key))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalLocalizeRegisterEntries(entries *LocEntry, count int32) {
	entriesArg, entriesFin := entries.Handle()
	C.igLocalizeRegisterEntries(internal.ReinterpretCast[*C.ImGuiLocEntry](entriesArg), C.int(count))

	entriesFin()
}

// -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
func InternalLogBegin(typeArg LogType, auto_open_depth int32) {
	C.igLogBegin(C.ImGuiLogType(typeArg), C.int(auto_open_depth))
}

// helper to display buttons for logging to tty/file/clipboard
func LogButtons() {
	C.igLogButtons()
}

// stop logging (close file, etc.)
func LogFinish() {
	C.igLogFinish()
}

// InternalLogRenderedTextV parameter default value hint:
func InternalLogRenderedTextV(ref_pos *Vec2, text string) {
	ref_posArg, ref_posFin := internal.Wrap(ref_pos)
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igLogRenderedTextV(internal.ReinterpretCast[*C.ImVec2](ref_posArg), textArg, C.int(len(text)))

	ref_posFin()
	textFin()
}

func InternalLogSetNextTextDecoration(prefix string, suffix string) {
	prefixArg, prefixFin := internal.WrapString[C.char](prefix)
	suffixArg, suffixFin := internal.WrapString[C.char](suffix)
	C.igLogSetNextTextDecoration(prefixArg, suffixArg)

	prefixFin()
	suffixFin()
}

// pass text data straight to log (without being displayed)
func LogText(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igLogText(fmtArg)

	fmtFin()
}

// Start logging/capturing to internal buffer
// InternalLogToBufferV parameter default value hint:
// auto_open_depth: -1
func InternalLogToBufferV(auto_open_depth int32) {
	C.igLogToBuffer(C.int(auto_open_depth))
}

// start logging to OS clipboard
// LogToClipboardV parameter default value hint:
// auto_open_depth: -1
func LogToClipboardV(auto_open_depth int32) {
	C.igLogToClipboard(C.int(auto_open_depth))
}

// start logging to file
// LogToFileV parameter default value hint:
// auto_open_depth: -1
// filename: NULL
func LogToFileV(auto_open_depth int32, filename string) {
	filenameArg, filenameFin := internal.WrapString[C.char](filename)
	C.igLogToFile(C.int(auto_open_depth), filenameArg)

	filenameFin()
}

// start logging to tty (stdout)
// LogToTTYV parameter default value hint:
// auto_open_depth: -1
func LogToTTYV(auto_open_depth int32) {
	C.igLogToTTY(C.int(auto_open_depth))
}

func InternalMarkIniSettingsDirty() {
	C.igMarkIniSettingsDirty_Nil()
}

func InternalMarkIniSettingsDirtyWindowPtr(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igMarkIniSettingsDirty_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

// Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
func InternalMarkItemEdited(id ID) {
	idArg, idFin := id.C()
	C.igMarkItemEdited(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

func MemAlloc(size uint64) uintptr {
	return uintptr(C.wrap_igMemAlloc(C.xulong(size)))
}

func MemFree(ptr uintptr) {
	C.wrap_igMemFree(C.uintptr_t(ptr))
}

// InternalMenuItemExV parameter default value hint:
// shortcut: NULL
// selected: false
// enabled: true
func InternalMenuItemExV(label string, icon string, shortcut string, selected bool, enabled bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	iconArg, iconFin := internal.WrapString[C.char](icon)
	shortcutArg, shortcutFin := internal.WrapString[C.char](shortcut)

	defer func() {
		labelFin()
		iconFin()
		shortcutFin()
	}()
	return C.igMenuItemEx(labelArg, iconArg, shortcutArg, C.bool(selected), C.bool(enabled)) == C.bool(true)
}

// return true when activated.
// MenuItemBoolV parameter default value hint:
// shortcut: NULL
// selected: false
// enabled: true
func MenuItemBoolV(label string, shortcut string, selected bool, enabled bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	shortcutArg, shortcutFin := internal.WrapString[C.char](shortcut)

	defer func() {
		labelFin()
		shortcutFin()
	}()
	return C.igMenuItem_Bool(labelArg, shortcutArg, C.bool(selected), C.bool(enabled)) == C.bool(true)
}

// return true when activated + toggle (*p_selected) if p_selected != NULL
// MenuItemBoolPtrV parameter default value hint:
// enabled: true
func MenuItemBoolPtrV(label string, shortcut string, p_selected *bool, enabled bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	shortcutArg, shortcutFin := internal.WrapString[C.char](shortcut)
	p_selectedArg, p_selectedFin := internal.WrapNumberPtr[C.bool, bool](p_selected)

	defer func() {
		labelFin()
		shortcutFin()
		p_selectedFin()
	}()
	return C.igMenuItem_BoolPtr(labelArg, shortcutArg, p_selectedArg, C.bool(enabled)) == C.bool(true)
}

func InternalMouseButtonToKey(button MouseButton) Key {
	return Key(C.igMouseButtonToKey(C.ImGuiMouseButton(button)))
}

func InternalMultiSelectAddSetAll(ms *MultiSelectTempData, selected bool) {
	msArg, msFin := ms.Handle()
	C.igMultiSelectAddSetAll(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](msArg), C.bool(selected))

	msFin()
}

func InternalMultiSelectAddSetRange(ms *MultiSelectTempData, selected bool, range_dir int32, first_item SelectionUserData, last_item SelectionUserData) {
	msArg, msFin := ms.Handle()
	first_itemArg, first_itemFin := first_item.C()
	last_itemArg, last_itemFin := last_item.C()
	C.igMultiSelectAddSetRange(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](msArg), C.bool(selected), C.int(range_dir), internal.ReinterpretCast[C.ImGuiSelectionUserData](first_itemArg), internal.ReinterpretCast[C.ImGuiSelectionUserData](last_itemArg))

	msFin()
	first_itemFin()
	last_itemFin()
}

func InternalMultiSelectItemFooter(id ID, p_selected *bool, p_pressed *bool) {
	idArg, idFin := id.C()
	p_selectedArg, p_selectedFin := internal.WrapNumberPtr[C.bool, bool](p_selected)
	p_pressedArg, p_pressedFin := internal.WrapNumberPtr[C.bool, bool](p_pressed)
	C.igMultiSelectItemFooter(internal.ReinterpretCast[C.ImGuiID](idArg), p_selectedArg, p_pressedArg)

	idFin()
	p_selectedFin()
	p_pressedFin()
}

func InternalMultiSelectItemHeader(id ID, p_selected *bool, p_button_flags *ButtonFlags) {
	idArg, idFin := id.C()
	p_selectedArg, p_selectedFin := internal.WrapNumberPtr[C.bool, bool](p_selected)
	C.igMultiSelectItemHeader(internal.ReinterpretCast[C.ImGuiID](idArg), p_selectedArg, (*C.ImGuiButtonFlags)(p_button_flags))

	idFin()
	p_selectedFin()
}

func InternalNavClearPreferredPosForAxis(axis Axis) {
	C.igNavClearPreferredPosForAxis(C.ImGuiAxis(axis))
}

func InternalNavHighlightActivated(id ID) {
	idArg, idFin := id.C()
	C.igNavHighlightActivated(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

func InternalNavInitRequestApplyResult() {
	C.igNavInitRequestApplyResult()
}

func InternalNavInitWindow(window *Window, force_reinit bool) {
	windowArg, windowFin := window.Handle()
	C.igNavInitWindow(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.bool(force_reinit))

	windowFin()
}

func InternalNavMoveRequestApplyResult() {
	C.igNavMoveRequestApplyResult()
}

func InternalNavMoveRequestButNoResultYet() bool {
	return C.igNavMoveRequestButNoResultYet() == C.bool(true)
}

func InternalNavMoveRequestCancel() {
	C.igNavMoveRequestCancel()
}

func InternalNavMoveRequestForward(move_dir Dir, clip_dir Dir, move_flags NavMoveFlags, scroll_flags ScrollFlags) {
	C.igNavMoveRequestForward(C.ImGuiDir(move_dir), C.ImGuiDir(clip_dir), C.ImGuiNavMoveFlags(move_flags), C.ImGuiScrollFlags(scroll_flags))
}

func InternalNavMoveRequestResolveWithLastItem(result *NavItemData) {
	resultArg, resultFin := result.Handle()
	C.igNavMoveRequestResolveWithLastItem(internal.ReinterpretCast[*C.ImGuiNavItemData](resultArg))

	resultFin()
}

func InternalNavMoveRequestResolveWithPastTreeNode(result *NavItemData, tree_node_data *TreeNodeStackData) {
	resultArg, resultFin := result.Handle()
	tree_node_dataArg, tree_node_dataFin := tree_node_data.Handle()
	C.igNavMoveRequestResolveWithPastTreeNode(internal.ReinterpretCast[*C.ImGuiNavItemData](resultArg), internal.ReinterpretCast[*C.ImGuiTreeNodeStackData](tree_node_dataArg))

	resultFin()
	tree_node_dataFin()
}

func InternalNavMoveRequestSubmit(move_dir Dir, clip_dir Dir, move_flags NavMoveFlags, scroll_flags ScrollFlags) {
	C.igNavMoveRequestSubmit(C.ImGuiDir(move_dir), C.ImGuiDir(clip_dir), C.ImGuiNavMoveFlags(move_flags), C.ImGuiScrollFlags(scroll_flags))
}

func InternalNavMoveRequestTryWrapping(window *Window, move_flags NavMoveFlags) {
	windowArg, windowFin := window.Handle()
	C.igNavMoveRequestTryWrapping(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.ImGuiNavMoveFlags(move_flags))

	windowFin()
}

func InternalNavUpdateCurrentWindowIsScrollPushableX() {
	C.igNavUpdateCurrentWindowIsScrollPushableX()
}

// start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
func NewFrame() {
	C.igNewFrame()
}

// undo a SameLine() or force a new line when in a horizontal-layout context.
func NewLine() {
	C.igNewLine()
}

// next column, defaults to current row or next row if the current row is finished
func NextColumn() {
	C.igNextColumn()
}

// InternalOpenPopupExV parameter default value hint:
// popup_flags: ImGuiPopupFlags_None
func InternalOpenPopupExV(id ID, popup_flags PopupFlags) {
	idArg, idFin := id.C()
	C.igOpenPopupEx(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiPopupFlags(popup_flags))

	idFin()
}

// helper to open popup when clicked on last item. Default to ImGuiPopupFlags_MouseButtonRight == 1. (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors)
// OpenPopupOnItemClickV parameter default value hint:
// str_id: NULL
// popup_flags: 1
func OpenPopupOnItemClickV(str_id string, popup_flags PopupFlags) {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	C.igOpenPopupOnItemClick(str_idArg, C.ImGuiPopupFlags(popup_flags))

	str_idFin()
}

// id overload to facilitate calling from nested stacks
// OpenPopupIDV parameter default value hint:
// popup_flags: 0
func OpenPopupIDV(id ID, popup_flags PopupFlags) {
	idArg, idFin := id.C()
	C.igOpenPopup_ID(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiPopupFlags(popup_flags))

	idFin()
}

// call to mark popup as open (don't call every frame!).
// OpenPopupStrV parameter default value hint:
// popup_flags: 0
func OpenPopupStrV(str_id string, popup_flags PopupFlags) {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	C.igOpenPopup_Str(str_idArg, C.ImGuiPopupFlags(popup_flags))

	str_idFin()
}

// PlotHistogramFloatPtrV parameter default value hint:
// values_offset: 0
// overlay_text: NULL
// scale_min: FLT_MAX
// scale_max: FLT_MAX
// graph_size: ImVec2(0,0)
// stride: sizeof(float)
func PlotHistogramFloatPtrV(label string, values *float32, values_count int32, values_offset int32, overlay_text string, scale_min float32, scale_max float32, graph_size Vec2, stride int32) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	valuesArg, valuesFin := internal.WrapNumberPtr[C.float, float32](values)
	overlay_textArg, overlay_textFin := internal.WrapString[C.char](overlay_text)
	C.igPlotHistogram_FloatPtr(labelArg, valuesArg, C.int(values_count), C.int(values_offset), overlay_textArg, C.float(scale_min), C.float(scale_max), internal.ReinterpretCast[C.ImVec2](graph_size.ToC()), C.int(stride))

	labelFin()
	valuesFin()
	overlay_textFin()
}

// PlotLinesFloatPtrV parameter default value hint:
// values_offset: 0
// overlay_text: NULL
// scale_min: FLT_MAX
// scale_max: FLT_MAX
// graph_size: ImVec2(0,0)
// stride: sizeof(float)
func PlotLinesFloatPtrV(label string, values *float32, values_count int32, values_offset int32, overlay_text string, scale_min float32, scale_max float32, graph_size Vec2, stride int32) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	valuesArg, valuesFin := internal.WrapNumberPtr[C.float, float32](values)
	overlay_textArg, overlay_textFin := internal.WrapString[C.char](overlay_text)
	C.igPlotLines_FloatPtr(labelArg, valuesArg, C.int(values_count), C.int(values_offset), overlay_textArg, C.float(scale_min), C.float(scale_max), internal.ReinterpretCast[C.ImVec2](graph_size.ToC()), C.int(stride))

	labelFin()
	valuesFin()
	overlay_textFin()
}

func PopClipRect() {
	C.igPopClipRect()
}

func InternalPopColumnsBackground() {
	C.igPopColumnsBackground()
}

func InternalPopFocusScope() {
	C.igPopFocusScope()
}

func PopFont() {
	C.igPopFont()
}

// pop from the ID stack.
func PopID() {
	C.igPopID()
}

func PopItemFlag() {
	C.igPopItemFlag()
}

func PopItemWidth() {
	C.igPopItemWidth()
}

// PopStyleColorV parameter default value hint:
// count: 1
func PopStyleColorV(count int32) {
	C.igPopStyleColor(C.int(count))
}

// PopStyleVarV parameter default value hint:
// count: 1
func PopStyleVarV(count int32) {
	C.igPopStyleVar(C.int(count))
}

func PopTextWrapPos() {
	C.igPopTextWrapPos()
}

// ProgressBarV parameter default value hint:
// size_arg: ImVec2(-FLT_MIN,0)
// overlay: NULL
func ProgressBarV(fraction float32, size_arg Vec2, overlay string) {
	overlayArg, overlayFin := internal.WrapString[C.char](overlay)
	C.igProgressBar(C.float(fraction), internal.ReinterpretCast[C.ImVec2](size_arg.ToC()), overlayArg)

	overlayFin()
}

func PushClipRect(clip_rect_min Vec2, clip_rect_max Vec2, intersect_with_current_clip_rect bool) {
	C.igPushClipRect(internal.ReinterpretCast[C.ImVec2](clip_rect_min.ToC()), internal.ReinterpretCast[C.ImVec2](clip_rect_max.ToC()), C.bool(intersect_with_current_clip_rect))
}

func InternalPushColumnClipRect(column_index int32) {
	C.igPushColumnClipRect(C.int(column_index))
}

func InternalPushColumnsBackground() {
	C.igPushColumnsBackground()
}

func InternalPushFocusScope(id ID) {
	idArg, idFin := id.C()
	C.igPushFocusScope(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

// use NULL as a shortcut to push default font
func PushFont(font *Font) {
	fontArg, fontFin := font.Handle()
	C.igPushFont(internal.ReinterpretCast[*C.ImFont](fontArg))

	fontFin()
}

// push integer into the ID stack (will hash integer).
func PushIDInt(int_id int32) {
	C.igPushID_Int(C.int(int_id))
}

// push pointer into the ID stack (will hash pointer).
func PushIDPtr(ptr_id uintptr) {
	C.wrap_igPushID_Ptr(C.uintptr_t(ptr_id))
}

// push string into the ID stack (will hash string).
func PushIDStr(str_id string) {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	C.igPushID_Str(str_idArg)

	str_idFin()
}

// push string into the ID stack (will hash string).
func PushIDStrStr(str_id_begin string, str_id_end string) {
	str_id_beginArg, str_id_beginFin := internal.WrapString[C.char](str_id_begin)
	str_id_endArg, str_id_endFin := internal.WrapString[C.char](str_id_end)
	C.igPushID_StrStr(str_id_beginArg, str_id_endArg)

	str_id_beginFin()
	str_id_endFin()
}

// modify specified shared item flag, e.g. PushItemFlag(ImGuiItemFlags_NoTabStop, true)
func PushItemFlag(option ItemFlags, enabled bool) {
	C.igPushItemFlag(C.ImGuiItemFlags(option), C.bool(enabled))
}

// push width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).
func PushItemWidth(item_width float32) {
	C.igPushItemWidth(C.float(item_width))
}

func InternalPushMultiItemsWidths(components int32, width_full float32) {
	C.igPushMultiItemsWidths(C.int(components), C.float(width_full))
}

// Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
func InternalPushOverrideID(id ID) {
	idArg, idFin := id.C()
	C.igPushOverrideID(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

// modify a style color. always use this if you modify the style after NewFrame().
func PushStyleColorU32(idx Col, col uint32) {
	C.igPushStyleColor_U32(C.ImGuiCol(idx), C.ImU32(col))
}

func PushStyleColorVec4(idx Col, col Vec4) {
	C.igPushStyleColor_Vec4(C.ImGuiCol(idx), internal.ReinterpretCast[C.ImVec4](col.ToC()))
}

// modify X component of a style ImVec2 variable. "
func PushStyleVarX(idx StyleVar, val_x float32) {
	C.igPushStyleVarX(C.ImGuiStyleVar(idx), C.float(val_x))
}

// modify Y component of a style ImVec2 variable. "
func PushStyleVarY(idx StyleVar, val_y float32) {
	C.igPushStyleVarY(C.ImGuiStyleVar(idx), C.float(val_y))
}

// modify a style float variable. always use this if you modify the style after NewFrame()!
func PushStyleVarFloat(idx StyleVar, val float32) {
	C.igPushStyleVar_Float(C.ImGuiStyleVar(idx), C.float(val))
}

// modify a style ImVec2 variable. "
func PushStyleVarVec2(idx StyleVar, val Vec2) {
	C.igPushStyleVar_Vec2(C.ImGuiStyleVar(idx), internal.ReinterpretCast[C.ImVec2](val.ToC()))
}

// push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
// PushTextWrapPosV parameter default value hint:
// wrap_local_pos_x: 0.0f
func PushTextWrapPosV(wrap_local_pos_x float32) {
	C.igPushTextWrapPos(C.float(wrap_local_pos_x))
}

// use with e.g. if (RadioButton("one", my_value==1))  my_value = 1;
func RadioButtonBool(label string, active bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igRadioButton_Bool(labelArg, C.bool(active)) == C.bool(true)
}

// shortcut to handle the above pattern when value is an integer
func RadioButtonIntPtr(label string, v *int32, v_button int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.igRadioButton_IntPtr(labelArg, vArg, C.int(v_button)) == C.bool(true)
}

func InternalRemoveContextHook(context *Context, hook_to_remove ID) {
	contextArg, contextFin := context.Handle()
	hook_to_removeArg, hook_to_removeFin := hook_to_remove.C()
	C.igRemoveContextHook(internal.ReinterpretCast[*C.ImGuiContext](contextArg), internal.ReinterpretCast[C.ImGuiID](hook_to_removeArg))

	contextFin()
	hook_to_removeFin()
}

func InternalRemoveSettingsHandler(type_name string) {
	type_nameArg, type_nameFin := internal.WrapString[C.char](type_name)
	C.igRemoveSettingsHandler(type_nameArg)

	type_nameFin()
}

// ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
func Render() {
	C.igRender()
}

// InternalRenderArrowV parameter default value hint:
// scale: 1.0f
func InternalRenderArrowV(draw_list *DrawList, pos Vec2, col uint32, dir Dir, scale float32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderArrow(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), C.ImGuiDir(dir), C.float(scale))

	draw_listFin()
}

func InternalRenderArrowDockMenu(draw_list *DrawList, p_min Vec2, sz float32, col uint32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderArrowDockMenu(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), C.float(sz), C.ImU32(col))

	draw_listFin()
}

func InternalRenderArrowPointingAt(draw_list *DrawList, pos Vec2, half_sz Vec2, direction Dir, col uint32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderArrowPointingAt(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), internal.ReinterpretCast[C.ImVec2](half_sz.ToC()), C.ImGuiDir(direction), C.ImU32(col))

	draw_listFin()
}

func InternalRenderBullet(draw_list *DrawList, pos Vec2, col uint32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderBullet(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col))

	draw_listFin()
}

func InternalRenderCheckMark(draw_list *DrawList, pos Vec2, col uint32, sz float32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderCheckMark(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), C.float(sz))

	draw_listFin()
}

// InternalRenderColorRectWithAlphaCheckerboardV parameter default value hint:
// rounding: 0.0f
// flags: 0
func InternalRenderColorRectWithAlphaCheckerboardV(draw_list *DrawList, p_min Vec2, p_max Vec2, fill_col uint32, grid_step float32, grid_off Vec2, rounding float32, flags DrawFlags) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderColorRectWithAlphaCheckerboard(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(fill_col), C.float(grid_step), internal.ReinterpretCast[C.ImVec2](grid_off.ToC()), C.float(rounding), C.ImDrawFlags(flags))

	draw_listFin()
}

func InternalRenderDragDropTargetRect(bb Rect, item_clip_rect Rect) {
	C.igRenderDragDropTargetRect(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImRect](item_clip_rect.ToC()))
}

// InternalRenderFrameV parameter default value hint:
// borders: true
// rounding: 0.0f
func InternalRenderFrameV(p_min Vec2, p_max Vec2, fill_col uint32, borders bool, rounding float32) {
	C.igRenderFrame(internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(fill_col), C.bool(borders), C.float(rounding))
}

// InternalRenderFrameBorderV parameter default value hint:
// rounding: 0.0f
func InternalRenderFrameBorderV(p_min Vec2, p_max Vec2, rounding float32) {
	C.igRenderFrameBorder(internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.float(rounding))
}

func InternalRenderMouseCursor(pos Vec2, scale float32, mouse_cursor MouseCursor, col_fill uint32, col_border uint32, col_shadow uint32) {
	C.igRenderMouseCursor(internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.float(scale), C.ImGuiMouseCursor(mouse_cursor), C.ImU32(col_fill), C.ImU32(col_border), C.ImU32(col_shadow))
}

// Navigation highlight
// InternalRenderNavCursorV parameter default value hint:
// flags: ImGuiNavRenderCursorFlags_None
func InternalRenderNavCursorV(bb Rect, id ID, flags NavRenderCursorFlags) {
	idArg, idFin := id.C()
	C.igRenderNavCursor(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiNavRenderCursorFlags(flags))

	idFin()
}

// call in main loop. will call RenderWindow/SwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.
// RenderPlatformWindowsDefaultV parameter default value hint:
// platform_render_arg: NULL
// renderer_render_arg: NULL
func RenderPlatformWindowsDefaultV(platform_render_arg uintptr, renderer_render_arg uintptr) {
	C.wrap_igRenderPlatformWindowsDefaultV(C.uintptr_t(platform_render_arg), C.uintptr_t(renderer_render_arg))
}

func InternalRenderRectFilledRangeH(draw_list *DrawList, rect Rect, col uint32, x_start_norm float32, x_end_norm float32, rounding float32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderRectFilledRangeH(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImRect](rect.ToC()), C.ImU32(col), C.float(x_start_norm), C.float(x_end_norm), C.float(rounding))

	draw_listFin()
}

func InternalRenderRectFilledWithHole(draw_list *DrawList, outer Rect, inner Rect, col uint32, rounding float32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igRenderRectFilledWithHole(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImRect](outer.ToC()), internal.ReinterpretCast[C.ImRect](inner.ToC()), C.ImU32(col), C.float(rounding))

	draw_listFin()
}

// InternalRenderTextV parameter default value hint:
// hide_text_after_hash: true
func InternalRenderTextV(pos Vec2, text string, hide_text_after_hash bool) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igRenderTextV(internal.ReinterpretCast[C.ImVec2](pos.ToC()), textArg, C.int(len(text)), C.bool(hide_text_after_hash))

	textFin()
}

// InternalRenderTextClippedV parameter default value hint:
// align: ImVec2(0,0)
// clip_rect: NULL
func InternalRenderTextClippedV(pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2, align Vec2, clip_rect *Rect) {
	textArg, textFin := internal.WrapString[C.char](text)
	text_size_if_knownArg, text_size_if_knownFin := internal.Wrap(text_size_if_known)
	clip_rectArg, clip_rectFin := internal.Wrap(clip_rect)
	C.wrap_igRenderTextClippedV(internal.ReinterpretCast[C.ImVec2](pos_min.ToC()), internal.ReinterpretCast[C.ImVec2](pos_max.ToC()), textArg, C.int(len(text)), internal.ReinterpretCast[*C.ImVec2](text_size_if_knownArg), internal.ReinterpretCast[C.ImVec2](align.ToC()), internal.ReinterpretCast[*C.ImRect](clip_rectArg))

	textFin()
	text_size_if_knownFin()
	clip_rectFin()
}

// InternalRenderTextClippedExV parameter default value hint:
// align: ImVec2(0,0)
// clip_rect: NULL
func InternalRenderTextClippedExV(draw_list *DrawList, pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2, align Vec2, clip_rect *Rect) {
	draw_listArg, draw_listFin := draw_list.Handle()
	textArg, textFin := internal.WrapString[C.char](text)
	text_size_if_knownArg, text_size_if_knownFin := internal.Wrap(text_size_if_known)
	clip_rectArg, clip_rectFin := internal.Wrap(clip_rect)
	C.wrap_igRenderTextClippedExV(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos_min.ToC()), internal.ReinterpretCast[C.ImVec2](pos_max.ToC()), textArg, C.int(len(text)), internal.ReinterpretCast[*C.ImVec2](text_size_if_knownArg), internal.ReinterpretCast[C.ImVec2](align.ToC()), internal.ReinterpretCast[*C.ImRect](clip_rectArg))

	draw_listFin()
	textFin()
	text_size_if_knownFin()
	clip_rectFin()
}

func InternalRenderTextEllipsis(draw_list *DrawList, pos_min Vec2, pos_max Vec2, clip_max_x float32, ellipsis_max_x float32, text string, text_size_if_known *Vec2) {
	draw_listArg, draw_listFin := draw_list.Handle()
	textArg, textFin := internal.WrapString[C.char](text)
	text_size_if_knownArg, text_size_if_knownFin := internal.Wrap(text_size_if_known)
	C.wrap_igRenderTextEllipsis(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos_min.ToC()), internal.ReinterpretCast[C.ImVec2](pos_max.ToC()), C.float(clip_max_x), C.float(ellipsis_max_x), textArg, C.int(len(text)), internal.ReinterpretCast[*C.ImVec2](text_size_if_knownArg))

	draw_listFin()
	textFin()
	text_size_if_knownFin()
}

func InternalRenderTextWrapped(pos Vec2, text string, wrap_width float32) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igRenderTextWrapped(internal.ReinterpretCast[C.ImVec2](pos.ToC()), textArg, C.int(len(text)), C.float(wrap_width))

	textFin()
}

// ResetMouseDragDeltaV parameter default value hint:
// button: 0
func ResetMouseDragDeltaV(button MouseButton) {
	C.igResetMouseDragDelta(C.ImGuiMouseButton(button))
}

// call between widgets or groups to layout them horizontally. X position given in window coordinates.
// SameLineV parameter default value hint:
// offset_from_start_x: 0.0f
// spacing: -1.0f
func SameLineV(offset_from_start_x float32, spacing float32) {
	C.igSameLine(C.float(offset_from_start_x), C.float(spacing))
}

// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
func SaveIniSettingsToDisk(ini_filename string) {
	ini_filenameArg, ini_filenameFin := internal.WrapString[C.char](ini_filename)
	C.igSaveIniSettingsToDisk(ini_filenameArg)

	ini_filenameFin()
}

// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.
// SaveIniSettingsToMemoryV parameter default value hint:
// out_ini_size: NULL
func SaveIniSettingsToMemoryV(out_ini_size *uint64) string {
	return func() string {
		result := C.igSaveIniSettingsToMemory((*C.xulong)(out_ini_size))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalScaleWindowsInViewport(viewport *ViewportP, scale float32) {
	viewportArg, viewportFin := viewport.Handle()
	C.igScaleWindowsInViewport(internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg), C.float(scale))

	viewportFin()
}

func InternalScrollToBringRectIntoView(window *Window, rect Rect) {
	windowArg, windowFin := window.Handle()
	C.igScrollToBringRectIntoView(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](rect.ToC()))

	windowFin()
}

// InternalScrollToItemV parameter default value hint:
// flags: 0
func InternalScrollToItemV(flags ScrollFlags) {
	C.igScrollToItem(C.ImGuiScrollFlags(flags))
}

// InternalScrollToRectV parameter default value hint:
// flags: 0
func InternalScrollToRectV(window *Window, rect Rect, flags ScrollFlags) {
	windowArg, windowFin := window.Handle()
	C.igScrollToRect(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](rect.ToC()), C.ImGuiScrollFlags(flags))

	windowFin()
}

// InternalScrollToRectExV parameter default value hint:
// flags: 0
func InternalScrollToRectExV(window *Window, rect Rect, flags ScrollFlags) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igScrollToRectEx(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](rect.ToC()), C.ImGuiScrollFlags(flags))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalScrollbar(axis Axis) {
	C.igScrollbar(C.ImGuiAxis(axis))
}

func InternalScrollbarEx(bb Rect, id ID, axis Axis, p_scroll_v *int64, avail_v int64, contents_v int64, flags DrawFlags) bool {
	idArg, idFin := id.C()
	p_scroll_vArg, p_scroll_vFin := internal.WrapNumberPtr[C.ImS64, int64](p_scroll_v)

	defer func() {
		idFin()
		p_scroll_vFin()
	}()
	return C.igScrollbarEx(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiAxis(axis), p_scroll_vArg, C.ImS64(avail_v), C.ImS64(contents_v), C.ImDrawFlags(flags)) == C.bool(true)
}

// "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
// SelectableBoolV parameter default value hint:
// selected: false
// flags: 0
// size: ImVec2(0,0)
func SelectableBoolV(label string, selected bool, flags SelectableFlags, size Vec2) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igSelectable_Bool(labelArg, C.bool(selected), C.ImGuiSelectableFlags(flags), internal.ReinterpretCast[C.ImVec2](size.ToC())) == C.bool(true)
}

// "bool* p_selected" point to the selection state (read-write), as a convenient helper.
// SelectableBoolPtrV parameter default value hint:
// flags: 0
// size: ImVec2(0,0)
func SelectableBoolPtrV(label string, p_selected *bool, flags SelectableFlags, size Vec2) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	p_selectedArg, p_selectedFin := internal.WrapNumberPtr[C.bool, bool](p_selected)

	defer func() {
		labelFin()
		p_selectedFin()
	}()
	return C.igSelectable_BoolPtr(labelArg, p_selectedArg, C.ImGuiSelectableFlags(flags), internal.ReinterpretCast[C.ImVec2](size.ToC())) == C.bool(true)
}

// separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
func Separator() {
	C.igSeparator()
}

// InternalSeparatorExV parameter default value hint:
// thickness: 1.0f
func InternalSeparatorExV(flags SeparatorFlags, thickness float32) {
	C.igSeparatorEx(C.ImGuiSeparatorFlags(flags), C.float(thickness))
}

// currently: formatted text with an horizontal line
func SeparatorText(label string) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igSeparatorText(labelArg)

	labelFin()
}

func InternalSeparatorTextEx(id ID, label string, label_end string, extra_width float32) {
	idArg, idFin := id.C()
	labelArg, labelFin := internal.WrapString[C.char](label)
	label_endArg, label_endFin := internal.WrapString[C.char](label_end)
	C.igSeparatorTextEx(internal.ReinterpretCast[C.ImGuiID](idArg), labelArg, label_endArg, C.float(extra_width))

	idFin()
	labelFin()
	label_endFin()
}

func InternalSetActiveID(id ID, window *Window) {
	idArg, idFin := id.C()
	windowArg, windowFin := window.Handle()
	C.igSetActiveID(internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	idFin()
	windowFin()
}

func InternalSetActiveIdUsingAllKeyboardKeys() {
	C.igSetActiveIdUsingAllKeyboardKeys()
}

// SetAllocatorFunctionsV parameter default value hint:
// user_data: NULL
func SetAllocatorFunctionsV(alloc_func MemAllocFunc, free_func MemFreeFunc, user_data uintptr) {
	alloc_funcArg, alloc_funcFin := alloc_func.C()
	free_funcArg, free_funcFin := free_func.C()
	C.wrap_igSetAllocatorFunctionsV(internal.ReinterpretCast[C.ImGuiMemAllocFunc](alloc_funcArg), internal.ReinterpretCast[C.ImGuiMemFreeFunc](free_funcArg), C.uintptr_t(user_data))

	alloc_funcFin()
	free_funcFin()
}

func SetClipboardText(text string) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.igSetClipboardText(textArg)

	textFin()
}

// initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.
func SetColorEditOptions(flags ColorEditFlags) {
	C.igSetColorEditOptions(C.ImGuiColorEditFlags(flags))
}

// set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
func SetColumnOffset(column_index int32, offset_x float32) {
	C.igSetColumnOffset(C.int(column_index), C.float(offset_x))
}

// set column width (in pixels). pass -1 to use current column
func SetColumnWidth(column_index int32, width float32) {
	C.igSetColumnWidth(C.int(column_index), C.float(width))
}

func SetCurrentContext(ctx *Context) {
	ctxArg, ctxFin := ctx.Handle()
	C.igSetCurrentContext(internal.ReinterpretCast[*C.ImGuiContext](ctxArg))

	ctxFin()
}

func InternalSetCurrentFont(font *Font) {
	fontArg, fontFin := font.Handle()
	C.igSetCurrentFont(internal.ReinterpretCast[*C.ImFont](fontArg))

	fontFin()
}

func InternalSetCurrentViewport(window *Window, viewport *ViewportP) {
	windowArg, windowFin := window.Handle()
	viewportArg, viewportFin := viewport.Handle()
	C.igSetCurrentViewport(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg))

	windowFin()
	viewportFin()
}

// [window-local] "
func SetCursorPos(local_pos Vec2) {
	C.igSetCursorPos(internal.ReinterpretCast[C.ImVec2](local_pos.ToC()))
}

// [window-local] "
func SetCursorPosX(local_x float32) {
	C.igSetCursorPosX(C.float(local_x))
}

// [window-local] "
func SetCursorPosY(local_y float32) {
	C.igSetCursorPosY(C.float(local_y))
}

// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND.
func SetCursorScreenPos(pos Vec2) {
	C.igSetCursorScreenPos(internal.ReinterpretCast[C.ImVec2](pos.ToC()))
}

// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.
// SetDragDropPayloadV parameter default value hint:
// cond: 0
func SetDragDropPayloadV(typeArg string, data uintptr, sz uint64, cond Cond) bool {
	typeArgArg, typeArgFin := internal.WrapString[C.char](typeArg)

	defer func() {
		typeArgFin()
	}()
	return C.wrap_igSetDragDropPayloadV(typeArgArg, C.uintptr_t(data), C.xulong(sz), C.ImGuiCond(cond)) == C.bool(true)
}

func InternalSetFocusID(id ID, window *Window) {
	idArg, idFin := id.C()
	windowArg, windowFin := window.Handle()
	C.igSetFocusID(internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	idFin()
	windowFin()
}

func InternalSetHoveredID(id ID) {
	idArg, idFin := id.C()
	C.igSetHoveredID(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

// make last item the default focused item of of a newly appearing window.
func SetItemDefaultFocus() {
	C.igSetItemDefaultFocus()
}

// Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive())  SetKeyOwner(key, GetItemID());'.
func InternalSetItemKeyOwnerInputFlags(key Key, flags InputFlags) {
	C.igSetItemKeyOwner_InputFlags(C.ImGuiKey(key), C.ImGuiInputFlags(flags))
}

// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive())  SetKeyOwner(key, GetItemID());'.
func SetItemKeyOwner(key Key) {
	C.igSetItemKeyOwner_Nil(C.ImGuiKey(key))
}

// set a text-only tooltip if preceding item was hovered. override any previous call to SetTooltip().
func SetItemTooltip(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igSetItemTooltip(fmtArg)

	fmtFin()
}

// InternalSetKeyOwnerV parameter default value hint:
// flags: 0
func InternalSetKeyOwnerV(key Key, owner_id ID, flags InputFlags) {
	owner_idArg, owner_idFin := owner_id.C()
	C.igSetKeyOwner(C.ImGuiKey(key), internal.ReinterpretCast[C.ImGuiID](owner_idArg), C.ImGuiInputFlags(flags))

	owner_idFin()
}

// InternalSetKeyOwnersForKeyChordV parameter default value hint:
// flags: 0
func InternalSetKeyOwnersForKeyChordV(key KeyChord, owner_id ID, flags InputFlags) {
	keyArg, keyFin := key.C()
	owner_idArg, owner_idFin := owner_id.C()
	C.igSetKeyOwnersForKeyChord(internal.ReinterpretCast[C.ImGuiKeyChord](keyArg), internal.ReinterpretCast[C.ImGuiID](owner_idArg), C.ImGuiInputFlags(flags))

	keyFin()
	owner_idFin()
}

// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.
// SetKeyboardFocusHereV parameter default value hint:
// offset: 0
func SetKeyboardFocusHereV(offset int32) {
	C.igSetKeyboardFocusHere(C.int(offset))
}

func InternalSetLastItemData(item_id ID, in_flags ItemFlags, status_flags ItemStatusFlags, item_rect Rect) {
	item_idArg, item_idFin := item_id.C()
	C.igSetLastItemData(internal.ReinterpretCast[C.ImGuiID](item_idArg), C.ImGuiItemFlags(in_flags), C.ImGuiItemStatusFlags(status_flags), internal.ReinterpretCast[C.ImRect](item_rect.ToC()))

	item_idFin()
}

// set desired mouse cursor shape
func SetMouseCursor(cursor_type MouseCursor) {
	C.igSetMouseCursor(C.ImGuiMouseCursor(cursor_type))
}

// alter visibility of keyboard/gamepad cursor. by default: show when using an arrow key, hide when clicking with mouse.
func SetNavCursorVisible(visible bool) {
	C.igSetNavCursorVisible(C.bool(visible))
}

func InternalSetNavCursorVisibleAfterMove() {
	C.igSetNavCursorVisibleAfterMove()
}

func InternalSetNavFocusScope(focus_scope_id ID) {
	focus_scope_idArg, focus_scope_idFin := focus_scope_id.C()
	C.igSetNavFocusScope(internal.ReinterpretCast[C.ImGuiID](focus_scope_idArg))

	focus_scope_idFin()
}

func InternalSetNavID(id ID, nav_layer NavLayer, focus_scope_id ID, rect_rel Rect) {
	idArg, idFin := id.C()
	focus_scope_idArg, focus_scope_idFin := focus_scope_id.C()
	C.igSetNavID(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiNavLayer(nav_layer), internal.ReinterpretCast[C.ImGuiID](focus_scope_idArg), internal.ReinterpretCast[C.ImRect](rect_rel.ToC()))

	idFin()
	focus_scope_idFin()
}

func InternalSetNavWindow(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igSetNavWindow(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.
func SetNextFrameWantCaptureKeyboard(want_capture_keyboard bool) {
	C.igSetNextFrameWantCaptureKeyboard(C.bool(want_capture_keyboard))
}

// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.
func SetNextFrameWantCaptureMouse(want_capture_mouse bool) {
	C.igSetNextFrameWantCaptureMouse(C.bool(want_capture_mouse))
}

// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.
func SetNextItemAllowOverlap() {
	C.igSetNextItemAllowOverlap()
}

// set next TreeNode/CollapsingHeader open state.
// SetNextItemOpenV parameter default value hint:
// cond: 0
func SetNextItemOpenV(is_open bool, cond Cond) {
	C.igSetNextItemOpen(C.bool(is_open), C.ImGuiCond(cond))
}

func InternalSetNextItemRefVal(data_type DataType, p_data uintptr) {
	C.wrap_igSetNextItemRefVal(C.ImGuiDataType(data_type), C.uintptr_t(p_data))
}

func SetNextItemSelectionUserData(selection_user_data SelectionUserData) {
	selection_user_dataArg, selection_user_dataFin := selection_user_data.C()
	C.igSetNextItemSelectionUserData(internal.ReinterpretCast[C.ImGuiSelectionUserData](selection_user_dataArg))

	selection_user_dataFin()
}

// SetNextItemShortcutV parameter default value hint:
// flags: 0
func SetNextItemShortcutV(key_chord KeyChord, flags InputFlags) {
	key_chordArg, key_chordFin := key_chord.C()
	C.igSetNextItemShortcut(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg), C.ImGuiInputFlags(flags))

	key_chordFin()
}

// set id to use for open/close storage (default to same as item id).
func SetNextItemStorageID(storage_id ID) {
	storage_idArg, storage_idFin := storage_id.C()
	C.igSetNextItemStorageID(internal.ReinterpretCast[C.ImGuiID](storage_idArg))

	storage_idFin()
}

// set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)
func SetNextItemWidth(item_width float32) {
	C.igSetNextItemWidth(C.float(item_width))
}

// set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
func SetNextWindowBgAlpha(alpha float32) {
	C.igSetNextWindowBgAlpha(C.float(alpha))
}

// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parent/child relationship)
func SetNextWindowClass(window_class *WindowClass) {
	window_classArg, window_classFin := window_class.Handle()
	C.igSetNextWindowClass(internal.ReinterpretCast[*C.ImGuiWindowClass](window_classArg))

	window_classFin()
}

// set next window collapsed state. call before Begin()
// SetNextWindowCollapsedV parameter default value hint:
// cond: 0
func SetNextWindowCollapsedV(collapsed bool, cond Cond) {
	C.igSetNextWindowCollapsed(C.bool(collapsed), C.ImGuiCond(cond))
}

// set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
func SetNextWindowContentSize(size Vec2) {
	C.igSetNextWindowContentSize(internal.ReinterpretCast[C.ImVec2](size.ToC()))
}

// set next window dock id
// SetNextWindowDockIDV parameter default value hint:
// cond: 0
func SetNextWindowDockIDV(dock_id ID, cond Cond) {
	dock_idArg, dock_idFin := dock_id.C()
	C.igSetNextWindowDockID(internal.ReinterpretCast[C.ImGuiID](dock_idArg), C.ImGuiCond(cond))

	dock_idFin()
}

// set next window to be focused / top-most. call before Begin()
func SetNextWindowFocus() {
	C.igSetNextWindowFocus()
}

// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
// SetNextWindowPosV parameter default value hint:
// cond: 0
// pivot: ImVec2(0,0)
func SetNextWindowPosV(pos Vec2, cond Cond, pivot Vec2) {
	C.igSetNextWindowPos(internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImGuiCond(cond), internal.ReinterpretCast[C.ImVec2](pivot.ToC()))
}

func InternalSetNextWindowRefreshPolicy(flags WindowRefreshFlags) {
	C.igSetNextWindowRefreshPolicy(C.ImGuiWindowRefreshFlags(flags))
}

// set next window scrolling value (use < 0.0f to not affect a given axis).
func SetNextWindowScroll(scroll Vec2) {
	C.igSetNextWindowScroll(internal.ReinterpretCast[C.ImVec2](scroll.ToC()))
}

// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
// SetNextWindowSizeV parameter default value hint:
// cond: 0
func SetNextWindowSizeV(size Vec2, cond Cond) {
	C.igSetNextWindowSize(internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiCond(cond))
}

// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.
// SetNextWindowSizeConstraintsV parameter default value hint:
// custom_callback: NULL
// custom_callback_data: NULL
func SetNextWindowSizeConstraintsV(size_min Vec2, size_max Vec2, custom_callback SizeCallback, custom_callback_data uintptr) {
	custom_callbackArg, custom_callbackFin := custom_callback.C()
	C.wrap_igSetNextWindowSizeConstraintsV(internal.ReinterpretCast[C.ImVec2](size_min.ToC()), internal.ReinterpretCast[C.ImVec2](size_max.ToC()), internal.ReinterpretCast[C.ImGuiSizeCallback](custom_callbackArg), C.uintptr_t(custom_callback_data))

	custom_callbackFin()
}

// set next window viewport
func SetNextWindowViewport(viewport_id ID) {
	viewport_idArg, viewport_idFin := viewport_id.C()
	C.igSetNextWindowViewport(internal.ReinterpretCast[C.ImGuiID](viewport_idArg))

	viewport_idFin()
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
// SetScrollFromPosXFloatV parameter default value hint:
// center_x_ratio: 0.5f
func SetScrollFromPosXFloatV(local_x float32, center_x_ratio float32) {
	C.igSetScrollFromPosX_Float(C.float(local_x), C.float(center_x_ratio))
}

func InternalSetScrollFromPosXWindowPtr(window *Window, local_x float32, center_x_ratio float32) {
	windowArg, windowFin := window.Handle()
	C.igSetScrollFromPosX_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.float(local_x), C.float(center_x_ratio))

	windowFin()
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
// SetScrollFromPosYFloatV parameter default value hint:
// center_y_ratio: 0.5f
func SetScrollFromPosYFloatV(local_y float32, center_y_ratio float32) {
	C.igSetScrollFromPosY_Float(C.float(local_y), C.float(center_y_ratio))
}

func InternalSetScrollFromPosYWindowPtr(window *Window, local_y float32, center_y_ratio float32) {
	windowArg, windowFin := window.Handle()
	C.igSetScrollFromPosY_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.float(local_y), C.float(center_y_ratio))

	windowFin()
}

// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// SetScrollHereXV parameter default value hint:
// center_x_ratio: 0.5f
func SetScrollHereXV(center_x_ratio float32) {
	C.igSetScrollHereX(C.float(center_x_ratio))
}

// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// SetScrollHereYV parameter default value hint:
// center_y_ratio: 0.5f
func SetScrollHereYV(center_y_ratio float32) {
	C.igSetScrollHereY(C.float(center_y_ratio))
}

// set scrolling amount [0 .. GetScrollMaxX()]
func SetScrollXFloat(scroll_x float32) {
	C.igSetScrollX_Float(C.float(scroll_x))
}

func InternalSetScrollXWindowPtr(window *Window, scroll_x float32) {
	windowArg, windowFin := window.Handle()
	C.igSetScrollX_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.float(scroll_x))

	windowFin()
}

// set scrolling amount [0 .. GetScrollMaxY()]
func SetScrollYFloat(scroll_y float32) {
	C.igSetScrollY_Float(C.float(scroll_y))
}

func InternalSetScrollYWindowPtr(window *Window, scroll_y float32) {
	windowArg, windowFin := window.Handle()
	C.igSetScrollY_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.float(scroll_y))

	windowFin()
}

// owner_id needs to be explicit and cannot be 0
func InternalSetShortcutRouting(key_chord KeyChord, flags InputFlags, owner_id ID) bool {
	key_chordArg, key_chordFin := key_chord.C()
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		key_chordFin()
		owner_idFin()
	}()
	return C.igSetShortcutRouting(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg), C.ImGuiInputFlags(flags), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
func SetStateStorage(storage *Storage) {
	storageArg, storageFin := storage.Handle()
	C.igSetStateStorage(internal.ReinterpretCast[*C.ImGuiStorage](storageArg))

	storageFin()
}

// notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name.
func SetTabItemClosed(tab_or_docked_window_label string) {
	tab_or_docked_window_labelArg, tab_or_docked_window_labelFin := internal.WrapString[C.char](tab_or_docked_window_label)
	C.igSetTabItemClosed(tab_or_docked_window_labelArg)

	tab_or_docked_window_labelFin()
}

// set a text-only tooltip. Often used after a ImGui::IsItemHovered() check. Override any previous call to SetTooltip().
func SetTooltip(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igSetTooltip(fmtArg)

	fmtFin()
}

func InternalSetWindowClipRectBeforeSetChannel(window *Window, clip_rect Rect) {
	windowArg, windowFin := window.Handle()
	C.igSetWindowClipRectBeforeSetChannel(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](clip_rect.ToC()))

	windowFin()
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// SetWindowCollapsedBoolV parameter default value hint:
// cond: 0
func SetWindowCollapsedBoolV(collapsed bool, cond Cond) {
	C.igSetWindowCollapsed_Bool(C.bool(collapsed), C.ImGuiCond(cond))
}

// set named window collapsed state
// SetWindowCollapsedStrV parameter default value hint:
// cond: 0
func SetWindowCollapsedStrV(name string, collapsed bool, cond Cond) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.igSetWindowCollapsed_Str(nameArg, C.bool(collapsed), C.ImGuiCond(cond))

	nameFin()
}

// InternalSetWindowCollapsedWindowPtrV parameter default value hint:
// cond: 0
func InternalSetWindowCollapsedWindowPtrV(window *Window, collapsed bool, cond Cond) {
	windowArg, windowFin := window.Handle()
	C.igSetWindowCollapsed_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.bool(collapsed), C.ImGuiCond(cond))

	windowFin()
}

func InternalSetWindowDock(window *Window, dock_id ID, cond Cond) {
	windowArg, windowFin := window.Handle()
	dock_idArg, dock_idFin := dock_id.C()
	C.igSetWindowDock(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImGuiID](dock_idArg), C.ImGuiCond(cond))

	windowFin()
	dock_idFin()
}

// (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
func SetWindowFocus() {
	C.igSetWindowFocus_Nil()
}

// set named window to be focused / top-most. use NULL to remove focus.
func SetWindowFocusStr(name string) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.igSetWindowFocus_Str(nameArg)

	nameFin()
}

// [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
func SetWindowFontScale(scale float32) {
	C.igSetWindowFontScale(C.float(scale))
}

func InternalSetWindowHiddenAndSkipItemsForCurrentFrame(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igSetWindowHiddenAndSkipItemsForCurrentFrame(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalSetWindowHitTestHole(window *Window, pos Vec2, size Vec2) {
	windowArg, windowFin := window.Handle()
	C.igSetWindowHitTestHole(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), internal.ReinterpretCast[C.ImVec2](size.ToC()))

	windowFin()
}

// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.
func InternalSetWindowParentWindowForFocusRoute(window *Window, parent_window *Window) {
	windowArg, windowFin := window.Handle()
	parent_windowArg, parent_windowFin := parent_window.Handle()
	C.igSetWindowParentWindowForFocusRoute(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiWindow](parent_windowArg))

	windowFin()
	parent_windowFin()
}

// set named window position.
// SetWindowPosStrV parameter default value hint:
// cond: 0
func SetWindowPosStrV(name string, pos Vec2, cond Cond) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.igSetWindowPos_Str(nameArg, internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImGuiCond(cond))

	nameFin()
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// SetWindowPosVec2V parameter default value hint:
// cond: 0
func SetWindowPosVec2V(pos Vec2, cond Cond) {
	C.igSetWindowPos_Vec2(internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImGuiCond(cond))
}

// InternalSetWindowPosWindowPtrV parameter default value hint:
// cond: 0
func InternalSetWindowPosWindowPtrV(window *Window, pos Vec2, cond Cond) {
	windowArg, windowFin := window.Handle()
	C.igSetWindowPos_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImGuiCond(cond))

	windowFin()
}

// set named window size. set axis to 0.0f to force an auto-fit on this axis.
// SetWindowSizeStrV parameter default value hint:
// cond: 0
func SetWindowSizeStrV(name string, size Vec2, cond Cond) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.igSetWindowSize_Str(nameArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiCond(cond))

	nameFin()
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// SetWindowSizeVec2V parameter default value hint:
// cond: 0
func SetWindowSizeVec2V(size Vec2, cond Cond) {
	C.igSetWindowSize_Vec2(internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiCond(cond))
}

// InternalSetWindowSizeWindowPtrV parameter default value hint:
// cond: 0
func InternalSetWindowSizeWindowPtrV(window *Window, size Vec2, cond Cond) {
	windowArg, windowFin := window.Handle()
	C.igSetWindowSize_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiCond(cond))

	windowFin()
}

func InternalSetWindowViewport(window *Window, viewport *ViewportP) {
	windowArg, windowFin := window.Handle()
	viewportArg, viewportFin := viewport.Handle()
	C.igSetWindowViewport(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg))

	windowFin()
	viewportFin()
}

func InternalShadeVertsLinearColorGradientKeepAlpha(draw_list *DrawList, vert_start_idx int32, vert_end_idx int32, gradient_p0 Vec2, gradient_p1 Vec2, col0 uint32, col1 uint32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igShadeVertsLinearColorGradientKeepAlpha(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.int(vert_start_idx), C.int(vert_end_idx), internal.ReinterpretCast[C.ImVec2](gradient_p0.ToC()), internal.ReinterpretCast[C.ImVec2](gradient_p1.ToC()), C.ImU32(col0), C.ImU32(col1))

	draw_listFin()
}

func InternalShadeVertsLinearUV(draw_list *DrawList, vert_start_idx int32, vert_end_idx int32, a Vec2, b Vec2, uv_a Vec2, uv_b Vec2, clamp bool) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igShadeVertsLinearUV(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.int(vert_start_idx), C.int(vert_end_idx), internal.ReinterpretCast[C.ImVec2](a.ToC()), internal.ReinterpretCast[C.ImVec2](b.ToC()), internal.ReinterpretCast[C.ImVec2](uv_a.ToC()), internal.ReinterpretCast[C.ImVec2](uv_b.ToC()), C.bool(clamp))

	draw_listFin()
}

func InternalShadeVertsTransformPos(draw_list *DrawList, vert_start_idx int32, vert_end_idx int32, pivot_in Vec2, cos_a float32, sin_a float32, pivot_out Vec2) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igShadeVertsTransformPos(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.int(vert_start_idx), C.int(vert_end_idx), internal.ReinterpretCast[C.ImVec2](pivot_in.ToC()), C.float(cos_a), C.float(sin_a), internal.ReinterpretCast[C.ImVec2](pivot_out.ToC()))

	draw_listFin()
}

func InternalShortcutID(key_chord KeyChord, flags InputFlags, owner_id ID) bool {
	key_chordArg, key_chordFin := key_chord.C()
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		key_chordFin()
		owner_idFin()
	}()
	return C.igShortcut_ID(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg), C.ImGuiInputFlags(flags), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// ShortcutNilV parameter default value hint:
// flags: 0
func ShortcutNilV(key_chord KeyChord, flags InputFlags) bool {
	key_chordArg, key_chordFin := key_chord.C()

	defer func() {
		key_chordFin()
	}()
	return C.igShortcut_Nil(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg), C.ImGuiInputFlags(flags)) == C.bool(true)
}

// create About window. display Dear ImGui version, credits and build/system information.
// ShowAboutWindowV parameter default value hint:
// p_open: NULL
func ShowAboutWindowV(p_open *bool) {
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)
	C.igShowAboutWindow(p_openArg)

	p_openFin()
}

// create Debug Log window. display a simplified log of important dear imgui events.
// ShowDebugLogWindowV parameter default value hint:
// p_open: NULL
func ShowDebugLogWindowV(p_open *bool) {
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)
	C.igShowDebugLogWindow(p_openArg)

	p_openFin()
}

// create Demo window. demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
// ShowDemoWindowV parameter default value hint:
// p_open: NULL
func ShowDemoWindowV(p_open *bool) {
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)
	C.igShowDemoWindow(p_openArg)

	p_openFin()
}

func InternalShowFontAtlas(atlas *FontAtlas) {
	atlasArg, atlasFin := atlas.Handle()
	C.igShowFontAtlas(internal.ReinterpretCast[*C.ImFontAtlas](atlasArg))

	atlasFin()
}

// add font selector block (not a window), essentially a combo listing the loaded fonts.
func ShowFontSelector(label string) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igShowFontSelector(labelArg)

	labelFin()
}

// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
// ShowIDStackToolWindowV parameter default value hint:
// p_open: NULL
func ShowIDStackToolWindowV(p_open *bool) {
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)
	C.igShowIDStackToolWindow(p_openArg)

	p_openFin()
}

// create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
// ShowMetricsWindowV parameter default value hint:
// p_open: NULL
func ShowMetricsWindowV(p_open *bool) {
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)
	C.igShowMetricsWindow(p_openArg)

	p_openFin()
}

// add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
// ShowStyleEditorV parameter default value hint:
// ref: NULL
func ShowStyleEditorV(ref *Style) {
	refArg, refFin := ref.Handle()
	C.igShowStyleEditor(internal.ReinterpretCast[*C.ImGuiStyle](refArg))

	refFin()
}

// add style selector block (not a window), essentially a combo listing the default styles.
func ShowStyleSelector(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igShowStyleSelector(labelArg) == C.bool(true)
}

// add basic help/info block (not a window): how to manipulate ImGui as an end-user (mouse/keyboard controls).
func ShowUserGuide() {
	C.igShowUserGuide()
}

func InternalShrinkWidths(items *ShrinkWidthItem, count int32, width_excess float32) {
	itemsArg, itemsFin := items.Handle()
	C.igShrinkWidths(internal.ReinterpretCast[*C.ImGuiShrinkWidthItem](itemsArg), C.int(count), C.float(width_excess))

	itemsFin()
}

// Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().
func InternalShutdown() {
	C.igShutdown()
}

// SliderAngleV parameter default value hint:
// v_degrees_min: -360.0f
// v_degrees_max: +360.0f
// format: "%.0f deg"
// flags: 0
func SliderAngleV(label string, v_rad *float32, v_degrees_min float32, v_degrees_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	v_radArg, v_radFin := internal.WrapNumberPtr[C.float, float32](v_rad)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		v_radFin()
		formatFin()
	}()
	return C.igSliderAngle(labelArg, v_radArg, C.float(v_degrees_min), C.float(v_degrees_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

func InternalSliderBehavior(bb Rect, id ID, data_type DataType, p_v uintptr, p_min uintptr, p_max uintptr, format string, flags SliderFlags, out_grab_bb *Rect) bool {
	idArg, idFin := id.C()
	formatArg, formatFin := internal.WrapString[C.char](format)
	out_grab_bbArg, out_grab_bbFin := internal.Wrap(out_grab_bb)

	defer func() {
		idFin()
		formatFin()
		out_grab_bbFin()
	}()
	return C.wrap_igSliderBehavior(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiDataType(data_type), C.uintptr_t(p_v), C.uintptr_t(p_min), C.uintptr_t(p_max), formatArg, C.ImGuiSliderFlags(flags), internal.ReinterpretCast[*C.ImRect](out_grab_bbArg)) == C.bool(true)
}

// adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display.
// SliderFloatV parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloatV(label string, v *float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igSliderFloat(labelArg, vArg, C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderFloat2V parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloat2V(label string, v *[2]float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igSliderFloat2(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderFloat3V parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloat3V(label string, v *[3]float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igSliderFloat3(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderFloat4V parameter default value hint:
// format: "%.3f"
// flags: 0
func SliderFloat4V(label string, v *[4]float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}

		formatFin()
	}()
	return C.igSliderFloat4(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderIntV parameter default value hint:
// format: "%d"
// flags: 0
func SliderIntV(label string, v *int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igSliderInt(labelArg, vArg, C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderInt2V parameter default value hint:
// format: "%d"
// flags: 0
func SliderInt2V(label string, v *[2]int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igSliderInt2(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderInt3V parameter default value hint:
// format: "%d"
// flags: 0
func SliderInt3V(label string, v *[3]int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igSliderInt3(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderInt4V parameter default value hint:
// format: "%d"
// flags: 0
func SliderInt4V(label string, v *[4]int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}

		formatFin()
	}()
	return C.igSliderInt4(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderScalarV parameter default value hint:
// format: NULL
// flags: 0
func SliderScalarV(label string, data_type DataType, p_data uintptr, p_min uintptr, p_max uintptr, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		formatFin()
	}()
	return C.wrap_igSliderScalarV(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.uintptr_t(p_min), C.uintptr_t(p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// SliderScalarNV parameter default value hint:
// format: NULL
// flags: 0
func SliderScalarNV(label string, data_type DataType, p_data uintptr, components int32, p_min uintptr, p_max uintptr, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		formatFin()
	}()
	return C.wrap_igSliderScalarNV(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.int(components), C.uintptr_t(p_min), C.uintptr_t(p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// button with (FramePadding.y == 0) to easily embed within text
func SmallButton(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igSmallButton(labelArg) == C.bool(true)
}

// add vertical spacing.
func Spacing() {
	C.igSpacing()
}

// InternalSplitterBehaviorV parameter default value hint:
// hover_extend: 0.0f
// hover_visibility_delay: 0.0f
// bg_col: 0
func InternalSplitterBehaviorV(bb Rect, id ID, axis Axis, size1 *float32, size2 *float32, min_size1 float32, min_size2 float32, hover_extend float32, hover_visibility_delay float32, bg_col uint32) bool {
	idArg, idFin := id.C()
	size1Arg, size1Fin := internal.WrapNumberPtr[C.float, float32](size1)
	size2Arg, size2Fin := internal.WrapNumberPtr[C.float, float32](size2)

	defer func() {
		idFin()
		size1Fin()
		size2Fin()
	}()
	return C.igSplitterBehavior(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiAxis(axis), size1Arg, size2Arg, C.float(min_size1), C.float(min_size2), C.float(hover_extend), C.float(hover_visibility_delay), C.ImU32(bg_col)) == C.bool(true)
}

func InternalStartMouseMovingWindow(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igStartMouseMovingWindow(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func InternalStartMouseMovingWindowOrNode(window *Window, node *DockNode, undock bool) {
	windowArg, windowFin := window.Handle()
	nodeArg, nodeFin := node.Handle()
	C.igStartMouseMovingWindowOrNode(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[*C.ImGuiDockNode](nodeArg), C.bool(undock))

	windowFin()
	nodeFin()
}

// classic imgui style
// StyleColorsClassicV parameter default value hint:
// dst: NULL
func StyleColorsClassicV(dst *Style) {
	dstArg, dstFin := dst.Handle()
	C.igStyleColorsClassic(internal.ReinterpretCast[*C.ImGuiStyle](dstArg))

	dstFin()
}

// new, recommended style (default)
// StyleColorsDarkV parameter default value hint:
// dst: NULL
func StyleColorsDarkV(dst *Style) {
	dstArg, dstFin := dst.Handle()
	C.igStyleColorsDark(internal.ReinterpretCast[*C.ImGuiStyle](dstArg))

	dstFin()
}

// best used with borders and a custom, thicker font
// StyleColorsLightV parameter default value hint:
// dst: NULL
func StyleColorsLightV(dst *Style) {
	dstArg, dstFin := dst.Handle()
	C.igStyleColorsLight(internal.ReinterpretCast[*C.ImGuiStyle](dstArg))

	dstFin()
}

func InternalTabBarAddTab(tab_bar *TabBar, tab_flags TabItemFlags, window *Window) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	windowArg, windowFin := window.Handle()
	C.igTabBarAddTab(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), C.ImGuiTabItemFlags(tab_flags), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	tab_barFin()
	windowFin()
}

func InternalTabBarCloseTab(tab_bar *TabBar, tab *TabItem) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tabArg, tabFin := tab.Handle()
	C.igTabBarCloseTab(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[*C.ImGuiTabItem](tabArg))

	tab_barFin()
	tabFin()
}

func InternalTabBarFindMostRecentlySelectedTabForActiveWindow(tab_bar *TabBar) *TabItem {
	tab_barArg, tab_barFin := tab_bar.Handle()

	defer func() {
		tab_barFin()
	}()
	return NewTabItemFromC(C.igTabBarFindMostRecentlySelectedTabForActiveWindow(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg)))
}

func InternalTabBarFindTabByID(tab_bar *TabBar, tab_id ID) *TabItem {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tab_idArg, tab_idFin := tab_id.C()

	defer func() {
		tab_barFin()
		tab_idFin()
	}()
	return NewTabItemFromC(C.igTabBarFindTabByID(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[C.ImGuiID](tab_idArg)))
}

func InternalTabBarFindTabByOrder(tab_bar *TabBar, order int32) *TabItem {
	tab_barArg, tab_barFin := tab_bar.Handle()

	defer func() {
		tab_barFin()
	}()
	return NewTabItemFromC(C.igTabBarFindTabByOrder(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), C.int(order)))
}

func InternalTabBarGetCurrentTab(tab_bar *TabBar) *TabItem {
	tab_barArg, tab_barFin := tab_bar.Handle()

	defer func() {
		tab_barFin()
	}()
	return NewTabItemFromC(C.igTabBarGetCurrentTab(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg)))
}

func InternalTabBarGetTabName(tab_bar *TabBar, tab *TabItem) string {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tabArg, tabFin := tab.Handle()

	defer func() {
		tab_barFin()
		tabFin()
	}()
	return func() string {
		result := C.igTabBarGetTabName(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[*C.ImGuiTabItem](tabArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalTabBarGetTabOrder(tab_bar *TabBar, tab *TabItem) int32 {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tabArg, tabFin := tab.Handle()

	defer func() {
		tab_barFin()
		tabFin()
	}()
	return int32(C.igTabBarGetTabOrder(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[*C.ImGuiTabItem](tabArg)))
}

func InternalTabBarProcessReorder(tab_bar *TabBar) bool {
	tab_barArg, tab_barFin := tab_bar.Handle()

	defer func() {
		tab_barFin()
	}()
	return C.igTabBarProcessReorder(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg)) == C.bool(true)
}

func InternalTabBarQueueFocusStr(tab_bar *TabBar, tab_name string) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tab_nameArg, tab_nameFin := internal.WrapString[C.char](tab_name)
	C.igTabBarQueueFocus_Str(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), tab_nameArg)

	tab_barFin()
	tab_nameFin()
}

func InternalTabBarQueueFocusTabItemPtr(tab_bar *TabBar, tab *TabItem) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tabArg, tabFin := tab.Handle()
	C.igTabBarQueueFocus_TabItemPtr(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[*C.ImGuiTabItem](tabArg))

	tab_barFin()
	tabFin()
}

func InternalTabBarQueueReorder(tab_bar *TabBar, tab *TabItem, offset int32) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tabArg, tabFin := tab.Handle()
	C.igTabBarQueueReorder(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[*C.ImGuiTabItem](tabArg), C.int(offset))

	tab_barFin()
	tabFin()
}

func InternalTabBarQueueReorderFromMousePos(tab_bar *TabBar, tab *TabItem, mouse_pos Vec2) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tabArg, tabFin := tab.Handle()
	C.igTabBarQueueReorderFromMousePos(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[*C.ImGuiTabItem](tabArg), internal.ReinterpretCast[C.ImVec2](mouse_pos.ToC()))

	tab_barFin()
	tabFin()
}

func InternalTabBarRemoveTab(tab_bar *TabBar, tab_id ID) {
	tab_barArg, tab_barFin := tab_bar.Handle()
	tab_idArg, tab_idFin := tab_id.C()
	C.igTabBarRemoveTab(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), internal.ReinterpretCast[C.ImGuiID](tab_idArg))

	tab_barFin()
	tab_idFin()
}

func InternalTabItemBackground(draw_list *DrawList, bb Rect, flags TabItemFlags, col uint32) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.igTabItemBackground(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImRect](bb.ToC()), C.ImGuiTabItemFlags(flags), C.ImU32(col))

	draw_listFin()
}

// create a Tab behaving like a button. return true when clicked. cannot be selected in the tab bar.
// TabItemButtonV parameter default value hint:
// flags: 0
func TabItemButtonV(label string, flags TabItemFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igTabItemButton(labelArg, C.ImGuiTabItemFlags(flags)) == C.bool(true)
}

func InternalTabItemCalcSizeStr(label string, has_close_button_or_unsaved_marker bool) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igTabItemCalcSize_Str(internal.ReinterpretCast[*C.ImVec2](pOutArg), labelArg, C.bool(has_close_button_or_unsaved_marker))

	pOutFin()
	labelFin()

	return *pOut
}

func InternalTabItemCalcSizeWindowPtr(window *Window) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igTabItemCalcSize_WindowPtr(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalTabItemEx(tab_bar *TabBar, label string, p_open *bool, flags TabItemFlags, docked_window *Window) bool {
	tab_barArg, tab_barFin := tab_bar.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	p_openArg, p_openFin := internal.WrapNumberPtr[C.bool, bool](p_open)
	docked_windowArg, docked_windowFin := docked_window.Handle()

	defer func() {
		tab_barFin()
		labelFin()
		p_openFin()
		docked_windowFin()
	}()
	return C.igTabItemEx(internal.ReinterpretCast[*C.ImGuiTabBar](tab_barArg), labelArg, p_openArg, C.ImGuiTabItemFlags(flags), internal.ReinterpretCast[*C.ImGuiWindow](docked_windowArg)) == C.bool(true)
}

func InternalTabItemLabelAndCloseButton(draw_list *DrawList, bb Rect, flags TabItemFlags, frame_padding Vec2, label string, tab_id ID, close_button_id ID, is_contents_visible bool, out_just_closed *bool, out_text_clipped *bool) {
	draw_listArg, draw_listFin := draw_list.Handle()
	labelArg, labelFin := internal.WrapString[C.char](label)
	tab_idArg, tab_idFin := tab_id.C()
	close_button_idArg, close_button_idFin := close_button_id.C()
	out_just_closedArg, out_just_closedFin := internal.WrapNumberPtr[C.bool, bool](out_just_closed)
	out_text_clippedArg, out_text_clippedFin := internal.WrapNumberPtr[C.bool, bool](out_text_clipped)
	C.igTabItemLabelAndCloseButton(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImRect](bb.ToC()), C.ImGuiTabItemFlags(flags), internal.ReinterpretCast[C.ImVec2](frame_padding.ToC()), labelArg, internal.ReinterpretCast[C.ImGuiID](tab_idArg), internal.ReinterpretCast[C.ImGuiID](close_button_idArg), C.bool(is_contents_visible), out_just_closedArg, out_text_clippedArg)

	draw_listFin()
	labelFin()
	tab_idFin()
	close_button_idFin()
	out_just_closedFin()
	out_text_clippedFin()
}

// submit a row with angled headers for every column with the ImGuiTableColumnFlags_AngledHeader flag. MUST BE FIRST ROW.
func TableAngledHeadersRow() {
	C.igTableAngledHeadersRow()
}

func InternalTableAngledHeadersRowEx(row_id ID, angle float32, max_label_width float32, data *TableHeaderData, data_count int32) {
	row_idArg, row_idFin := row_id.C()
	dataArg, dataFin := data.Handle()
	C.igTableAngledHeadersRowEx(internal.ReinterpretCast[C.ImGuiID](row_idArg), C.float(angle), C.float(max_label_width), internal.ReinterpretCast[*C.ImGuiTableHeaderData](dataArg), C.int(data_count))

	row_idFin()
	dataFin()
}

func InternalTableBeginApplyRequests(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableBeginApplyRequests(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableBeginCell(table *Table, column_n int32) {
	tableArg, tableFin := table.Handle()
	C.igTableBeginCell(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(column_n))

	tableFin()
}

func InternalTableBeginContextMenuPopup(table *Table) bool {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return C.igTableBeginContextMenuPopup(internal.ReinterpretCast[*C.ImGuiTable](tableArg)) == C.bool(true)
}

func InternalTableBeginInitMemory(table *Table, columns_count int32) {
	tableArg, tableFin := table.Handle()
	C.igTableBeginInitMemory(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(columns_count))

	tableFin()
}

func InternalTableBeginRow(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableBeginRow(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableCalcMaxColumnWidth(table *Table, column_n int32) float32 {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return float32(C.igTableCalcMaxColumnWidth(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(column_n)))
}

func InternalTableDrawBorders(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableDrawBorders(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableDrawDefaultContextMenu(table *Table, flags_for_section_to_display TableFlags) {
	tableArg, tableFin := table.Handle()
	C.igTableDrawDefaultContextMenu(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.ImGuiTableFlags(flags_for_section_to_display))

	tableFin()
}

func InternalTableEndCell(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableEndCell(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableEndRow(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableEndRow(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableFindByID(id ID) *Table {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewTableFromC(C.igTableFindByID(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

func InternalTableFixColumnSortDirection(table *Table, column *TableColumn) {
	tableArg, tableFin := table.Handle()
	columnArg, columnFin := column.Handle()
	C.igTableFixColumnSortDirection(internal.ReinterpretCast[*C.ImGuiTable](tableArg), internal.ReinterpretCast[*C.ImGuiTableColumn](columnArg))

	tableFin()
	columnFin()
}

func InternalTableGcCompactSettings() {
	C.igTableGcCompactSettings()
}

func InternalTableGcCompactTransientBuffersTablePtr(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableGcCompactTransientBuffers_TablePtr(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableGcCompactTransientBuffersTableTempDataPtr(table *TableTempData) {
	tableArg, tableFin := table.Handle()
	C.igTableGcCompactTransientBuffers_TableTempDataPtr(internal.ReinterpretCast[*C.ImGuiTableTempData](tableArg))

	tableFin()
}

func InternalTableGetBoundSettings(table *Table) *TableSettings {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return NewTableSettingsFromC(C.igTableGetBoundSettings(internal.ReinterpretCast[*C.ImGuiTable](tableArg)))
}

func InternalTableGetCellBgRect(table *Table, column_n int32) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	tableArg, tableFin := table.Handle()
	C.igTableGetCellBgRect(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(column_n))

	pOutFin()
	tableFin()

	return *pOut
}

// return number of columns (value passed to BeginTable)
func TableGetColumnCount() int32 {
	return int32(C.igTableGetColumnCount())
}

// return column flags so you can query their Enabled/Visible/Sorted/Hovered status flags. Pass -1 to use current column.
// TableGetColumnFlagsV parameter default value hint:
// column_n: -1
func TableGetColumnFlagsV(column_n int32) TableColumnFlags {
	return TableColumnFlags(C.igTableGetColumnFlags(C.int(column_n)))
}

// return current column index.
func TableGetColumnIndex() int32 {
	return int32(C.igTableGetColumnIndex())
}

// return "" if column didn't have a name declared by TableSetupColumn(). Pass -1 to use current column.
// TableGetColumnNameIntV parameter default value hint:
// column_n: -1
func TableGetColumnNameIntV(column_n int32) string {
	return func() string {
		result := C.igTableGetColumnName_Int(C.int(column_n))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalTableGetColumnNameTablePtr(table *Table, column_n int32) string {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return func() string {
		result := C.igTableGetColumnName_TablePtr(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(column_n))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalTableGetColumnNextSortDirection(column *TableColumn) SortDirection {
	columnArg, columnFin := column.Handle()

	defer func() {
		columnFin()
	}()
	return SortDirection(C.igTableGetColumnNextSortDirection(internal.ReinterpretCast[*C.ImGuiTableColumn](columnArg)))
}

// InternalTableGetColumnResizeIDV parameter default value hint:
// instance_no: 0
func InternalTableGetColumnResizeIDV(table *Table, column_n int32, instance_no int32) ID {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igTableGetColumnResizeID(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(column_n), C.int(instance_no))
		return &result
	}())
}

func InternalTableGetColumnWidthAuto(table *Table, column *TableColumn) float32 {
	tableArg, tableFin := table.Handle()
	columnArg, columnFin := column.Handle()

	defer func() {
		tableFin()
		columnFin()
	}()
	return float32(C.igTableGetColumnWidthAuto(internal.ReinterpretCast[*C.ImGuiTable](tableArg), internal.ReinterpretCast[*C.ImGuiTableColumn](columnArg)))
}

func InternalTableGetHeaderAngledMaxLabelWidth() float32 {
	return float32(C.igTableGetHeaderAngledMaxLabelWidth())
}

func InternalTableGetHeaderRowHeight() float32 {
	return float32(C.igTableGetHeaderRowHeight())
}

// return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered. Can also use (TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered) instead.
func TableGetHoveredColumn() int32 {
	return int32(C.igTableGetHoveredColumn())
}

// Retrieve *PREVIOUS FRAME* hovered row. This difference with TableGetHoveredColumn() is the reason why this is not public yet.
func InternalTableGetHoveredRow() int32 {
	return int32(C.igTableGetHoveredRow())
}

func InternalTableGetInstanceData(table *Table, instance_no int32) *TableInstanceData {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return NewTableInstanceDataFromC(C.igTableGetInstanceData(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(instance_no)))
}

func InternalTableGetInstanceID(table *Table, instance_no int32) ID {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.igTableGetInstanceID(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(instance_no))
		return &result
	}())
}

// return current row index.
func TableGetRowIndex() int32 {
	return int32(C.igTableGetRowIndex())
}

// get latest sort specs for the table (NULL if not sorting).  Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable().
func TableGetSortSpecs() *TableSortSpecs {
	return NewTableSortSpecsFromC(C.igTableGetSortSpecs())
}

// submit one header cell manually (rarely used)
func TableHeader(label string) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.igTableHeader(labelArg)

	labelFin()
}

// submit a row with headers cells based on data provided to TableSetupColumn() + submit context menu
func TableHeadersRow() {
	C.igTableHeadersRow()
}

func InternalTableLoadSettings(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableLoadSettings(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableMergeDrawChannels(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableMergeDrawChannels(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

// append into the next column (or first column of next row if currently in last column). Return true when column is visible.
func TableNextColumn() bool {
	return C.igTableNextColumn() == C.bool(true)
}

// append into the first cell of a new row.
// TableNextRowV parameter default value hint:
// row_flags: 0
// min_row_height: 0.0f
func TableNextRowV(row_flags TableRowFlags, min_row_height float32) {
	C.igTableNextRow(C.ImGuiTableRowFlags(row_flags), C.float(min_row_height))
}

// InternalTableOpenContextMenuV parameter default value hint:
// column_n: -1
func InternalTableOpenContextMenuV(column_n int32) {
	C.igTableOpenContextMenu(C.int(column_n))
}

func InternalTablePopBackgroundChannel() {
	C.igTablePopBackgroundChannel()
}

func InternalTablePushBackgroundChannel() {
	C.igTablePushBackgroundChannel()
}

func InternalTableRemove(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableRemove(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableResetSettings(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableResetSettings(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableSaveSettings(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableSaveSettings(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

// change the color of a cell, row, or column. See ImGuiTableBgTarget_ flags for details.
// TableSetBgColorV parameter default value hint:
// column_n: -1
func TableSetBgColorV(target TableBgTarget, color uint32, column_n int32) {
	C.igTableSetBgColor(C.ImGuiTableBgTarget(target), C.ImU32(color), C.int(column_n))
}

// change user accessible enabled/disabled state of a column. Set to false to hide the column. User can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
func TableSetColumnEnabled(column_n int32, v bool) {
	C.igTableSetColumnEnabled(C.int(column_n), C.bool(v))
}

// append into the specified column. Return true when column is visible.
func TableSetColumnIndex(column_n int32) bool {
	return C.igTableSetColumnIndex(C.int(column_n)) == C.bool(true)
}

func InternalTableSetColumnSortDirection(column_n int32, sort_direction SortDirection, append_to_sort_specs bool) {
	C.igTableSetColumnSortDirection(C.int(column_n), C.ImGuiSortDirection(sort_direction), C.bool(append_to_sort_specs))
}

func InternalTableSetColumnWidth(column_n int32, width float32) {
	C.igTableSetColumnWidth(C.int(column_n), C.float(width))
}

func InternalTableSetColumnWidthAutoAll(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableSetColumnWidthAutoAll(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableSetColumnWidthAutoSingle(table *Table, column_n int32) {
	tableArg, tableFin := table.Handle()
	C.igTableSetColumnWidthAutoSingle(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(column_n))

	tableFin()
}

func InternalTableSettingsAddSettingsHandler() {
	C.igTableSettingsAddSettingsHandler()
}

func InternalTableSettingsCreate(id ID, columns_count int32) *TableSettings {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewTableSettingsFromC(C.igTableSettingsCreate(internal.ReinterpretCast[C.ImGuiID](idArg), C.int(columns_count)))
}

func InternalTableSettingsFindByID(id ID) *TableSettings {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return NewTableSettingsFromC(C.igTableSettingsFindByID(internal.ReinterpretCast[C.ImGuiID](idArg)))
}

// TableSetupColumnV parameter default value hint:
// flags: 0
// init_width_or_weight: 0.0f
// user_id: 0
func TableSetupColumnV(label string, flags TableColumnFlags, init_width_or_weight float32, user_id ID) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	user_idArg, user_idFin := user_id.C()
	C.igTableSetupColumn(labelArg, C.ImGuiTableColumnFlags(flags), C.float(init_width_or_weight), internal.ReinterpretCast[C.ImGuiID](user_idArg))

	labelFin()
	user_idFin()
}

func InternalTableSetupDrawChannels(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableSetupDrawChannels(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

// lock columns/rows so they stay visible when scrolled.
func TableSetupScrollFreeze(cols int32, rows int32) {
	C.igTableSetupScrollFreeze(C.int(cols), C.int(rows))
}

func InternalTableSortSpecsBuild(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableSortSpecsBuild(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableSortSpecsSanitize(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableSortSpecsSanitize(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableUpdateBorders(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableUpdateBorders(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableUpdateColumnsWeightFromWidth(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableUpdateColumnsWeightFromWidth(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTableUpdateLayout(table *Table) {
	tableArg, tableFin := table.Handle()
	C.igTableUpdateLayout(internal.ReinterpretCast[*C.ImGuiTable](tableArg))

	tableFin()
}

func InternalTeleportMousePos(pos Vec2) {
	C.igTeleportMousePos(internal.ReinterpretCast[C.ImVec2](pos.ToC()))
}

func InternalTempInputIsActive(id ID) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.igTempInputIsActive(internal.ReinterpretCast[C.ImGuiID](idArg)) == C.bool(true)
}

// InternalTempInputScalarV parameter default value hint:
// p_clamp_min: NULL
// p_clamp_max: NULL
func InternalTempInputScalarV(bb Rect, id ID, label string, data_type DataType, p_data uintptr, format string, p_clamp_min uintptr, p_clamp_max uintptr) bool {
	idArg, idFin := id.C()
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		idFin()
		labelFin()
		formatFin()
	}()
	return C.wrap_igTempInputScalarV(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), formatArg, C.uintptr_t(p_clamp_min), C.uintptr_t(p_clamp_max)) == C.bool(true)
}

func InternalTempInputText(bb Rect, id ID, label string, buf string, buf_size int32, flags InputTextFlags) bool {
	idArg, idFin := id.C()
	labelArg, labelFin := internal.WrapString[C.char](label)
	bufArg, bufFin := internal.WrapString[C.char](buf)

	defer func() {
		idFin()
		labelFin()
		bufFin()
	}()
	return C.igTempInputText(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), labelArg, bufArg, C.int(buf_size), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

// Test that key is either not owned, either owned by 'owner_id'
func InternalTestKeyOwner(key Key, owner_id ID) bool {
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		owner_idFin()
	}()
	return C.igTestKeyOwner(C.ImGuiKey(key), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

func InternalTestShortcutRouting(key_chord KeyChord, owner_id ID) bool {
	key_chordArg, key_chordFin := key_chord.C()
	owner_idArg, owner_idFin := owner_id.C()

	defer func() {
		key_chordFin()
		owner_idFin()
	}()
	return C.igTestShortcutRouting(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg), internal.ReinterpretCast[C.ImGuiID](owner_idArg)) == C.bool(true)
}

// formatted text
func Text(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igText(fmtArg)

	fmtFin()
}

// shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
func TextColored(col Vec4, fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igTextColored(internal.ReinterpretCast[C.ImVec4](col.ToC()), fmtArg)

	fmtFin()
}

// shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
func TextDisabled(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igTextDisabled(fmtArg)

	fmtFin()
}

// InternalTextExV parameter default value hint:
// flags: 0
func InternalTextExV(text string, flags TextFlags) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igTextExV(textArg, C.int(len(text)), C.ImGuiTextFlags(flags))

	textFin()
}

// hyperlink text button, return true when clicked
func TextLink(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igTextLink(labelArg) == C.bool(true)
}

// hyperlink text button, automatically open file/url when clicked
// TextLinkOpenURLV parameter default value hint:
// url: NULL
func TextLinkOpenURLV(label string, url string) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	urlArg, urlFin := internal.WrapString[C.char](url)
	C.igTextLinkOpenURL(labelArg, urlArg)

	labelFin()
	urlFin()
}

// raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
// TextUnformattedV parameter default value hint:
func TextUnformattedV(text string) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igTextUnformattedV(textArg, C.int(len(text)))

	textFin()
}

// shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
func TextWrapped(fmt string) {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)
	C.wrap_igTextWrapped(fmtArg)

	fmtFin()
}

func InternalTranslateWindowsInViewport(viewport *ViewportP, old_pos Vec2, new_pos Vec2, old_size Vec2, new_size Vec2) {
	viewportArg, viewportFin := viewport.Handle()
	C.igTranslateWindowsInViewport(internal.ReinterpretCast[*C.ImGuiViewportP](viewportArg), internal.ReinterpretCast[C.ImVec2](old_pos.ToC()), internal.ReinterpretCast[C.ImVec2](new_pos.ToC()), internal.ReinterpretCast[C.ImVec2](old_size.ToC()), internal.ReinterpretCast[C.ImVec2](new_size.ToC()))

	viewportFin()
}

// InternalTreeNodeBehaviorV parameter default value hint:
// label_end: NULL
func InternalTreeNodeBehaviorV(id ID, flags TreeNodeFlags, label string, label_end string) bool {
	idArg, idFin := id.C()
	labelArg, labelFin := internal.WrapString[C.char](label)
	label_endArg, label_endFin := internal.WrapString[C.char](label_end)

	defer func() {
		idFin()
		labelFin()
		label_endFin()
	}()
	return C.igTreeNodeBehavior(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiTreeNodeFlags(flags), labelArg, label_endArg) == C.bool(true)
}

func TreeNodeExPtr(ptr_id uintptr, flags TreeNodeFlags, fmt string) bool {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)

	defer func() {
		fmtFin()
	}()
	return C.wrap_igTreeNodeEx_Ptr(C.uintptr_t(ptr_id), C.ImGuiTreeNodeFlags(flags), fmtArg) == C.bool(true)
}

// TreeNodeExStrV parameter default value hint:
// flags: 0
func TreeNodeExStrV(label string, flags TreeNodeFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igTreeNodeEx_Str(labelArg, C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

func TreeNodeExStrStr(str_id string, flags TreeNodeFlags, fmt string) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)

	defer func() {
		str_idFin()
		fmtFin()
	}()
	return C.wrap_igTreeNodeEx_StrStr(str_idArg, C.ImGuiTreeNodeFlags(flags), fmtArg) == C.bool(true)
}

func InternalTreeNodeGetOpen(storage_id ID) bool {
	storage_idArg, storage_idFin := storage_id.C()

	defer func() {
		storage_idFin()
	}()
	return C.igTreeNodeGetOpen(internal.ReinterpretCast[C.ImGuiID](storage_idArg)) == C.bool(true)
}

func InternalTreeNodeSetOpen(storage_id ID, open bool) {
	storage_idArg, storage_idFin := storage_id.C()
	C.igTreeNodeSetOpen(internal.ReinterpretCast[C.ImGuiID](storage_idArg), C.bool(open))

	storage_idFin()
}

// Return open state. Consume previous SetNextItemOpen() data, if any. May return true when logging.
func InternalTreeNodeUpdateNextOpen(storage_id ID, flags TreeNodeFlags) bool {
	storage_idArg, storage_idFin := storage_id.C()

	defer func() {
		storage_idFin()
	}()
	return C.igTreeNodeUpdateNextOpen(internal.ReinterpretCast[C.ImGuiID](storage_idArg), C.ImGuiTreeNodeFlags(flags)) == C.bool(true)
}

// "
func TreeNodePtr(ptr_id uintptr, fmt string) bool {
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)

	defer func() {
		fmtFin()
	}()
	return C.wrap_igTreeNode_Ptr(C.uintptr_t(ptr_id), fmtArg) == C.bool(true)
}

func TreeNodeStr(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.igTreeNode_Str(labelArg) == C.bool(true)
}

// helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
func TreeNodeStrStr(str_id string, fmt string) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	fmtArg, fmtFin := internal.WrapString[C.char](fmt)

	defer func() {
		str_idFin()
		fmtFin()
	}()
	return C.wrap_igTreeNode_StrStr(str_idArg, fmtArg) == C.bool(true)
}

// ~ Unindent()+PopID()
func TreePop() {
	C.igTreePop()
}

func InternalTreePushOverrideID(id ID) {
	idArg, idFin := id.C()
	C.igTreePushOverrideID(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

// "
func TreePushPtr(ptr_id uintptr) {
	C.wrap_igTreePush_Ptr(C.uintptr_t(ptr_id))
}

// ~ Indent()+PushID(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired.
func TreePushStr(str_id string) {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	C.igTreePush_Str(str_idArg)

	str_idFin()
}

// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0
// UnindentV parameter default value hint:
// indent_w: 0.0f
func UnindentV(indent_w float32) {
	C.igUnindent(C.float(indent_w))
}

func InternalUpdateHoveredWindowAndCaptureFlags() {
	C.igUpdateHoveredWindowAndCaptureFlags()
}

func InternalUpdateInputEvents(trickle_fast_inputs bool) {
	C.igUpdateInputEvents(C.bool(trickle_fast_inputs))
}

func InternalUpdateMouseMovingWindowEndFrame() {
	C.igUpdateMouseMovingWindowEndFrame()
}

func InternalUpdateMouseMovingWindowNewFrame() {
	C.igUpdateMouseMovingWindowNewFrame()
}

// call in main loop. will call CreateWindow/ResizeWindow/etc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.
func UpdatePlatformWindows() {
	C.igUpdatePlatformWindows()
}

func InternalUpdateWindowParentAndRootLinks(window *Window, flags WindowFlags, parent_window *Window) {
	windowArg, windowFin := window.Handle()
	parent_windowArg, parent_windowFin := parent_window.Handle()
	C.igUpdateWindowParentAndRootLinks(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.ImGuiWindowFlags(flags), internal.ReinterpretCast[*C.ImGuiWindow](parent_windowArg))

	windowFin()
	parent_windowFin()
}

func InternalUpdateWindowSkipRefresh(window *Window) {
	windowArg, windowFin := window.Handle()
	C.igUpdateWindowSkipRefresh(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

// VSliderFloatV parameter default value hint:
// format: "%.3f"
// flags: 0
func VSliderFloatV(label string, size Vec2, v *float32, v_min float32, v_max float32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igVSliderFloat(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), vArg, C.float(v_min), C.float(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// VSliderIntV parameter default value hint:
// format: "%d"
// flags: 0
func VSliderIntV(label string, size Vec2, v *int32, v_min int32, v_max int32, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		vFin()
		formatFin()
	}()
	return C.igVSliderInt(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), vArg, C.int(v_min), C.int(v_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

// VSliderScalarV parameter default value hint:
// format: NULL
// flags: 0
func VSliderScalarV(label string, size Vec2, data_type DataType, p_data uintptr, p_min uintptr, p_max uintptr, format string, flags SliderFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		labelFin()
		formatFin()
	}()
	return C.wrap_igVSliderScalarV(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.uintptr_t(p_min), C.uintptr_t(p_max), formatArg, C.ImGuiSliderFlags(flags)) == C.bool(true)
}

func ValueBool(prefix string, b bool) {
	prefixArg, prefixFin := internal.WrapString[C.char](prefix)
	C.igValue_Bool(prefixArg, C.bool(b))

	prefixFin()
}

// ValueFloatV parameter default value hint:
// float_format: NULL
func ValueFloatV(prefix string, v float32, float_format string) {
	prefixArg, prefixFin := internal.WrapString[C.char](prefix)
	float_formatArg, float_formatFin := internal.WrapString[C.char](float_format)
	C.igValue_Float(prefixArg, C.float(v), float_formatArg)

	prefixFin()
	float_formatFin()
}

func ValueInt(prefix string, v int32) {
	prefixArg, prefixFin := internal.WrapString[C.char](prefix)
	C.igValue_Int(prefixArg, C.int(v))

	prefixFin()
}

func ValueUint(prefix string, v uint32) {
	prefixArg, prefixFin := internal.WrapString[C.char](prefix)
	C.igValue_Uint(prefixArg, C.uint(v))

	prefixFin()
}

func InternalWindowPosAbsToRel(window *Window, p Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igWindowPosAbsToRel(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImVec2](p.ToC()))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalWindowPosRelToAbs(window *Window, p Vec2) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igWindowPosRelToAbs(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImVec2](p.ToC()))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalWindowRectAbsToRel(window *Window, r Rect) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igWindowRectAbsToRel(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](r.ToC()))

	pOutFin()
	windowFin()

	return *pOut
}

func InternalWindowRectRelToAbs(window *Window, r Rect) Rect {
	pOut := new(Rect)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.igWindowRectRelToAbs(internal.ReinterpretCast[*C.ImRect](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](r.ToC()))

	pOutFin()
	windowFin()

	return *pOut
}

func ColorHSV(h float32, s float32, v float32) Color {
	pOut := new(Color)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.wrap_ImColor_HSV(internal.ReinterpretCast[*C.ImColor](pOutArg), C.float(h), C.float(s), C.float(v))

	pOutFin()

	return *pOut
}

func (self *Color) SetHSV(h float32, s float32, v float32) {
	selfArg, selfFin := internal.Wrap(self)
	C.wrap_ImColor_SetHSV(internal.ReinterpretCast[*C.ImColor](selfArg), C.float(h), C.float(s), C.float(v))

	selfFin()
}

func (self *DrawList) AddBezierCubic(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddBezierCubic(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddBezierQuadratic(p1 Vec2, p2 Vec2, p3 Vec2, col uint32, thickness float32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddBezierQuadratic(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), C.ImU32(col), C.float(thickness))

	selfFin()
}

func (self *DrawList) AddCallback(callback DrawCallback, userdata uintptr) {
	selfArg, selfFin := self.Handle()
	callbackArg, callbackFin := callback.C()
	C.wrap_ImDrawList_AddCallback(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImDrawCallback](callbackArg), C.uintptr_t(userdata))

	selfFin()
	callbackFin()
}

func (self *DrawList) AddCircle(center Vec2, radius float32, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddCircle(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddCircleFilled(center Vec2, radius float32, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddCircleFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddEllipse(center Vec2, radius Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddEllipse(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), internal.ReinterpretCast[C.ImVec2](radius.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddEllipseFilled(center Vec2, radius Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddEllipseFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), internal.ReinterpretCast[C.ImVec2](radius.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddImage(user_texture_id TextureID, p_min Vec2, p_max Vec2) {
	selfArg, selfFin := self.Handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.wrap_ImDrawList_AddImage(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()))

	selfFin()
	user_texture_idFin()
}

func (self *DrawList) AddImageQuad(user_texture_id TextureID, p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2) {
	selfArg, selfFin := self.Handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.wrap_ImDrawList_AddImageQuad(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()))

	selfFin()
	user_texture_idFin()
}

func (self *DrawList) AddImageRounded(user_texture_id TextureID, p_min Vec2, p_max Vec2, uv_min Vec2, uv_max Vec2, col uint32, rounding float32) {
	selfArg, selfFin := self.Handle()
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.wrap_ImDrawList_AddImageRounded(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), internal.ReinterpretCast[C.ImVec2](uv_min.ToC()), internal.ReinterpretCast[C.ImVec2](uv_max.ToC()), C.ImU32(col), C.float(rounding))

	selfFin()
	user_texture_idFin()
}

func (self *DrawList) AddLine(p1 Vec2, p2 Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddLine(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddNgon(center Vec2, radius float32, col uint32, num_segments int32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddNgon(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.ImU32(col), C.int(num_segments))

	selfFin()
}

func (self *DrawList) AddQuad(p1 Vec2, p2 Vec2, p3 Vec2, p4 Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddQuad(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddRect(p_min Vec2, p_max Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddRect(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddRectFilled(p_min Vec2, p_max Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddRectFilled(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) AddTextFontPtr(font *Font, font_size float32, pos Vec2, col uint32, text_begin string) {
	selfArg, selfFin := self.Handle()
	fontArg, fontFin := font.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	C.wrap_ImDrawList_AddText_FontPtr(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[*C.ImFont](fontArg), C.float(font_size), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), text_beginArg)

	selfFin()
	fontFin()
	text_beginFin()
}

func (self *DrawList) AddTextVec2(pos Vec2, col uint32, text_begin string) {
	selfArg, selfFin := self.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	C.wrap_ImDrawList_AddText_Vec2(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), text_beginArg)

	selfFin()
	text_beginFin()
}

func (self *DrawList) AddTriangle(p1 Vec2, p2 Vec2, p3 Vec2, col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_AddTriangle(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p1.ToC()), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PathArcTo(center Vec2, radius float32, a_min float32, a_max float32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_PathArcTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), C.float(radius), C.float(a_min), C.float(a_max))

	selfFin()
}

func (self *DrawList) PathBezierCubicCurveTo(p2 Vec2, p3 Vec2, p4 Vec2) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_PathBezierCubicCurveTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()), internal.ReinterpretCast[C.ImVec2](p4.ToC()))

	selfFin()
}

func (self *DrawList) PathBezierQuadraticCurveTo(p2 Vec2, p3 Vec2) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_PathBezierQuadraticCurveTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](p2.ToC()), internal.ReinterpretCast[C.ImVec2](p3.ToC()))

	selfFin()
}

func (self *DrawList) PathEllipticalArcTo(center Vec2, radius Vec2, rot float32, a_min float32, a_max float32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_PathEllipticalArcTo(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](center.ToC()), internal.ReinterpretCast[C.ImVec2](radius.ToC()), C.float(rot), C.float(a_min), C.float(a_max))

	selfFin()
}

func (self *DrawList) PathRect(rect_min Vec2, rect_max Vec2) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_PathRect(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](rect_min.ToC()), internal.ReinterpretCast[C.ImVec2](rect_max.ToC()))

	selfFin()
}

func (self *DrawList) PathStroke(col uint32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_PathStroke(internal.ReinterpretCast[*C.ImDrawList](selfArg), C.ImU32(col))

	selfFin()
}

func (self *DrawList) PushClipRect(clip_rect_min Vec2, clip_rect_max Vec2) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImDrawList_PushClipRect(internal.ReinterpretCast[*C.ImDrawList](selfArg), internal.ReinterpretCast[C.ImVec2](clip_rect_min.ToC()), internal.ReinterpretCast[C.ImVec2](clip_rect_max.ToC()))

	selfFin()
}

func (self *FontAtlas) AddCustomRectFontGlyph(font *Font, id Wchar, width int32, height int32, advance_x float32) int32 {
	selfArg, selfFin := self.Handle()
	fontArg, fontFin := font.Handle()

	defer func() {
		selfFin()
		fontFin()
	}()
	return int32(C.wrap_ImFontAtlas_AddCustomRectFontGlyph(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), internal.ReinterpretCast[*C.ImFont](fontArg), C.ImWchar(id), C.int(width), C.int(height), C.float(advance_x)))
}

func (self *FontAtlas) AddFontDefault() *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlas_AddFontDefault(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

func (self *FontAtlas) AddFontFromFileTTF(filename string, size_pixels float32) *Font {
	selfArg, selfFin := self.Handle()
	filenameArg, filenameFin := internal.WrapString[C.char](filename)

	defer func() {
		selfFin()
		filenameFin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlas_AddFontFromFileTTF(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), filenameArg, C.float(size_pixels)))
}

func (self *FontAtlas) AddFontFromMemoryCompressedBase85TTF(compressed_font_data_base85 string, size_pixels float32) *Font {
	selfArg, selfFin := self.Handle()
	compressed_font_data_base85Arg, compressed_font_data_base85Fin := internal.WrapString[C.char](compressed_font_data_base85)

	defer func() {
		selfFin()
		compressed_font_data_base85Fin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), compressed_font_data_base85Arg, C.float(size_pixels)))
}

func (self *FontAtlas) AddFontFromMemoryCompressedTTF(compressed_font_data uintptr, compressed_font_data_size int32, size_pixels float32) *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryCompressedTTF(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), C.uintptr_t(compressed_font_data), C.int(compressed_font_data_size), C.float(size_pixels)))
}

func (self *FontAtlas) AddFontFromMemoryTTF(font_data uintptr, font_data_size int32, size_pixels float32) *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlas_AddFontFromMemoryTTF(internal.ReinterpretCast[*C.ImFontAtlas](selfArg), C.uintptr_t(font_data), C.int(font_data_size), C.float(size_pixels)))
}

func (self *FontGlyphRangesBuilder) AddText(text string) {
	selfArg, selfFin := self.Handle()
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_ImFontGlyphRangesBuilder_AddText(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg), textArg, C.int(len(text)))

	selfFin()
	textFin()
}

func (self *Font) AddRemapChar(dst Wchar, src Wchar) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImFont_AddRemapChar(internal.ReinterpretCast[*C.ImFont](selfArg), C.ImWchar(dst), C.ImWchar(src))

	selfFin()
}

func (self *Font) CalcTextSizeA(size float32, max_width float32, wrap_width float32, text_begin string) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	selfArg, selfFin := self.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	C.wrap_ImFont_CalcTextSizeA(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImFont](selfArg), C.float(size), C.float(max_width), C.float(wrap_width), text_beginArg)

	pOutFin()
	selfFin()
	text_beginFin()

	return *pOut
}

func (self *Font) RenderText(draw_list *DrawList, size float32, pos Vec2, col uint32, clip_rect Vec4, text_begin string) {
	selfArg, selfFin := self.Handle()
	draw_listArg, draw_listFin := draw_list.Handle()
	text_beginArg, text_beginFin := internal.WrapString[C.char](text_begin)
	C.wrap_ImFont_RenderText(internal.ReinterpretCast[*C.ImFont](selfArg), internal.ReinterpretCast[*C.ImDrawList](draw_listArg), C.float(size), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), internal.ReinterpretCast[C.ImVec4](clip_rect.ToC()), text_beginArg)

	selfFin()
	draw_listFin()
	text_beginFin()
}

func (self *IO) SetKeyEventNativeData(key Key, native_keycode int32, native_scancode int32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImGuiIO_SetKeyEventNativeData(internal.ReinterpretCast[*C.ImGuiIO](selfArg), C.ImGuiKey(key), C.int(native_keycode), C.int(native_scancode))

	selfFin()
}

func (self *InputTextCallbackData) InsertChars(pos int32, text string) {
	selfArg, selfFin := self.Handle()
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_ImGuiInputTextCallbackData_InsertChars(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg), C.int(pos), textArg, C.int(len(text)))

	selfFin()
	textFin()
}

func (self *ListClipper) Begin(items_count int32) {
	selfArg, selfFin := self.Handle()
	C.wrap_ImGuiListClipper_Begin(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg), C.int(items_count))

	selfFin()
}

func (self *Storage) Bool(key ID) bool {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return C.wrap_ImGuiStorage_GetBool(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg)) == C.bool(true)
}

func (self *Storage) BoolRef(key ID) *bool {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*bool)(C.wrap_ImGuiStorage_GetBoolRef(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg)))
}

func (self *Storage) Float(key ID) float32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return float32(C.wrap_ImGuiStorage_GetFloat(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg)))
}

func (self *Storage) FloatRef(key ID) *float32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*float32)(C.wrap_ImGuiStorage_GetFloatRef(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg)))
}

func (self *Storage) Int(key ID) int32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return int32(C.wrap_ImGuiStorage_GetInt(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg)))
}

func (self *Storage) IntRef(key ID) *int32 {
	selfArg, selfFin := self.Handle()
	keyArg, keyFin := key.C()

	defer func() {
		selfFin()
		keyFin()
	}()
	return (*int32)(C.wrap_ImGuiStorage_GetIntRef(internal.ReinterpretCast[*C.ImGuiStorage](selfArg), internal.ReinterpretCast[C.ImGuiID](keyArg)))
}

func (self *TextBuffer) Append(str string) {
	selfArg, selfFin := self.Handle()
	strArg, strFin := internal.WrapString[C.char](str)
	C.wrap_ImGuiTextBuffer_Append(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg), strArg)

	selfFin()
	strFin()
}

func (self *TextFilter) Draw() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTextFilter_Draw(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg)) == C.bool(true)
}

func (self *TextFilter) PassFilter(text string) bool {
	selfArg, selfFin := self.Handle()
	textArg, textFin := internal.WrapString[C.char](text)

	defer func() {
		selfFin()
		textFin()
	}()
	return C.wrap_ImGuiTextFilter_PassFilter(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg), textArg, C.int(len(text))) == C.bool(true)
}

func (self *Window) InternalIDStr(str string) ID {
	selfArg, selfFin := self.Handle()
	strArg, strFin := internal.WrapString[C.char](str)

	defer func() {
		selfFin()
		strFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetID_Str(internal.ReinterpretCast[*C.ImGuiWindow](selfArg), strArg)
		return &result
	}())
}

func AcceptDragDropPayload(typeArg string) *Payload {
	typeArgArg, typeArgFin := internal.WrapString[C.char](typeArg)

	defer func() {
		typeArgFin()
	}()
	return NewPayloadFromC(C.wrap_igAcceptDragDropPayload(typeArgArg))
}

func InternalArrowButtonEx(str_id string, dir Dir, size_arg Vec2) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igArrowButtonEx(str_idArg, C.ImGuiDir(dir), internal.ReinterpretCast[C.ImVec2](size_arg.ToC())) == C.bool(true)
}

func Begin(name string) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)

	defer func() {
		nameFin()
	}()
	return C.wrap_igBegin(nameArg) == C.bool(true)
}

func BeginChildID(id ID) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.wrap_igBeginChild_ID(internal.ReinterpretCast[C.ImGuiID](idArg)) == C.bool(true)
}

func BeginChildStr(str_id string) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginChild_Str(str_idArg) == C.bool(true)
}

func InternalBeginColumns(str_id string, count int32) {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	C.wrap_igBeginColumns(str_idArg, C.int(count))

	str_idFin()
}

func BeginCombo(label string, preview_value string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	preview_valueArg, preview_valueFin := internal.WrapString[C.char](preview_value)

	defer func() {
		labelFin()
		preview_valueFin()
	}()
	return C.wrap_igBeginCombo(labelArg, preview_valueArg) == C.bool(true)
}

func BeginDisabled() {
	C.wrap_igBeginDisabled()
}

func BeginDragDropSource() bool {
	return C.wrap_igBeginDragDropSource() == C.bool(true)
}

func BeginListBox(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igBeginListBox(labelArg) == C.bool(true)
}

func BeginMenu(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igBeginMenu(labelArg) == C.bool(true)
}

func InternalBeginMenuEx(label string, icon string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	iconArg, iconFin := internal.WrapString[C.char](icon)

	defer func() {
		labelFin()
		iconFin()
	}()
	return C.wrap_igBeginMenuEx(labelArg, iconArg) == C.bool(true)
}

func BeginMultiSelect(flags MultiSelectFlags) *MultiSelectIO {
	return NewMultiSelectIOFromC(C.wrap_igBeginMultiSelect(C.ImGuiMultiSelectFlags(flags)))
}

func BeginPopup(str_id string) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginPopup(str_idArg) == C.bool(true)
}

func BeginPopupContextItem() bool {
	return C.wrap_igBeginPopupContextItem() == C.bool(true)
}

func BeginPopupContextVoid() bool {
	return C.wrap_igBeginPopupContextVoid() == C.bool(true)
}

func BeginPopupContextWindow() bool {
	return C.wrap_igBeginPopupContextWindow() == C.bool(true)
}

func BeginPopupModal(name string) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)

	defer func() {
		nameFin()
	}()
	return C.wrap_igBeginPopupModal(nameArg) == C.bool(true)
}

func BeginTabBar(str_id string) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginTabBar(str_idArg) == C.bool(true)
}

func BeginTabItem(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igBeginTabItem(labelArg) == C.bool(true)
}

func BeginTable(str_id string, columns int32) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igBeginTable(str_idArg, C.int(columns)) == C.bool(true)
}

func InternalBeginTableEx(name string, id ID, columns_count int32) bool {
	nameArg, nameFin := internal.WrapString[C.char](name)
	idArg, idFin := id.C()

	defer func() {
		nameFin()
		idFin()
	}()
	return C.wrap_igBeginTableEx(nameArg, internal.ReinterpretCast[C.ImGuiID](idArg), C.int(columns_count)) == C.bool(true)
}

func Button(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igButton(labelArg) == C.bool(true)
}

func InternalButtonBehavior(bb Rect, id ID, out_hovered *bool, out_held *bool) bool {
	idArg, idFin := id.C()
	out_hoveredArg, out_hoveredFin := internal.WrapNumberPtr[C.bool, bool](out_hovered)
	out_heldArg, out_heldFin := internal.WrapNumberPtr[C.bool, bool](out_held)

	defer func() {
		idFin()
		out_hoveredFin()
		out_heldFin()
	}()
	return C.wrap_igButtonBehavior(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), out_hoveredArg, out_heldArg) == C.bool(true)
}

func InternalButtonEx(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igButtonEx(labelArg) == C.bool(true)
}

func CalcTextSize(text string) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igCalcTextSize(internal.ReinterpretCast[*C.ImVec2](pOutArg), textArg, C.int(len(text)))

	pOutFin()
	textFin()

	return *pOut
}

func CollapsingHeaderBoolPtr(label string, p_visible *bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	p_visibleArg, p_visibleFin := internal.WrapNumberPtr[C.bool, bool](p_visible)

	defer func() {
		labelFin()
		p_visibleFin()
	}()
	return C.wrap_igCollapsingHeader_BoolPtr(labelArg, p_visibleArg) == C.bool(true)
}

func CollapsingHeaderTreeNodeFlags(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igCollapsingHeader_TreeNodeFlags(labelArg) == C.bool(true)
}

func ColorButton(desc_id string, col Vec4) bool {
	desc_idArg, desc_idFin := internal.WrapString[C.char](desc_id)

	defer func() {
		desc_idFin()
	}()
	return C.wrap_igColorButton(desc_idArg, internal.ReinterpretCast[C.ImVec4](col.ToC())) == C.bool(true)
}

func ColorEdit3(label string, col *[3]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorEdit3(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func ColorEdit4(label string, col *[4]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorEdit4(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func ColorPicker3(label string, col *[3]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorPicker3(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func ColorPicker4(label string, col *[4]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	colArg := make([]C.float, len(col))
	for i, colV := range col {
		colArg[i] = C.float(colV)
	}

	defer func() {
		labelFin()

		for i, colV := range colArg {
			(*col)[i] = float32(colV)
		}
	}()
	return C.wrap_igColorPicker4(labelArg, (*C.float)(&colArg[0])) == C.bool(true)
}

func Columns() {
	C.wrap_igColumns()
}

func ComboStr(label string, current_item *int32, items_separated_by_zeros string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	current_itemArg, current_itemFin := internal.WrapNumberPtr[C.int, int32](current_item)
	items_separated_by_zerosArg, items_separated_by_zerosFin := internal.WrapString[C.char](items_separated_by_zeros)

	defer func() {
		labelFin()
		current_itemFin()
		items_separated_by_zerosFin()
	}()
	return C.wrap_igCombo_Str(labelArg, current_itemArg, items_separated_by_zerosArg) == C.bool(true)
}

func ComboStrarr(label string, current_item *int32, items []string, items_count int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	current_itemArg, current_itemFin := internal.WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := internal.WrapStringList[C.char](items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.wrap_igCombo_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count)) == C.bool(true)
}

func CreateContext() *Context {
	return NewContextFromC(C.wrap_igCreateContext())
}

func InternalDataTypeApplyFromText(buf string, data_type DataType, p_data uintptr, format string) bool {
	bufArg, bufFin := internal.WrapString[C.char](buf)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		bufFin()
		formatFin()
	}()
	return C.wrap_igDataTypeApplyFromText(bufArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), formatArg) == C.bool(true)
}

func InternalDebugDrawCursorPos() {
	C.wrap_igDebugDrawCursorPos()
}

func InternalDebugDrawItemRect() {
	C.wrap_igDebugDrawItemRect()
}

func InternalDebugDrawLineExtents() {
	C.wrap_igDebugDrawLineExtents()
}

func DestroyContext() {
	C.wrap_igDestroyContext()
}

func InternalDockBuilderAddNode() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.wrap_igDockBuilderAddNode(); return &result }())
}

func InternalDockBuilderRemoveNodeDockedWindows(node_id ID) {
	node_idArg, node_idFin := node_id.C()
	C.wrap_igDockBuilderRemoveNodeDockedWindows(internal.ReinterpretCast[C.ImGuiID](node_idArg))

	node_idFin()
}

func InternalDockContextProcessUndockWindow(ctx *Context, window *Window) {
	ctxArg, ctxFin := ctx.Handle()
	windowArg, windowFin := window.Handle()
	C.wrap_igDockContextProcessUndockWindow(internal.ReinterpretCast[*C.ImGuiContext](ctxArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	ctxFin()
	windowFin()
}

func DockSpace(dockspace_id ID) ID {
	dockspace_idArg, dockspace_idFin := dockspace_id.C()

	defer func() {
		dockspace_idFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_igDockSpace(internal.ReinterpretCast[C.ImGuiID](dockspace_idArg))
		return &result
	}())
}

func DockSpaceOverViewport() ID {
	return *NewIDFromC(func() *C.ImGuiID { result := C.wrap_igDockSpaceOverViewport(); return &result }())
}

func DragFloat(label string, v *float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igDragFloat(labelArg, vArg) == C.bool(true)
}

func DragFloat2(label string, v *[2]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igDragFloat2(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func DragFloat3(label string, v *[3]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igDragFloat3(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func DragFloat4(label string, v *[4]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igDragFloat4(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func DragFloatRange2(label string, v_current_min *float32, v_current_max *float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	v_current_minArg, v_current_minFin := internal.WrapNumberPtr[C.float, float32](v_current_min)
	v_current_maxArg, v_current_maxFin := internal.WrapNumberPtr[C.float, float32](v_current_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
	}()
	return C.wrap_igDragFloatRange2(labelArg, v_current_minArg, v_current_maxArg) == C.bool(true)
}

func DragInt(label string, v *int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igDragInt(labelArg, vArg) == C.bool(true)
}

func DragInt2(label string, v *[2]int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igDragInt2(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func DragInt3(label string, v *[3]int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igDragInt3(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func DragInt4(label string, v *[4]int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igDragInt4(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func DragIntRange2(label string, v_current_min *int32, v_current_max *int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	v_current_minArg, v_current_minFin := internal.WrapNumberPtr[C.int, int32](v_current_min)
	v_current_maxArg, v_current_maxFin := internal.WrapNumberPtr[C.int, int32](v_current_max)

	defer func() {
		labelFin()
		v_current_minFin()
		v_current_maxFin()
	}()
	return C.wrap_igDragIntRange2(labelArg, v_current_minArg, v_current_maxArg) == C.bool(true)
}

func DragScalar(label string, data_type DataType, p_data uintptr) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igDragScalar(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data)) == C.bool(true)
}

func DragScalarN(label string, data_type DataType, p_data uintptr, components int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igDragScalarN(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.int(components)) == C.bool(true)
}

func InternalFindRenderedTextEnd(text string) string {
	textArg, textFin := internal.WrapString[C.char](text)

	defer func() {
		textFin()
	}()
	return func() string {
		result := C.wrap_igFindRenderedTextEnd(textArg, C.int(len(text)))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalFocusWindow(window *Window) {
	windowArg, windowFin := window.Handle()
	C.wrap_igFocusWindow(internal.ReinterpretCast[*C.ImGuiWindow](windowArg))

	windowFin()
}

func BackgroundDrawList() *DrawList {
	return NewDrawListFromC(C.wrap_igGetBackgroundDrawList())
}

func ColorU32Col(idx Col) uint32 {
	return uint32(C.wrap_igGetColorU32_Col(C.ImGuiCol(idx)))
}

func ColorU32U32(col uint32) uint32 {
	return uint32(C.wrap_igGetColorU32_U32(C.ImU32(col)))
}

func ColumnOffset() float32 {
	return float32(C.wrap_igGetColumnOffset())
}

func ColumnWidth() float32 {
	return float32(C.wrap_igGetColumnWidth())
}

func ForegroundDrawListViewportPtr() *DrawList {
	return NewDrawListFromC(C.wrap_igGetForegroundDrawList_ViewportPtr())
}

func MouseDragDelta() Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	C.wrap_igGetMouseDragDelta(internal.ReinterpretCast[*C.ImVec2](pOutArg))

	pOutFin()

	return *pOut
}

func InternalTypingSelectRequest() *TypingSelectRequest {
	return NewTypingSelectRequestFromC(C.wrap_igGetTypingSelectRequest())
}

func InternalImFileLoadToMemory(filename string, mode string) uintptr {
	filenameArg, filenameFin := internal.WrapString[C.char](filename)
	modeArg, modeFin := internal.WrapString[C.char](mode)

	defer func() {
		filenameFin()
		modeFin()
	}()
	return uintptr(C.wrap_igImFileLoadToMemory(filenameArg, modeArg))
}

func InternalImHashData(data uintptr, data_size uint64) ID {
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_igImHashData(C.uintptr_t(data), C.xulong(data_size))
		return &result
	}())
}

func InternalImHashStr(data string) ID {
	dataArg, dataFin := internal.WrapString[C.char](data)

	defer func() {
		dataFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID { result := C.wrap_igImHashStr(dataArg); return &result }())
}

func InternalImTextStrFromUtf8(out_buf *Wchar, out_buf_size int32, in_text string, in_text_end string) int32 {
	in_textArg, in_textFin := internal.WrapString[C.char](in_text)
	in_text_endArg, in_text_endFin := internal.WrapString[C.char](in_text_end)

	defer func() {
		in_textFin()
		in_text_endFin()
	}()
	return int32(C.wrap_igImTextStrFromUtf8((*C.ImWchar)(out_buf), C.int(out_buf_size), in_textArg, in_text_endArg))
}

func Image(user_texture_id TextureID, image_size Vec2) {
	user_texture_idArg, user_texture_idFin := user_texture_id.C()
	C.wrap_igImage(internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](image_size.ToC()))

	user_texture_idFin()
}

func ImageButton(str_id string, user_texture_id TextureID, image_size Vec2) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	user_texture_idArg, user_texture_idFin := user_texture_id.C()

	defer func() {
		str_idFin()
		user_texture_idFin()
	}()
	return C.wrap_igImageButton(str_idArg, internal.ReinterpretCast[C.ImTextureID](user_texture_idArg), internal.ReinterpretCast[C.ImVec2](image_size.ToC())) == C.bool(true)
}

func InternalImageButtonEx(id ID, texture_id TextureID, image_size Vec2, uv0 Vec2, uv1 Vec2, bg_col Vec4, tint_col Vec4) bool {
	idArg, idFin := id.C()
	texture_idArg, texture_idFin := texture_id.C()

	defer func() {
		idFin()
		texture_idFin()
	}()
	return C.wrap_igImageButtonEx(internal.ReinterpretCast[C.ImGuiID](idArg), internal.ReinterpretCast[C.ImTextureID](texture_idArg), internal.ReinterpretCast[C.ImVec2](image_size.ToC()), internal.ReinterpretCast[C.ImVec2](uv0.ToC()), internal.ReinterpretCast[C.ImVec2](uv1.ToC()), internal.ReinterpretCast[C.ImVec4](bg_col.ToC()), internal.ReinterpretCast[C.ImVec4](tint_col.ToC())) == C.bool(true)
}

func Indent() {
	C.wrap_igIndent()
}

func InputDouble(label string, v *float64) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.double, float64](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igInputDouble(labelArg, vArg) == C.bool(true)
}

func InputFloat(label string, v *float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igInputFloat(labelArg, vArg) == C.bool(true)
}

func InputFloat2(label string, v *[2]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igInputFloat2(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func InputFloat3(label string, v *[3]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igInputFloat3(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func InputFloat4(label string, v *[4]float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igInputFloat4(labelArg, (*C.float)(&vArg[0])) == C.bool(true)
}

func InputInt(label string, v *int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igInputInt(labelArg, vArg) == C.bool(true)
}

func InputInt2(label string, v *[2]int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igInputInt2(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func InputInt3(label string, v *[3]int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igInputInt3(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func InputInt4(label string, v *[4]int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igInputInt4(labelArg, (*C.int)(&vArg[0])) == C.bool(true)
}

func InputScalar(label string, data_type DataType, p_data uintptr) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igInputScalar(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data)) == C.bool(true)
}

func InputScalarN(label string, data_type DataType, p_data uintptr, components int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igInputScalarN(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.int(components)) == C.bool(true)
}

func InternalInputTextEx(label string, hint string, buf string, buf_size int32, size_arg Vec2, flags InputTextFlags) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	hintArg, hintFin := internal.WrapString[C.char](hint)
	bufArg, bufFin := internal.WrapString[C.char](buf)

	defer func() {
		labelFin()
		hintFin()
		bufFin()
	}()
	return C.wrap_igInputTextEx(labelArg, hintArg, bufArg, C.int(buf_size), internal.ReinterpretCast[C.ImVec2](size_arg.ToC()), C.ImGuiInputTextFlags(flags)) == C.bool(true)
}

func InvisibleButton(str_id string, size Vec2) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igInvisibleButton(str_idArg, internal.ReinterpretCast[C.ImVec2](size.ToC())) == C.bool(true)
}

func IsItemClicked() bool {
	return C.wrap_igIsItemClicked() == C.bool(true)
}

func IsItemHovered() bool {
	return C.wrap_igIsItemHovered() == C.bool(true)
}

func InternalIsKeyChordPressedInputFlags(key_chord KeyChord, flags InputFlags) bool {
	key_chordArg, key_chordFin := key_chord.C()

	defer func() {
		key_chordFin()
	}()
	return C.wrap_igIsKeyChordPressed_InputFlags(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg), C.ImGuiInputFlags(flags)) == C.bool(true)
}

func IsKeyPressedBool(key Key) bool {
	return C.wrap_igIsKeyPressed_Bool(C.ImGuiKey(key)) == C.bool(true)
}

func InternalIsKeyPressedInputFlags(key Key, flags InputFlags) bool {
	return C.wrap_igIsKeyPressed_InputFlags(C.ImGuiKey(key), C.ImGuiInputFlags(flags)) == C.bool(true)
}

func IsMouseClickedBool(button MouseButton) bool {
	return C.wrap_igIsMouseClicked_Bool(C.ImGuiMouseButton(button)) == C.bool(true)
}

func InternalIsMouseClickedInputFlags(button MouseButton, flags InputFlags) bool {
	return C.wrap_igIsMouseClicked_InputFlags(C.ImGuiMouseButton(button), C.ImGuiInputFlags(flags)) == C.bool(true)
}

func InternalIsMouseDragPastThreshold(button MouseButton) bool {
	return C.wrap_igIsMouseDragPastThreshold(C.ImGuiMouseButton(button)) == C.bool(true)
}

func IsMouseDragging(button MouseButton) bool {
	return C.wrap_igIsMouseDragging(C.ImGuiMouseButton(button)) == C.bool(true)
}

func IsMouseHoveringRect(r_min Vec2, r_max Vec2) bool {
	return C.wrap_igIsMouseHoveringRect(internal.ReinterpretCast[C.ImVec2](r_min.ToC()), internal.ReinterpretCast[C.ImVec2](r_max.ToC())) == C.bool(true)
}

func IsMousePosValid() bool {
	return C.wrap_igIsMousePosValid() == C.bool(true)
}

func IsPopupOpenStr(str_id string) bool {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)

	defer func() {
		str_idFin()
	}()
	return C.wrap_igIsPopupOpen_Str(str_idArg) == C.bool(true)
}

func InternalIsWindowContentHoverable(window *Window) bool {
	windowArg, windowFin := window.Handle()

	defer func() {
		windowFin()
	}()
	return C.wrap_igIsWindowContentHoverable(internal.ReinterpretCast[*C.ImGuiWindow](windowArg)) == C.bool(true)
}

func IsWindowFocused() bool {
	return C.wrap_igIsWindowFocused() == C.bool(true)
}

func IsWindowHovered() bool {
	return C.wrap_igIsWindowHovered() == C.bool(true)
}

func InternalItemAdd(bb Rect, id ID) bool {
	idArg, idFin := id.C()

	defer func() {
		idFin()
	}()
	return C.wrap_igItemAdd(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg)) == C.bool(true)
}

func InternalItemSizeRect(bb Rect) {
	C.wrap_igItemSize_Rect(internal.ReinterpretCast[C.ImRect](bb.ToC()))
}

func InternalItemSizeVec2(size Vec2) {
	C.wrap_igItemSize_Vec2(internal.ReinterpretCast[C.ImVec2](size.ToC()))
}

func ListBoxStrarr(label string, current_item *int32, items []string, items_count int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	current_itemArg, current_itemFin := internal.WrapNumberPtr[C.int, int32](current_item)
	itemsArg, itemsFin := internal.WrapStringList[C.char](items)

	defer func() {
		labelFin()
		current_itemFin()
		itemsFin()
	}()
	return C.wrap_igListBox_Str_arr(labelArg, current_itemArg, itemsArg, C.int(items_count)) == C.bool(true)
}

func LoadIniSettingsFromMemory(ini_data string) {
	ini_dataArg, ini_dataFin := internal.WrapString[C.char](ini_data)
	C.wrap_igLoadIniSettingsFromMemory(ini_dataArg)

	ini_dataFin()
}

func InternalLogRenderedText(ref_pos *Vec2, text string) {
	ref_posArg, ref_posFin := internal.Wrap(ref_pos)
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igLogRenderedText(internal.ReinterpretCast[*C.ImVec2](ref_posArg), textArg, C.int(len(text)))

	ref_posFin()
	textFin()
}

func InternalLogToBuffer() {
	C.wrap_igLogToBuffer()
}

func LogToClipboard() {
	C.wrap_igLogToClipboard()
}

func LogToFile() {
	C.wrap_igLogToFile()
}

func LogToTTY() {
	C.wrap_igLogToTTY()
}

func InternalMenuItemEx(label string, icon string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	iconArg, iconFin := internal.WrapString[C.char](icon)

	defer func() {
		labelFin()
		iconFin()
	}()
	return C.wrap_igMenuItemEx(labelArg, iconArg) == C.bool(true)
}

func MenuItemBool(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igMenuItem_Bool(labelArg) == C.bool(true)
}

func MenuItemBoolPtr(label string, shortcut string, p_selected *bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	shortcutArg, shortcutFin := internal.WrapString[C.char](shortcut)
	p_selectedArg, p_selectedFin := internal.WrapNumberPtr[C.bool, bool](p_selected)

	defer func() {
		labelFin()
		shortcutFin()
		p_selectedFin()
	}()
	return C.wrap_igMenuItem_BoolPtr(labelArg, shortcutArg, p_selectedArg) == C.bool(true)
}

func InternalOpenPopupEx(id ID) {
	idArg, idFin := id.C()
	C.wrap_igOpenPopupEx(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

func OpenPopupOnItemClick() {
	C.wrap_igOpenPopupOnItemClick()
}

func OpenPopupID(id ID) {
	idArg, idFin := id.C()
	C.wrap_igOpenPopup_ID(internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

func OpenPopupStr(str_id string) {
	str_idArg, str_idFin := internal.WrapString[C.char](str_id)
	C.wrap_igOpenPopup_Str(str_idArg)

	str_idFin()
}

func PlotHistogramFloatPtr(label string, values *float32, values_count int32) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	valuesArg, valuesFin := internal.WrapNumberPtr[C.float, float32](values)
	C.wrap_igPlotHistogram_FloatPtr(labelArg, valuesArg, C.int(values_count))

	labelFin()
	valuesFin()
}

func PlotLinesFloatPtr(label string, values *float32, values_count int32) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	valuesArg, valuesFin := internal.WrapNumberPtr[C.float, float32](values)
	C.wrap_igPlotLines_FloatPtr(labelArg, valuesArg, C.int(values_count))

	labelFin()
	valuesFin()
}

func PopStyleColor() {
	C.wrap_igPopStyleColor()
}

func PopStyleVar() {
	C.wrap_igPopStyleVar()
}

func ProgressBar(fraction float32) {
	C.wrap_igProgressBar(C.float(fraction))
}

func PushTextWrapPos() {
	C.wrap_igPushTextWrapPos()
}

func InternalRenderArrow(draw_list *DrawList, pos Vec2, col uint32, dir Dir) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.wrap_igRenderArrow(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()), C.ImU32(col), C.ImGuiDir(dir))

	draw_listFin()
}

func InternalRenderColorRectWithAlphaCheckerboard(draw_list *DrawList, p_min Vec2, p_max Vec2, fill_col uint32, grid_step float32, grid_off Vec2) {
	draw_listArg, draw_listFin := draw_list.Handle()
	C.wrap_igRenderColorRectWithAlphaCheckerboard(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(fill_col), C.float(grid_step), internal.ReinterpretCast[C.ImVec2](grid_off.ToC()))

	draw_listFin()
}

func InternalRenderFrame(p_min Vec2, p_max Vec2, fill_col uint32) {
	C.wrap_igRenderFrame(internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()), C.ImU32(fill_col))
}

func InternalRenderFrameBorder(p_min Vec2, p_max Vec2) {
	C.wrap_igRenderFrameBorder(internal.ReinterpretCast[C.ImVec2](p_min.ToC()), internal.ReinterpretCast[C.ImVec2](p_max.ToC()))
}

func InternalRenderNavCursor(bb Rect, id ID) {
	idArg, idFin := id.C()
	C.wrap_igRenderNavCursor(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg))

	idFin()
}

func RenderPlatformWindowsDefault() {
	C.wrap_igRenderPlatformWindowsDefault()
}

func InternalRenderText(pos Vec2, text string) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igRenderText(internal.ReinterpretCast[C.ImVec2](pos.ToC()), textArg, C.int(len(text)))

	textFin()
}

func InternalRenderTextClipped(pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2) {
	textArg, textFin := internal.WrapString[C.char](text)
	text_size_if_knownArg, text_size_if_knownFin := internal.Wrap(text_size_if_known)
	C.wrap_igRenderTextClipped(internal.ReinterpretCast[C.ImVec2](pos_min.ToC()), internal.ReinterpretCast[C.ImVec2](pos_max.ToC()), textArg, C.int(len(text)), internal.ReinterpretCast[*C.ImVec2](text_size_if_knownArg))

	textFin()
	text_size_if_knownFin()
}

func InternalRenderTextClippedEx(draw_list *DrawList, pos_min Vec2, pos_max Vec2, text string, text_size_if_known *Vec2) {
	draw_listArg, draw_listFin := draw_list.Handle()
	textArg, textFin := internal.WrapString[C.char](text)
	text_size_if_knownArg, text_size_if_knownFin := internal.Wrap(text_size_if_known)
	C.wrap_igRenderTextClippedEx(internal.ReinterpretCast[*C.ImDrawList](draw_listArg), internal.ReinterpretCast[C.ImVec2](pos_min.ToC()), internal.ReinterpretCast[C.ImVec2](pos_max.ToC()), textArg, C.int(len(text)), internal.ReinterpretCast[*C.ImVec2](text_size_if_knownArg))

	draw_listFin()
	textFin()
	text_size_if_knownFin()
}

func ResetMouseDragDelta() {
	C.wrap_igResetMouseDragDelta()
}

func SameLine() {
	C.wrap_igSameLine()
}

func SaveIniSettingsToMemory() string {
	return func() string {
		result := C.wrap_igSaveIniSettingsToMemory()
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalScrollToItem() {
	C.wrap_igScrollToItem()
}

func InternalScrollToRect(window *Window, rect Rect) {
	windowArg, windowFin := window.Handle()
	C.wrap_igScrollToRect(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](rect.ToC()))

	windowFin()
}

func InternalScrollToRectEx(window *Window, rect Rect) Vec2 {
	pOut := new(Vec2)
	pOutArg, pOutFin := internal.Wrap(pOut)

	windowArg, windowFin := window.Handle()
	C.wrap_igScrollToRectEx(internal.ReinterpretCast[*C.ImVec2](pOutArg), internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImRect](rect.ToC()))

	pOutFin()
	windowFin()

	return *pOut
}

func SelectableBool(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igSelectable_Bool(labelArg) == C.bool(true)
}

func SelectableBoolPtr(label string, p_selected *bool) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	p_selectedArg, p_selectedFin := internal.WrapNumberPtr[C.bool, bool](p_selected)

	defer func() {
		labelFin()
		p_selectedFin()
	}()
	return C.wrap_igSelectable_BoolPtr(labelArg, p_selectedArg) == C.bool(true)
}

func InternalSeparatorEx(flags SeparatorFlags) {
	C.wrap_igSeparatorEx(C.ImGuiSeparatorFlags(flags))
}

func SetAllocatorFunctions(alloc_func MemAllocFunc, free_func MemFreeFunc) {
	alloc_funcArg, alloc_funcFin := alloc_func.C()
	free_funcArg, free_funcFin := free_func.C()
	C.wrap_igSetAllocatorFunctions(internal.ReinterpretCast[C.ImGuiMemAllocFunc](alloc_funcArg), internal.ReinterpretCast[C.ImGuiMemFreeFunc](free_funcArg))

	alloc_funcFin()
	free_funcFin()
}

func SetDragDropPayload(typeArg string, data uintptr, sz uint64) bool {
	typeArgArg, typeArgFin := internal.WrapString[C.char](typeArg)

	defer func() {
		typeArgFin()
	}()
	return C.wrap_igSetDragDropPayload(typeArgArg, C.uintptr_t(data), C.xulong(sz)) == C.bool(true)
}

func InternalSetKeyOwner(key Key, owner_id ID) {
	owner_idArg, owner_idFin := owner_id.C()
	C.wrap_igSetKeyOwner(C.ImGuiKey(key), internal.ReinterpretCast[C.ImGuiID](owner_idArg))

	owner_idFin()
}

func InternalSetKeyOwnersForKeyChord(key KeyChord, owner_id ID) {
	keyArg, keyFin := key.C()
	owner_idArg, owner_idFin := owner_id.C()
	C.wrap_igSetKeyOwnersForKeyChord(internal.ReinterpretCast[C.ImGuiKeyChord](keyArg), internal.ReinterpretCast[C.ImGuiID](owner_idArg))

	keyFin()
	owner_idFin()
}

func SetKeyboardFocusHere() {
	C.wrap_igSetKeyboardFocusHere()
}

func SetNextItemOpen(is_open bool) {
	C.wrap_igSetNextItemOpen(C.bool(is_open))
}

func SetNextItemShortcut(key_chord KeyChord) {
	key_chordArg, key_chordFin := key_chord.C()
	C.wrap_igSetNextItemShortcut(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg))

	key_chordFin()
}

func SetNextWindowCollapsed(collapsed bool) {
	C.wrap_igSetNextWindowCollapsed(C.bool(collapsed))
}

func SetNextWindowDockID(dock_id ID) {
	dock_idArg, dock_idFin := dock_id.C()
	C.wrap_igSetNextWindowDockID(internal.ReinterpretCast[C.ImGuiID](dock_idArg))

	dock_idFin()
}

func SetNextWindowPos(pos Vec2) {
	C.wrap_igSetNextWindowPos(internal.ReinterpretCast[C.ImVec2](pos.ToC()))
}

func SetNextWindowSize(size Vec2) {
	C.wrap_igSetNextWindowSize(internal.ReinterpretCast[C.ImVec2](size.ToC()))
}

func SetNextWindowSizeConstraints(size_min Vec2, size_max Vec2) {
	C.wrap_igSetNextWindowSizeConstraints(internal.ReinterpretCast[C.ImVec2](size_min.ToC()), internal.ReinterpretCast[C.ImVec2](size_max.ToC()))
}

func SetScrollFromPosXFloat(local_x float32) {
	C.wrap_igSetScrollFromPosX_Float(C.float(local_x))
}

func SetScrollFromPosYFloat(local_y float32) {
	C.wrap_igSetScrollFromPosY_Float(C.float(local_y))
}

func SetScrollHereX() {
	C.wrap_igSetScrollHereX()
}

func SetScrollHereY() {
	C.wrap_igSetScrollHereY()
}

func SetWindowCollapsedBool(collapsed bool) {
	C.wrap_igSetWindowCollapsed_Bool(C.bool(collapsed))
}

func SetWindowCollapsedStr(name string, collapsed bool) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.wrap_igSetWindowCollapsed_Str(nameArg, C.bool(collapsed))

	nameFin()
}

func InternalSetWindowCollapsedWindowPtr(window *Window, collapsed bool) {
	windowArg, windowFin := window.Handle()
	C.wrap_igSetWindowCollapsed_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), C.bool(collapsed))

	windowFin()
}

func SetWindowPosStr(name string, pos Vec2) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.wrap_igSetWindowPos_Str(nameArg, internal.ReinterpretCast[C.ImVec2](pos.ToC()))

	nameFin()
}

func SetWindowPosVec2(pos Vec2) {
	C.wrap_igSetWindowPos_Vec2(internal.ReinterpretCast[C.ImVec2](pos.ToC()))
}

func InternalSetWindowPosWindowPtr(window *Window, pos Vec2) {
	windowArg, windowFin := window.Handle()
	C.wrap_igSetWindowPos_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImVec2](pos.ToC()))

	windowFin()
}

func SetWindowSizeStr(name string, size Vec2) {
	nameArg, nameFin := internal.WrapString[C.char](name)
	C.wrap_igSetWindowSize_Str(nameArg, internal.ReinterpretCast[C.ImVec2](size.ToC()))

	nameFin()
}

func SetWindowSizeVec2(size Vec2) {
	C.wrap_igSetWindowSize_Vec2(internal.ReinterpretCast[C.ImVec2](size.ToC()))
}

func InternalSetWindowSizeWindowPtr(window *Window, size Vec2) {
	windowArg, windowFin := window.Handle()
	C.wrap_igSetWindowSize_WindowPtr(internal.ReinterpretCast[*C.ImGuiWindow](windowArg), internal.ReinterpretCast[C.ImVec2](size.ToC()))

	windowFin()
}

func Shortcut(key_chord KeyChord) bool {
	key_chordArg, key_chordFin := key_chord.C()

	defer func() {
		key_chordFin()
	}()
	return C.wrap_igShortcut_Nil(internal.ReinterpretCast[C.ImGuiKeyChord](key_chordArg)) == C.bool(true)
}

func ShowAboutWindow() {
	C.wrap_igShowAboutWindow()
}

func ShowDebugLogWindow() {
	C.wrap_igShowDebugLogWindow()
}

func ShowDemoWindow() {
	C.wrap_igShowDemoWindow()
}

func ShowIDStackToolWindow() {
	C.wrap_igShowIDStackToolWindow()
}

func ShowMetricsWindow() {
	C.wrap_igShowMetricsWindow()
}

func ShowStyleEditor() {
	C.wrap_igShowStyleEditor()
}

func SliderAngle(label string, v_rad *float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	v_radArg, v_radFin := internal.WrapNumberPtr[C.float, float32](v_rad)

	defer func() {
		labelFin()
		v_radFin()
	}()
	return C.wrap_igSliderAngle(labelArg, v_radArg) == C.bool(true)
}

func SliderFloat(label string, v *float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igSliderFloat(labelArg, vArg, C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderFloat2(label string, v *[2]float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igSliderFloat2(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderFloat3(label string, v *[3]float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igSliderFloat3(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderFloat4(label string, v *[4]float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = float32(vV)
		}
	}()
	return C.wrap_igSliderFloat4(labelArg, (*C.float)(&vArg[0]), C.float(v_min), C.float(v_max)) == C.bool(true)
}

func SliderInt(label string, v *int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igSliderInt(labelArg, vArg, C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderInt2(label string, v *[2]int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igSliderInt2(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderInt3(label string, v *[3]int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igSliderInt3(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderInt4(label string, v *[4]int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	defer func() {
		labelFin()

		for i, vV := range vArg {
			(*v)[i] = int32(vV)
		}
	}()
	return C.wrap_igSliderInt4(labelArg, (*C.int)(&vArg[0]), C.int(v_min), C.int(v_max)) == C.bool(true)
}

func SliderScalar(label string, data_type DataType, p_data uintptr, p_min uintptr, p_max uintptr) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igSliderScalar(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.uintptr_t(p_min), C.uintptr_t(p_max)) == C.bool(true)
}

func SliderScalarN(label string, data_type DataType, p_data uintptr, components int32, p_min uintptr, p_max uintptr) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igSliderScalarN(labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.int(components), C.uintptr_t(p_min), C.uintptr_t(p_max)) == C.bool(true)
}

func InternalSplitterBehavior(bb Rect, id ID, axis Axis, size1 *float32, size2 *float32, min_size1 float32, min_size2 float32) bool {
	idArg, idFin := id.C()
	size1Arg, size1Fin := internal.WrapNumberPtr[C.float, float32](size1)
	size2Arg, size2Fin := internal.WrapNumberPtr[C.float, float32](size2)

	defer func() {
		idFin()
		size1Fin()
		size2Fin()
	}()
	return C.wrap_igSplitterBehavior(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiAxis(axis), size1Arg, size2Arg, C.float(min_size1), C.float(min_size2)) == C.bool(true)
}

func StyleColorsClassic() {
	C.wrap_igStyleColorsClassic()
}

func StyleColorsDark() {
	C.wrap_igStyleColorsDark()
}

func StyleColorsLight() {
	C.wrap_igStyleColorsLight()
}

func TabItemButton(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igTabItemButton(labelArg) == C.bool(true)
}

func TableGetColumnFlags() TableColumnFlags {
	return TableColumnFlags(C.wrap_igTableGetColumnFlags())
}

func TableGetColumnNameInt() string {
	return func() string {
		result := C.wrap_igTableGetColumnName_Int()
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

func InternalTableGetColumnResizeID(table *Table, column_n int32) ID {
	tableArg, tableFin := table.Handle()

	defer func() {
		tableFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_igTableGetColumnResizeID(internal.ReinterpretCast[*C.ImGuiTable](tableArg), C.int(column_n))
		return &result
	}())
}

func TableNextRow() {
	C.wrap_igTableNextRow()
}

func InternalTableOpenContextMenu() {
	C.wrap_igTableOpenContextMenu()
}

func TableSetBgColor(target TableBgTarget, color uint32) {
	C.wrap_igTableSetBgColor(C.ImGuiTableBgTarget(target), C.ImU32(color))
}

func TableSetupColumn(label string) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.wrap_igTableSetupColumn(labelArg)

	labelFin()
}

func InternalTempInputScalar(bb Rect, id ID, label string, data_type DataType, p_data uintptr, format string) bool {
	idArg, idFin := id.C()
	labelArg, labelFin := internal.WrapString[C.char](label)
	formatArg, formatFin := internal.WrapString[C.char](format)

	defer func() {
		idFin()
		labelFin()
		formatFin()
	}()
	return C.wrap_igTempInputScalar(internal.ReinterpretCast[C.ImRect](bb.ToC()), internal.ReinterpretCast[C.ImGuiID](idArg), labelArg, C.ImGuiDataType(data_type), C.uintptr_t(p_data), formatArg) == C.bool(true)
}

func InternalTextEx(text string) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igTextEx(textArg, C.int(len(text)))

	textFin()
}

func TextLinkOpenURL(label string) {
	labelArg, labelFin := internal.WrapString[C.char](label)
	C.wrap_igTextLinkOpenURL(labelArg)

	labelFin()
}

func TextUnformatted(text string) {
	textArg, textFin := internal.WrapString[C.char](text)
	C.wrap_igTextUnformatted(textArg, C.int(len(text)))

	textFin()
}

func InternalTreeNodeBehavior(id ID, flags TreeNodeFlags, label string) bool {
	idArg, idFin := id.C()
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		idFin()
		labelFin()
	}()
	return C.wrap_igTreeNodeBehavior(internal.ReinterpretCast[C.ImGuiID](idArg), C.ImGuiTreeNodeFlags(flags), labelArg) == C.bool(true)
}

func TreeNodeExStr(label string) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igTreeNodeEx_Str(labelArg) == C.bool(true)
}

func Unindent() {
	C.wrap_igUnindent()
}

func VSliderFloat(label string, size Vec2, v *float32, v_min float32, v_max float32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.float, float32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igVSliderFloat(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), vArg, C.float(v_min), C.float(v_max)) == C.bool(true)
}

func VSliderInt(label string, size Vec2, v *int32, v_min int32, v_max int32) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)
	vArg, vFin := internal.WrapNumberPtr[C.int, int32](v)

	defer func() {
		labelFin()
		vFin()
	}()
	return C.wrap_igVSliderInt(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), vArg, C.int(v_min), C.int(v_max)) == C.bool(true)
}

func VSliderScalar(label string, size Vec2, data_type DataType, p_data uintptr, p_min uintptr, p_max uintptr) bool {
	labelArg, labelFin := internal.WrapString[C.char](label)

	defer func() {
		labelFin()
	}()
	return C.wrap_igVSliderScalar(labelArg, internal.ReinterpretCast[C.ImVec2](size.ToC()), C.ImGuiDataType(data_type), C.uintptr_t(p_data), C.uintptr_t(p_min), C.uintptr_t(p_max)) == C.bool(true)
}

func ValueFloat(prefix string, v float32) {
	prefixArg, prefixFin := internal.WrapString[C.char](prefix)
	C.wrap_igValue_Float(prefixArg, C.float(v))

	prefixFin()
}

// ImBitVector_SetStorage sets value of ImBitVector.Storage
func (self BitVector) SetStorage(v vectors.Vector[uint32]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.ImU32, uint32](vData)
	vVecArg := new(C.ImVector_ImU32)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImBitVector_SetStorage(selfArg, *vVecArg)
}

// ImBitVector_GetStorage returns value of ImBitVector.Storage
func (self *BitVector) Storage() vectors.Vector[uint32] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImBitVector_GetStorage(internal.ReinterpretCast[*C.ImBitVector](selfArg)).Size, C.wrap_ImBitVector_GetStorage(internal.ReinterpretCast[*C.ImBitVector](selfArg)).Capacity, (*uint32)(C.wrap_ImBitVector_GetStorage(internal.ReinterpretCast[*C.ImBitVector](selfArg)).Data))
}

// ImColor_GetValue returns value of ImColor.Value
func (self *Color) Value() Vec4 {
	selfArg, selfFin := internal.Wrap(self)

	defer func() {
		selfFin()
	}()
	return func() Vec4 {
		out := C.wrap_ImColor_GetValue(internal.ReinterpretCast[*C.ImColor](selfArg))
		return *(&Vec4{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawChannel_Set_CmdBuffer sets value of ImDrawChannel._CmdBuffer
func (self DrawChannel) SetCmdBuffer(v vectors.Vector[DrawCmd]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImDrawCmd)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImDrawCmd](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawChannel_Set_CmdBuffer(selfArg, *vVecArg)
}

// ImDrawChannel_Get_CmdBuffer returns value of ImDrawChannel._CmdBuffer
func (self *DrawChannel) CmdBuffer() vectors.Vector[DrawCmd] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawChannel_Get_CmdBuffer(internal.ReinterpretCast[*C.ImDrawChannel](selfArg)).Size, C.wrap_ImDrawChannel_Get_CmdBuffer(internal.ReinterpretCast[*C.ImDrawChannel](selfArg)).Capacity, NewDrawCmdFromC(C.wrap_ImDrawChannel_Get_CmdBuffer(internal.ReinterpretCast[*C.ImDrawChannel](selfArg)).Data))
}

// ImDrawChannel_Set_IdxBuffer sets value of ImDrawChannel._IdxBuffer
func (self DrawChannel) SetIdxBuffer(v vectors.Vector[DrawIdx]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImDrawIdx)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImDrawIdx](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawChannel_Set_IdxBuffer(selfArg, *vVecArg)
}

// ImDrawChannel_Get_IdxBuffer returns value of ImDrawChannel._IdxBuffer
func (self *DrawChannel) IdxBuffer() vectors.Vector[DrawIdx] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawChannel_Get_IdxBuffer(internal.ReinterpretCast[*C.ImDrawChannel](selfArg)).Size, C.wrap_ImDrawChannel_Get_IdxBuffer(internal.ReinterpretCast[*C.ImDrawChannel](selfArg)).Capacity, NewDrawIdxFromC(C.wrap_ImDrawChannel_Get_IdxBuffer(internal.ReinterpretCast[*C.ImDrawChannel](selfArg)).Data))
}

// ImDrawCmd_SetClipRect sets value of ImDrawCmd.ClipRect
//
// 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
func (self DrawCmd) SetClipRect(v Vec4) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetClipRect(selfArg, internal.ReinterpretCast[C.ImVec4](v.ToC()))
}

// ImDrawCmd_GetClipRect returns value of ImDrawCmd.ClipRect
//
// 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
func (self *DrawCmd) ClipRect() Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec4 {
		out := C.wrap_ImDrawCmd_GetClipRect(internal.ReinterpretCast[*C.ImDrawCmd](selfArg))
		return *(&Vec4{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawCmd_SetTextureId sets value of ImDrawCmd.TextureId
//
// 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
func (self DrawCmd) SetTextureId(v TextureID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetTextureId(selfArg, internal.ReinterpretCast[C.ImTextureID](vArg))
}

// ImDrawCmd_GetTextureId returns value of ImDrawCmd.TextureId
//
// 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
func (self *DrawCmd) TextureId() TextureID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextureIDFromC(func() *C.ImTextureID {
		result := C.wrap_ImDrawCmd_GetTextureId(internal.ReinterpretCast[*C.ImDrawCmd](selfArg))
		return &result
	}())
}

// ImDrawCmd_SetVtxOffset sets value of ImDrawCmd.VtxOffset
//
// 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.
func (self DrawCmd) SetVtxOffset(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetVtxOffset(selfArg, C.uint(v))
}

// ImDrawCmd_GetVtxOffset returns value of ImDrawCmd.VtxOffset
//
// 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.
func (self *DrawCmd) VtxOffset() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmd_GetVtxOffset(internal.ReinterpretCast[*C.ImDrawCmd](selfArg)))
}

// ImDrawCmd_SetIdxOffset sets value of ImDrawCmd.IdxOffset
//
// 4    // Start offset in index buffer.
func (self DrawCmd) SetIdxOffset(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetIdxOffset(selfArg, C.uint(v))
}

// ImDrawCmd_GetIdxOffset returns value of ImDrawCmd.IdxOffset
//
// 4    // Start offset in index buffer.
func (self *DrawCmd) IdxOffset() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmd_GetIdxOffset(internal.ReinterpretCast[*C.ImDrawCmd](selfArg)))
}

// ImDrawCmd_SetElemCount sets value of ImDrawCmd.ElemCount
//
// 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
func (self DrawCmd) SetElemCount(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetElemCount(selfArg, C.uint(v))
}

// ImDrawCmd_GetElemCount returns value of ImDrawCmd.ElemCount
//
// 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
func (self *DrawCmd) ElemCount() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmd_GetElemCount(internal.ReinterpretCast[*C.ImDrawCmd](selfArg)))
}

// ImDrawCmd_SetUserCallback sets value of ImDrawCmd.UserCallback
//
// 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
func (self DrawCmd) SetUserCallback(v DrawCallback) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetUserCallback(selfArg, internal.ReinterpretCast[C.ImDrawCallback](vArg))
}

// ImDrawCmd_GetUserCallback returns value of ImDrawCmd.UserCallback
//
// 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
func (self *DrawCmd) UserCallback() DrawCallback {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawCallbackFromC(func() *C.ImDrawCallback {
		result := C.wrap_ImDrawCmd_GetUserCallback(internal.ReinterpretCast[*C.ImDrawCmd](selfArg))
		return &result
	}())
}

// ImDrawCmd_SetUserCallbackData sets value of ImDrawCmd.UserCallbackData
//
// 4-8  // Callback user data (when UserCallback != NULL). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size > 0, this is pointing to a buffer where data is stored.
func (self DrawCmd) SetUserCallbackData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetUserCallbackData(selfArg, C.uintptr_t(v))
}

// ImDrawCmd_GetUserCallbackData returns value of ImDrawCmd.UserCallbackData
//
// 4-8  // Callback user data (when UserCallback != NULL). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size > 0, this is pointing to a buffer where data is stored.
func (self *DrawCmd) UserCallbackData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImDrawCmd_GetUserCallbackData(internal.ReinterpretCast[*C.ImDrawCmd](selfArg)))
}

// ImDrawCmd_SetUserCallbackDataSize sets value of ImDrawCmd.UserCallbackDataSize
//
// 4 // Size of callback user data when using storage, otherwise 0.
func (self DrawCmd) SetUserCallbackDataSize(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetUserCallbackDataSize(selfArg, C.int(v))
}

// ImDrawCmd_GetUserCallbackDataSize returns value of ImDrawCmd.UserCallbackDataSize
//
// 4 // Size of callback user data when using storage, otherwise 0.
func (self *DrawCmd) UserCallbackDataSize() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawCmd_GetUserCallbackDataSize(internal.ReinterpretCast[*C.ImDrawCmd](selfArg)))
}

// ImDrawCmd_SetUserCallbackDataOffset sets value of ImDrawCmd.UserCallbackDataOffset
//
// 4 // [Internal] Offset of callback user data when using storage, otherwise -1.
func (self DrawCmd) SetUserCallbackDataOffset(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmd_SetUserCallbackDataOffset(selfArg, C.int(v))
}

// ImDrawCmd_GetUserCallbackDataOffset returns value of ImDrawCmd.UserCallbackDataOffset
//
// 4 // [Internal] Offset of callback user data when using storage, otherwise -1.
func (self *DrawCmd) UserCallbackDataOffset() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawCmd_GetUserCallbackDataOffset(internal.ReinterpretCast[*C.ImDrawCmd](selfArg)))
}

// ImDrawCmdHeader_SetClipRect sets value of ImDrawCmdHeader.ClipRect
func (self DrawCmdHeader) SetClipRect(v Vec4) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmdHeader_SetClipRect(selfArg, internal.ReinterpretCast[C.ImVec4](v.ToC()))
}

// ImDrawCmdHeader_GetClipRect returns value of ImDrawCmdHeader.ClipRect
func (self *DrawCmdHeader) ClipRect() Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec4 {
		out := C.wrap_ImDrawCmdHeader_GetClipRect(internal.ReinterpretCast[*C.ImDrawCmdHeader](selfArg))
		return *(&Vec4{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawCmdHeader_SetTextureId sets value of ImDrawCmdHeader.TextureId
func (self DrawCmdHeader) SetTextureId(v TextureID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmdHeader_SetTextureId(selfArg, internal.ReinterpretCast[C.ImTextureID](vArg))
}

// ImDrawCmdHeader_GetTextureId returns value of ImDrawCmdHeader.TextureId
func (self *DrawCmdHeader) TextureId() TextureID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextureIDFromC(func() *C.ImTextureID {
		result := C.wrap_ImDrawCmdHeader_GetTextureId(internal.ReinterpretCast[*C.ImDrawCmdHeader](selfArg))
		return &result
	}())
}

// ImDrawCmdHeader_SetVtxOffset sets value of ImDrawCmdHeader.VtxOffset
func (self DrawCmdHeader) SetVtxOffset(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawCmdHeader_SetVtxOffset(selfArg, C.uint(v))
}

// ImDrawCmdHeader_GetVtxOffset returns value of ImDrawCmdHeader.VtxOffset
func (self *DrawCmdHeader) VtxOffset() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawCmdHeader_GetVtxOffset(internal.ReinterpretCast[*C.ImDrawCmdHeader](selfArg)))
}

// ImDrawData_SetValid sets value of ImDrawData.Valid
//
// Only valid after Render() is called and before the next NewFrame() is called.
func (self DrawData) SetValid(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetValid(selfArg, C.bool(v))
}

// ImDrawData_GetValid returns value of ImDrawData.Valid
//
// Only valid after Render() is called and before the next NewFrame() is called.
func (self *DrawData) Valid() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImDrawData_GetValid(internal.ReinterpretCast[*C.ImDrawData](selfArg)) == C.bool(true)
}

// ImDrawData_SetCmdListsCount sets value of ImDrawData.CmdListsCount
//
// Number of ImDrawList* to render
func (self DrawData) SetCmdListsCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetCmdListsCount(selfArg, C.int(v))
}

// ImDrawData_GetCmdListsCount returns value of ImDrawData.CmdListsCount
//
// Number of ImDrawList* to render
func (self *DrawData) CmdListsCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawData_GetCmdListsCount(internal.ReinterpretCast[*C.ImDrawData](selfArg)))
}

// ImDrawData_SetTotalIdxCount sets value of ImDrawData.TotalIdxCount
//
// For convenience, sum of all ImDrawList's IdxBuffer.Size
func (self DrawData) SetTotalIdxCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetTotalIdxCount(selfArg, C.int(v))
}

// ImDrawData_GetTotalIdxCount returns value of ImDrawData.TotalIdxCount
//
// For convenience, sum of all ImDrawList's IdxBuffer.Size
func (self *DrawData) TotalIdxCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawData_GetTotalIdxCount(internal.ReinterpretCast[*C.ImDrawData](selfArg)))
}

// ImDrawData_SetTotalVtxCount sets value of ImDrawData.TotalVtxCount
//
// For convenience, sum of all ImDrawList's VtxBuffer.Size
func (self DrawData) SetTotalVtxCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetTotalVtxCount(selfArg, C.int(v))
}

// ImDrawData_GetTotalVtxCount returns value of ImDrawData.TotalVtxCount
//
// For convenience, sum of all ImDrawList's VtxBuffer.Size
func (self *DrawData) TotalVtxCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawData_GetTotalVtxCount(internal.ReinterpretCast[*C.ImDrawData](selfArg)))
}

// ImDrawData_SetDisplayPos sets value of ImDrawData.DisplayPos
//
// Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)
func (self DrawData) SetDisplayPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetDisplayPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImDrawData_GetDisplayPos returns value of ImDrawData.DisplayPos
//
// Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)
func (self *DrawData) DisplayPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImDrawData_GetDisplayPos(internal.ReinterpretCast[*C.ImDrawData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawData_SetDisplaySize sets value of ImDrawData.DisplaySize
//
// Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)
func (self DrawData) SetDisplaySize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetDisplaySize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImDrawData_GetDisplaySize returns value of ImDrawData.DisplaySize
//
// Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)
func (self *DrawData) DisplaySize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImDrawData_GetDisplaySize(internal.ReinterpretCast[*C.ImDrawData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawData_SetFramebufferScale sets value of ImDrawData.FramebufferScale
//
// Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
func (self DrawData) SetFramebufferScale(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetFramebufferScale(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImDrawData_GetFramebufferScale returns value of ImDrawData.FramebufferScale
//
// Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
func (self *DrawData) FramebufferScale() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImDrawData_GetFramebufferScale(internal.ReinterpretCast[*C.ImDrawData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawData_SetOwnerViewport sets value of ImDrawData.OwnerViewport
//
// Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).
func (self DrawData) SetOwnerViewport(v *Viewport) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawData_SetOwnerViewport(selfArg, internal.ReinterpretCast[*C.ImGuiViewport](vArg))
}

// ImDrawData_GetOwnerViewport returns value of ImDrawData.OwnerViewport
//
// Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).
func (self *DrawData) OwnerViewport() *Viewport {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewViewportFromC(C.wrap_ImDrawData_GetOwnerViewport(internal.ReinterpretCast[*C.ImDrawData](selfArg)))
}

// ImDrawList_SetCmdBuffer sets value of ImDrawList.CmdBuffer
//
//	// This is what you have to render
//
// Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
func (self DrawList) SetCmdBuffer(v vectors.Vector[DrawCmd]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImDrawCmd)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImDrawCmd](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_SetCmdBuffer(selfArg, *vVecArg)
}

// ImDrawList_GetCmdBuffer returns value of ImDrawList.CmdBuffer
//
//	// This is what you have to render
//
// Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
func (self *DrawList) CmdBuffer() vectors.Vector[DrawCmd] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawList_GetCmdBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Size, C.wrap_ImDrawList_GetCmdBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Capacity, NewDrawCmdFromC(C.wrap_ImDrawList_GetCmdBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Data))
}

// ImDrawList_SetIdxBuffer sets value of ImDrawList.IdxBuffer
//
// Index buffer. Each command consume ImDrawCmd::ElemCount of those
func (self DrawList) SetIdxBuffer(v vectors.Vector[DrawIdx]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImDrawIdx)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImDrawIdx](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_SetIdxBuffer(selfArg, *vVecArg)
}

// ImDrawList_GetIdxBuffer returns value of ImDrawList.IdxBuffer
//
// Index buffer. Each command consume ImDrawCmd::ElemCount of those
func (self *DrawList) IdxBuffer() vectors.Vector[DrawIdx] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawList_GetIdxBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Size, C.wrap_ImDrawList_GetIdxBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Capacity, NewDrawIdxFromC(C.wrap_ImDrawList_GetIdxBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Data))
}

// ImDrawList_SetVtxBuffer sets value of ImDrawList.VtxBuffer
//
// Vertex buffer.
func (self DrawList) SetVtxBuffer(v vectors.Vector[DrawVert]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImDrawVert)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImDrawVert](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_SetVtxBuffer(selfArg, *vVecArg)
}

// ImDrawList_GetVtxBuffer returns value of ImDrawList.VtxBuffer
//
// Vertex buffer.
func (self *DrawList) VtxBuffer() vectors.Vector[DrawVert] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawList_GetVtxBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Size, C.wrap_ImDrawList_GetVtxBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Capacity, NewDrawVertFromC(C.wrap_ImDrawList_GetVtxBuffer(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Data))
}

// ImDrawList_SetFlags sets value of ImDrawList.Flags
//
// Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
func (self DrawList) SetFlags(v DrawListFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_SetFlags(selfArg, C.ImDrawListFlags(v))
}

// ImDrawList_GetFlags returns value of ImDrawList.Flags
//
// Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
func (self *DrawList) Flags() DrawListFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DrawListFlags(C.wrap_ImDrawList_GetFlags(internal.ReinterpretCast[*C.ImDrawList](selfArg)))
}

// ImDrawList_Set_VtxCurrentIdx sets value of ImDrawList._VtxCurrentIdx
//
//	// [Internal, used while building lists]
//
// [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
func (self DrawList) SetVtxCurrentIdx(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_VtxCurrentIdx(selfArg, C.uint(v))
}

// ImDrawList_Get_VtxCurrentIdx returns value of ImDrawList._VtxCurrentIdx
//
//	// [Internal, used while building lists]
//
// [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
func (self *DrawList) VtxCurrentIdx() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawList_Get_VtxCurrentIdx(internal.ReinterpretCast[*C.ImDrawList](selfArg)))
}

// ImDrawList_Set_Data sets value of ImDrawList._Data
//
// Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
func (self DrawList) SetData(v *DrawListSharedData) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_Data(selfArg, internal.ReinterpretCast[*C.ImDrawListSharedData](vArg))
}

// ImDrawList_Get_Data returns value of ImDrawList._Data
//
// Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
func (self *DrawList) Data() *DrawListSharedData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDrawListSharedDataFromC(C.wrap_ImDrawList_Get_Data(internal.ReinterpretCast[*C.ImDrawList](selfArg)))
}

// ImDrawList_Set_VtxWritePtr sets value of ImDrawList._VtxWritePtr
//
// [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
func (self DrawList) SetVtxWritePtr(v *DrawVert) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_VtxWritePtr(selfArg, internal.ReinterpretCast[*C.ImDrawVert](vArg))
}

// ImDrawList_Get_VtxWritePtr returns value of ImDrawList._VtxWritePtr
//
// [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
func (self *DrawList) VtxWritePtr() *DrawVert {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDrawVertFromC(C.wrap_ImDrawList_Get_VtxWritePtr(internal.ReinterpretCast[*C.ImDrawList](selfArg)))
}

// ImDrawList_Set_IdxWritePtr sets value of ImDrawList._IdxWritePtr
//
// [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
func (self DrawList) SetIdxWritePtr(v *DrawIdx) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_IdxWritePtr(selfArg, internal.ReinterpretCast[*C.ImDrawIdx](vArg))
}

// ImDrawList_Get_IdxWritePtr returns value of ImDrawList._IdxWritePtr
//
// [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
func (self *DrawList) IdxWritePtr() *DrawIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDrawIdxFromC(C.wrap_ImDrawList_Get_IdxWritePtr(internal.ReinterpretCast[*C.ImDrawList](selfArg)))
}

// ImDrawList_Set_Path sets value of ImDrawList._Path
//
// [Internal] current path building
func (self DrawList) SetPath(v vectors.Vector[Vec2]) {
	vData := v.Data
	vDataArg, _ := internal.Wrap(vData)
	vVecArg := new(C.ImVector_ImVec2)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImVec2](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_Path(selfArg, *vVecArg)
}

// ImDrawList_Set_CmdHeader sets value of ImDrawList._CmdHeader
//
// [Internal] template of active commands. Fields should match those of CmdBuffer.back().
func (self DrawList) SetCmdHeader(v DrawCmdHeader) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_CmdHeader(selfArg, internal.ReinterpretCast[C.ImDrawCmdHeader](vArg))
}

// ImDrawList_Get_CmdHeader returns value of ImDrawList._CmdHeader
//
// [Internal] template of active commands. Fields should match those of CmdBuffer.back().
func (self *DrawList) CmdHeader() DrawCmdHeader {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawCmdHeaderFromC(func() *C.ImDrawCmdHeader {
		result := C.wrap_ImDrawList_Get_CmdHeader(internal.ReinterpretCast[*C.ImDrawList](selfArg))
		return &result
	}())
}

// ImDrawList_Set_Splitter sets value of ImDrawList._Splitter
//
// [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
func (self DrawList) SetSplitter(v DrawListSplitter) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_Splitter(selfArg, internal.ReinterpretCast[C.ImDrawListSplitter](vArg))
}

// ImDrawList_Get_Splitter returns value of ImDrawList._Splitter
//
// [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
func (self *DrawList) Splitter() DrawListSplitter {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawListSplitterFromC(func() *C.ImDrawListSplitter {
		result := C.wrap_ImDrawList_Get_Splitter(internal.ReinterpretCast[*C.ImDrawList](selfArg))
		return &result
	}())
}

// ImDrawList_Set_ClipRectStack sets value of ImDrawList._ClipRectStack
//
// [Internal]
func (self DrawList) SetClipRectStack(v vectors.Vector[Vec4]) {
	vData := v.Data
	vDataArg, _ := internal.Wrap(vData)
	vVecArg := new(C.ImVector_ImVec4)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImVec4](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_ClipRectStack(selfArg, *vVecArg)
}

// ImDrawList_Set_TextureIdStack sets value of ImDrawList._TextureIdStack
//
// [Internal]
func (self DrawList) SetTextureIdStack(v vectors.Vector[TextureID]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImTextureID)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImTextureID](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_TextureIdStack(selfArg, *vVecArg)
}

// ImDrawList_Get_TextureIdStack returns value of ImDrawList._TextureIdStack
//
// [Internal]
func (self *DrawList) TextureIdStack() vectors.Vector[TextureID] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawList_Get_TextureIdStack(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Size, C.wrap_ImDrawList_Get_TextureIdStack(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Capacity, NewTextureIDFromC(C.wrap_ImDrawList_Get_TextureIdStack(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Data))
}

// ImDrawList_Set_CallbacksDataBuf sets value of ImDrawList._CallbacksDataBuf
//
// [Internal]
func (self DrawList) SetCallbacksDataBuf(v vectors.Vector[byte]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.ImU8, byte](vData)
	vVecArg := new(C.ImVector_ImU8)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_CallbacksDataBuf(selfArg, *vVecArg)
}

// ImDrawList_Get_CallbacksDataBuf returns value of ImDrawList._CallbacksDataBuf
//
// [Internal]
func (self *DrawList) CallbacksDataBuf() vectors.Vector[byte] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawList_Get_CallbacksDataBuf(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Size, C.wrap_ImDrawList_Get_CallbacksDataBuf(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Capacity, (*byte)(C.wrap_ImDrawList_Get_CallbacksDataBuf(internal.ReinterpretCast[*C.ImDrawList](selfArg)).Data))
}

// ImDrawList_Set_FringeScale sets value of ImDrawList._FringeScale
//
// [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
func (self DrawList) SetFringeScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_FringeScale(selfArg, C.float(v))
}

// ImDrawList_Get_FringeScale returns value of ImDrawList._FringeScale
//
// [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
func (self *DrawList) FringeScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawList_Get_FringeScale(internal.ReinterpretCast[*C.ImDrawList](selfArg)))
}

// ImDrawList_Set_OwnerName sets value of ImDrawList._OwnerName
//
// Pointer to owner window's name for debugging
func (self DrawList) SetOwnerName(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawList_Set_OwnerName(selfArg, vArg)
}

// ImDrawList_Get_OwnerName returns value of ImDrawList._OwnerName
//
// Pointer to owner window's name for debugging
func (self *DrawList) OwnerName() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImDrawList_Get_OwnerName(internal.ReinterpretCast[*C.ImDrawList](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImDrawListSharedData_SetTexUvWhitePixel sets value of ImDrawListSharedData.TexUvWhitePixel
//
// UV of white pixel in the atlas
func (self DrawListSharedData) SetTexUvWhitePixel(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetTexUvWhitePixel(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImDrawListSharedData_GetTexUvWhitePixel returns value of ImDrawListSharedData.TexUvWhitePixel
//
// UV of white pixel in the atlas
func (self *DrawListSharedData) TexUvWhitePixel() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImDrawListSharedData_GetTexUvWhitePixel(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawListSharedData_SetFont sets value of ImDrawListSharedData.Font
//
// Current/default font (optional, for simplified AddText overload)
func (self DrawListSharedData) SetFont(v *Font) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetFont(selfArg, internal.ReinterpretCast[*C.ImFont](vArg))
}

// ImDrawListSharedData_GetFont returns value of ImDrawListSharedData.Font
//
// Current/default font (optional, for simplified AddText overload)
func (self *DrawListSharedData) Font() *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImDrawListSharedData_GetFont(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg)))
}

// ImDrawListSharedData_SetFontSize sets value of ImDrawListSharedData.FontSize
//
// Current/default font size (optional, for simplified AddText overload)
func (self DrawListSharedData) SetFontSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetFontSize(selfArg, C.float(v))
}

// ImDrawListSharedData_GetFontSize returns value of ImDrawListSharedData.FontSize
//
// Current/default font size (optional, for simplified AddText overload)
func (self *DrawListSharedData) FontSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetFontSize(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg)))
}

// ImDrawListSharedData_SetFontScale sets value of ImDrawListSharedData.FontScale
//
// Current/default font scale (== FontSize / Font->FontSize)
func (self DrawListSharedData) SetFontScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetFontScale(selfArg, C.float(v))
}

// ImDrawListSharedData_GetFontScale returns value of ImDrawListSharedData.FontScale
//
// Current/default font scale (== FontSize / Font->FontSize)
func (self *DrawListSharedData) FontScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetFontScale(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg)))
}

// ImDrawListSharedData_SetCurveTessellationTol sets value of ImDrawListSharedData.CurveTessellationTol
//
// Tessellation tolerance when using PathBezierCurveTo()
func (self DrawListSharedData) SetCurveTessellationTol(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetCurveTessellationTol(selfArg, C.float(v))
}

// ImDrawListSharedData_GetCurveTessellationTol returns value of ImDrawListSharedData.CurveTessellationTol
//
// Tessellation tolerance when using PathBezierCurveTo()
func (self *DrawListSharedData) CurveTessellationTol() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetCurveTessellationTol(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg)))
}

// ImDrawListSharedData_SetCircleSegmentMaxError sets value of ImDrawListSharedData.CircleSegmentMaxError
//
// Number of circle segments to use per pixel of radius for AddCircle() etc
func (self DrawListSharedData) SetCircleSegmentMaxError(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetCircleSegmentMaxError(selfArg, C.float(v))
}

// ImDrawListSharedData_GetCircleSegmentMaxError returns value of ImDrawListSharedData.CircleSegmentMaxError
//
// Number of circle segments to use per pixel of radius for AddCircle() etc
func (self *DrawListSharedData) CircleSegmentMaxError() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetCircleSegmentMaxError(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg)))
}

// ImDrawListSharedData_SetClipRectFullscreen sets value of ImDrawListSharedData.ClipRectFullscreen
//
// Value for PushClipRectFullscreen()
func (self DrawListSharedData) SetClipRectFullscreen(v Vec4) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetClipRectFullscreen(selfArg, internal.ReinterpretCast[C.ImVec4](v.ToC()))
}

// ImDrawListSharedData_GetClipRectFullscreen returns value of ImDrawListSharedData.ClipRectFullscreen
//
// Value for PushClipRectFullscreen()
func (self *DrawListSharedData) ClipRectFullscreen() Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec4 {
		out := C.wrap_ImDrawListSharedData_GetClipRectFullscreen(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg))
		return *(&Vec4{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawListSharedData_SetInitialFlags sets value of ImDrawListSharedData.InitialFlags
//
// Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)
func (self DrawListSharedData) SetInitialFlags(v DrawListFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetInitialFlags(selfArg, C.ImDrawListFlags(v))
}

// ImDrawListSharedData_GetInitialFlags returns value of ImDrawListSharedData.InitialFlags
//
// Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)
func (self *DrawListSharedData) InitialFlags() DrawListFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DrawListFlags(C.wrap_ImDrawListSharedData_GetInitialFlags(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg)))
}

// ImDrawListSharedData_SetTempBuffer sets value of ImDrawListSharedData.TempBuffer
//
//	// [Internal] Temp write buffer
func (self DrawListSharedData) SetTempBuffer(v vectors.Vector[Vec2]) {
	vData := v.Data
	vDataArg, _ := internal.Wrap(vData)
	vVecArg := new(C.ImVector_ImVec2)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImVec2](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetTempBuffer(selfArg, *vVecArg)
}

// ImDrawListSharedData_SetArcFastVtx sets value of ImDrawListSharedData.ArcFastVtx[48]
//
//	// [Internal] Lookup tables
//
// Sample points on the quarter of the circle.
func (self DrawListSharedData) SetArcFastVtx(v *[48]Vec2) {
	vArg := make([]C.ImVec2, len(v))
	for i, vV := range v {
		vArg[i] = internal.ReinterpretCast[C.ImVec2](vV.ToC())
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetArcFastVtx(selfArg, (*C.ImVec2)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() Vec2 { out := vV; return *(&Vec2{}).FromC(unsafe.Pointer(&out)) }()
	}
}

// ImDrawListSharedData_GetArcFastVtx returns value of ImDrawListSharedData.ArcFastVtx[48]
//
//	// [Internal] Lookup tables
//
// Sample points on the quarter of the circle.
func (self *DrawListSharedData) ArcFastVtx() [48]Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [48]Vec2 {
		result := [48]Vec2{}
		resultMirr := C.wrap_ImDrawListSharedData_GetArcFastVtx(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg))
		for i := range result {
			result[i] = func() Vec2 {
				out := C.cimgui_ImVec2_GetAtIdx(resultMirr, C.int(i))
				return *(&Vec2{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}

// ImDrawListSharedData_SetArcFastRadiusCutoff sets value of ImDrawListSharedData.ArcFastRadiusCutoff
//
// Cutoff radius after which arc drawing will fallback to slower PathArcTo()
func (self DrawListSharedData) SetArcFastRadiusCutoff(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetArcFastRadiusCutoff(selfArg, C.float(v))
}

// ImDrawListSharedData_GetArcFastRadiusCutoff returns value of ImDrawListSharedData.ArcFastRadiusCutoff
//
// Cutoff radius after which arc drawing will fallback to slower PathArcTo()
func (self *DrawListSharedData) ArcFastRadiusCutoff() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImDrawListSharedData_GetArcFastRadiusCutoff(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg)))
}

// ImDrawListSharedData_SetCircleSegmentCounts sets value of ImDrawListSharedData.CircleSegmentCounts[64]
//
// Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)
func (self DrawListSharedData) SetCircleSegmentCounts(v *[64]byte) {
	vArg := make([]C.ImU8, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU8(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetCircleSegmentCounts(selfArg, (*C.ImU8)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = byte(vV)
	}
}

// ImDrawListSharedData_GetCircleSegmentCounts returns value of ImDrawListSharedData.CircleSegmentCounts[64]
//
// Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)
func (self *DrawListSharedData) CircleSegmentCounts() [64]byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [64]byte {
		result := [64]byte{}
		resultMirr := C.wrap_ImDrawListSharedData_GetCircleSegmentCounts(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg))
		for i := range result {
			result[i] = byte(C.cimgui_ImU8_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImDrawListSharedData_SetTexUvLines sets value of ImDrawListSharedData.TexUvLines
//
// UV of anti-aliased lines in the atlas
func (self DrawListSharedData) SetTexUvLines(v *Vec4) {
	vArg, _ := internal.Wrap(v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSharedData_SetTexUvLines(selfArg, internal.ReinterpretCast[*C.ImVec4](vArg))
}

// ImDrawListSharedData_GetTexUvLines returns value of ImDrawListSharedData.TexUvLines
//
// UV of anti-aliased lines in the atlas
func (self *DrawListSharedData) TexUvLines() *Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (&Vec4{}).FromC(unsafe.Pointer(C.wrap_ImDrawListSharedData_GetTexUvLines(internal.ReinterpretCast[*C.ImDrawListSharedData](selfArg))))
}

// ImDrawListSplitter_Set_Current sets value of ImDrawListSplitter._Current
//
// Current channel number (0)
func (self DrawListSplitter) SetCurrent(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSplitter_Set_Current(selfArg, C.int(v))
}

// ImDrawListSplitter_Get_Current returns value of ImDrawListSplitter._Current
//
// Current channel number (0)
func (self *DrawListSplitter) Current() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawListSplitter_Get_Current(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg)))
}

// ImDrawListSplitter_Set_Count sets value of ImDrawListSplitter._Count
//
// Number of active channels (1+)
func (self DrawListSplitter) SetCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSplitter_Set_Count(selfArg, C.int(v))
}

// ImDrawListSplitter_Get_Count returns value of ImDrawListSplitter._Count
//
// Number of active channels (1+)
func (self *DrawListSplitter) Count() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImDrawListSplitter_Get_Count(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg)))
}

// ImDrawListSplitter_Set_Channels sets value of ImDrawListSplitter._Channels
//
// Draw channels (not resized down so _Count might be < Channels.Size)
func (self DrawListSplitter) SetChannels(v vectors.Vector[DrawChannel]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImDrawChannel)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImDrawChannel](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawListSplitter_Set_Channels(selfArg, *vVecArg)
}

// ImDrawListSplitter_Get_Channels returns value of ImDrawListSplitter._Channels
//
// Draw channels (not resized down so _Count might be < Channels.Size)
func (self *DrawListSplitter) Channels() vectors.Vector[DrawChannel] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImDrawListSplitter_Get_Channels(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg)).Size, C.wrap_ImDrawListSplitter_Get_Channels(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg)).Capacity, NewDrawChannelFromC(C.wrap_ImDrawListSplitter_Get_Channels(internal.ReinterpretCast[*C.ImDrawListSplitter](selfArg)).Data))
}

// ImDrawVert_SetPos sets value of ImDrawVert.pos
func (self DrawVert) SetPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawVert_SetPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImDrawVert_GetPos returns value of ImDrawVert.pos
func (self *DrawVert) Pos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImDrawVert_GetPos(internal.ReinterpretCast[*C.ImDrawVert](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawVert_SetUv sets value of ImDrawVert.uv
func (self DrawVert) SetUv(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawVert_SetUv(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImDrawVert_GetUv returns value of ImDrawVert.uv
func (self *DrawVert) Uv() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImDrawVert_GetUv(internal.ReinterpretCast[*C.ImDrawVert](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImDrawVert_SetCol sets value of ImDrawVert.col
func (self DrawVert) SetCol(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImDrawVert_SetCol(selfArg, C.ImU32(v))
}

// ImDrawVert_GetCol returns value of ImDrawVert.col
func (self *DrawVert) Col() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImDrawVert_GetCol(internal.ReinterpretCast[*C.ImDrawVert](selfArg)))
}

// ImFont_SetIndexAdvanceX sets value of ImFont.IndexAdvanceX
//
//	// Members: Hot ~20/24 bytes (for CalcTextSize)
//
// 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).
func (self Font) SetIndexAdvanceX(v vectors.Vector[float32]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetIndexAdvanceX(selfArg, *vVecArg)
}

// ImFont_GetIndexAdvanceX returns value of ImFont.IndexAdvanceX
//
//	// Members: Hot ~20/24 bytes (for CalcTextSize)
//
// 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).
func (self *Font) IndexAdvanceX() vectors.Vector[float32] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImFont_GetIndexAdvanceX(internal.ReinterpretCast[*C.ImFont](selfArg)).Size, C.wrap_ImFont_GetIndexAdvanceX(internal.ReinterpretCast[*C.ImFont](selfArg)).Capacity, (*float32)(C.wrap_ImFont_GetIndexAdvanceX(internal.ReinterpretCast[*C.ImFont](selfArg)).Data))
}

// ImFont_SetFallbackAdvanceX sets value of ImFont.FallbackAdvanceX
//
// 4     // out // = FallbackGlyph->AdvanceX
func (self Font) SetFallbackAdvanceX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetFallbackAdvanceX(selfArg, C.float(v))
}

// ImFont_GetFallbackAdvanceX returns value of ImFont.FallbackAdvanceX
//
// 4     // out // = FallbackGlyph->AdvanceX
func (self *Font) FallbackAdvanceX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetFallbackAdvanceX(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetFontSize sets value of ImFont.FontSize
//
// 4     // in  //            // Height of characters/line, set during loading (don't change after loading)
func (self Font) SetFontSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetFontSize(selfArg, C.float(v))
}

// ImFont_GetFontSize returns value of ImFont.FontSize
//
// 4     // in  //            // Height of characters/line, set during loading (don't change after loading)
func (self *Font) FontSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetFontSize(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetIndexLookup sets value of ImFont.IndexLookup
//
//	// Members: Hot ~28/40 bytes (for CalcTextSize + render loop)
//
// 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
func (self Font) SetIndexLookup(v vectors.Vector[(Wchar)]) {
	vData := v.Data

	vVecArg := new(C.ImVector_ImWchar)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = (*C.ImWchar)(vData)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetIndexLookup(selfArg, *vVecArg)
}

// ImFont_GetIndexLookup returns value of ImFont.IndexLookup
//
//	// Members: Hot ~28/40 bytes (for CalcTextSize + render loop)
//
// 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
func (self *Font) IndexLookup() vectors.Vector[(Wchar)] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImFont_GetIndexLookup(internal.ReinterpretCast[*C.ImFont](selfArg)).Size, C.wrap_ImFont_GetIndexLookup(internal.ReinterpretCast[*C.ImFont](selfArg)).Capacity, (*Wchar)(C.wrap_ImFont_GetIndexLookup(internal.ReinterpretCast[*C.ImFont](selfArg)).Data))
}

// ImFont_SetGlyphs sets value of ImFont.Glyphs
//
// 12-16 // out //            // All glyphs.
func (self Font) SetGlyphs(v vectors.Vector[FontGlyph]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImFontGlyph)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImFontGlyph](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetGlyphs(selfArg, *vVecArg)
}

// ImFont_GetGlyphs returns value of ImFont.Glyphs
//
// 12-16 // out //            // All glyphs.
func (self *Font) Glyphs() vectors.Vector[FontGlyph] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImFont_GetGlyphs(internal.ReinterpretCast[*C.ImFont](selfArg)).Size, C.wrap_ImFont_GetGlyphs(internal.ReinterpretCast[*C.ImFont](selfArg)).Capacity, NewFontGlyphFromC(C.wrap_ImFont_GetGlyphs(internal.ReinterpretCast[*C.ImFont](selfArg)).Data))
}

// ImFont_SetFallbackGlyph sets value of ImFont.FallbackGlyph
//
// 4-8   // out // = FindGlyph(FontFallbackChar)
func (self Font) SetFallbackGlyph(v *FontGlyph) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetFallbackGlyph(selfArg, internal.ReinterpretCast[*C.ImFontGlyph](vArg))
}

// ImFont_GetFallbackGlyph returns value of ImFont.FallbackGlyph
//
// 4-8   // out // = FindGlyph(FontFallbackChar)
func (self *Font) FallbackGlyph() *FontGlyph {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontGlyphFromC(C.wrap_ImFont_GetFallbackGlyph(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetContainerAtlas sets value of ImFont.ContainerAtlas
//
//	// Members: Cold ~32/40 bytes
//
// 4-8   // out //            // What we has been loaded into
func (self Font) SetContainerAtlas(v *FontAtlas) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetContainerAtlas(selfArg, internal.ReinterpretCast[*C.ImFontAtlas](vArg))
}

// ImFont_GetContainerAtlas returns value of ImFont.ContainerAtlas
//
//	// Members: Cold ~32/40 bytes
//
// 4-8   // out //            // What we has been loaded into
func (self *Font) ContainerAtlas() *FontAtlas {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontAtlasFromC(C.wrap_ImFont_GetContainerAtlas(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetConfigData sets value of ImFont.ConfigData
//
// 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData
func (self Font) SetConfigData(v *FontConfig) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetConfigData(selfArg, internal.ReinterpretCast[*C.ImFontConfig](vArg))
}

// ImFont_GetConfigData returns value of ImFont.ConfigData
//
// 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData
func (self *Font) ConfigData() *FontConfig {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontConfigFromC(C.wrap_ImFont_GetConfigData(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetConfigDataCount sets value of ImFont.ConfigDataCount
//
// 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
func (self Font) SetConfigDataCount(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetConfigDataCount(selfArg, C.short(v))
}

// ImFont_GetConfigDataCount returns value of ImFont.ConfigDataCount
//
// 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
func (self *Font) ConfigDataCount() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImFont_GetConfigDataCount(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetFallbackChar sets value of ImFont.FallbackChar
//
// 2     // out // = FFFD/'?' // Character used if a glyph isn't found.
func (self Font) SetFallbackChar(v Wchar) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetFallbackChar(selfArg, C.ImWchar(v))
}

// ImFont_GetFallbackChar returns value of ImFont.FallbackChar
//
// 2     // out // = FFFD/'?' // Character used if a glyph isn't found.
func (self *Font) FallbackChar() Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImFont_GetFallbackChar(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetEllipsisChar sets value of ImFont.EllipsisChar
//
// 2     // out // = '...'/'.'// Character used for ellipsis rendering.
func (self Font) SetEllipsisChar(v Wchar) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisChar(selfArg, C.ImWchar(v))
}

// ImFont_GetEllipsisChar returns value of ImFont.EllipsisChar
//
// 2     // out // = '...'/'.'// Character used for ellipsis rendering.
func (self *Font) EllipsisChar() Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImFont_GetEllipsisChar(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetEllipsisCharCount sets value of ImFont.EllipsisCharCount
//
// 1     // out // 1 or 3
func (self Font) SetEllipsisCharCount(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisCharCount(selfArg, C.short(v))
}

// ImFont_GetEllipsisCharCount returns value of ImFont.EllipsisCharCount
//
// 1     // out // 1 or 3
func (self *Font) EllipsisCharCount() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImFont_GetEllipsisCharCount(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetEllipsisWidth sets value of ImFont.EllipsisWidth
//
// 4     // out               // Width
func (self Font) SetEllipsisWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisWidth(selfArg, C.float(v))
}

// ImFont_GetEllipsisWidth returns value of ImFont.EllipsisWidth
//
// 4     // out               // Width
func (self *Font) EllipsisWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetEllipsisWidth(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetEllipsisCharStep sets value of ImFont.EllipsisCharStep
//
// 4     // out               // Step between characters when EllipsisCount > 0
func (self Font) SetEllipsisCharStep(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetEllipsisCharStep(selfArg, C.float(v))
}

// ImFont_GetEllipsisCharStep returns value of ImFont.EllipsisCharStep
//
// 4     // out               // Step between characters when EllipsisCount > 0
func (self *Font) EllipsisCharStep() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetEllipsisCharStep(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetDirtyLookupTables sets value of ImFont.DirtyLookupTables
//
// 1     // out //
func (self Font) SetDirtyLookupTables(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetDirtyLookupTables(selfArg, C.bool(v))
}

// ImFont_GetDirtyLookupTables returns value of ImFont.DirtyLookupTables
//
// 1     // out //
func (self *Font) DirtyLookupTables() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFont_GetDirtyLookupTables(internal.ReinterpretCast[*C.ImFont](selfArg)) == C.bool(true)
}

// ImFont_SetScale sets value of ImFont.Scale
//
// 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
func (self Font) SetScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetScale(selfArg, C.float(v))
}

// ImFont_GetScale returns value of ImFont.Scale
//
// 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
func (self *Font) Scale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetScale(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetAscent sets value of ImFont.Ascent
//
// 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
func (self Font) SetAscent(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetAscent(selfArg, C.float(v))
}

// ImFont_GetAscent returns value of ImFont.Ascent
//
// 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
func (self *Font) Ascent() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetAscent(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetDescent sets value of ImFont.Descent
//
// 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
func (self Font) SetDescent(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetDescent(selfArg, C.float(v))
}

// ImFont_GetDescent returns value of ImFont.Descent
//
// 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
func (self *Font) Descent() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFont_GetDescent(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetMetricsTotalSurface sets value of ImFont.MetricsTotalSurface
//
// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
func (self Font) SetMetricsTotalSurface(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetMetricsTotalSurface(selfArg, C.int(v))
}

// ImFont_GetMetricsTotalSurface returns value of ImFont.MetricsTotalSurface
//
// 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
func (self *Font) MetricsTotalSurface() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFont_GetMetricsTotalSurface(internal.ReinterpretCast[*C.ImFont](selfArg)))
}

// ImFont_SetUsed4kPagesMap sets value of ImFont.Used4kPagesMap[(0x10FFFF+1)/4096/8]
//
// 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.
func (self Font) SetUsed4kPagesMap(v *[34]byte) {
	vArg := make([]C.ImU8, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU8(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFont_SetUsed4kPagesMap(selfArg, (*C.ImU8)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = byte(vV)
	}
}

// ImFont_GetUsed4kPagesMap returns value of ImFont.Used4kPagesMap[(0x10FFFF+1)/4096/8]
//
// 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.
func (self *Font) Used4kPagesMap() [34]byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [34]byte {
		result := [34]byte{}
		resultMirr := C.wrap_ImFont_GetUsed4kPagesMap(internal.ReinterpretCast[*C.ImFont](selfArg))
		for i := range result {
			result[i] = byte(C.cimgui_ImU8_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImFontAtlas_SetFlags sets value of ImFontAtlas.Flags
//
// Build flags (see ImFontAtlasFlags_)
func (self FontAtlas) SetFlags(v FontAtlasFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetFlags(selfArg, C.ImFontAtlasFlags(v))
}

// ImFontAtlas_GetFlags returns value of ImFontAtlas.Flags
//
// Build flags (see ImFontAtlasFlags_)
func (self *FontAtlas) Flags() FontAtlasFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return FontAtlasFlags(C.wrap_ImFontAtlas_GetFlags(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetTexDesiredWidth sets value of ImFontAtlas.TexDesiredWidth
//
// Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
func (self FontAtlas) SetTexDesiredWidth(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexDesiredWidth(selfArg, C.int(v))
}

// ImFontAtlas_GetTexDesiredWidth returns value of ImFontAtlas.TexDesiredWidth
//
// Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
func (self *FontAtlas) TexDesiredWidth() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexDesiredWidth(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetTexGlyphPadding sets value of ImFontAtlas.TexGlyphPadding
//
// Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).
func (self FontAtlas) SetTexGlyphPadding(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexGlyphPadding(selfArg, C.int(v))
}

// ImFontAtlas_GetTexGlyphPadding returns value of ImFontAtlas.TexGlyphPadding
//
// Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).
func (self *FontAtlas) TexGlyphPadding() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexGlyphPadding(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetLocked sets value of ImFontAtlas.Locked
//
// Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
func (self FontAtlas) SetLocked(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetLocked(selfArg, C.bool(v))
}

// ImFontAtlas_GetLocked returns value of ImFontAtlas.Locked
//
// Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
func (self *FontAtlas) Locked() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontAtlas_GetLocked(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)) == C.bool(true)
}

// ImFontAtlas_SetUserData sets value of ImFontAtlas.UserData
//
// Store your own atlas related user-data (if e.g. you have multiple font atlas).
func (self FontAtlas) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetUserData(selfArg, C.uintptr_t(v))
}

// ImFontAtlas_GetUserData returns value of ImFontAtlas.UserData
//
// Store your own atlas related user-data (if e.g. you have multiple font atlas).
func (self *FontAtlas) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImFontAtlas_GetUserData(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetTexReady sets value of ImFontAtlas.TexReady
//
//	// [Internal]
//	// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
//
// Set when texture was built matching current font input
func (self FontAtlas) SetTexReady(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexReady(selfArg, C.bool(v))
}

// ImFontAtlas_GetTexReady returns value of ImFontAtlas.TexReady
//
//	// [Internal]
//	// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
//
// Set when texture was built matching current font input
func (self *FontAtlas) TexReady() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontAtlas_GetTexReady(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)) == C.bool(true)
}

// ImFontAtlas_SetTexPixelsUseColors sets value of ImFontAtlas.TexPixelsUseColors
//
// Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.
func (self FontAtlas) SetTexPixelsUseColors(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexPixelsUseColors(selfArg, C.bool(v))
}

// ImFontAtlas_GetTexPixelsUseColors returns value of ImFontAtlas.TexPixelsUseColors
//
// Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.
func (self *FontAtlas) TexPixelsUseColors() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontAtlas_GetTexPixelsUseColors(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)) == C.bool(true)
}

// ImFontAtlas_SetTexPixelsAlpha8 sets value of ImFontAtlas.TexPixelsAlpha8
//
// 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
func (self FontAtlas) SetTexPixelsAlpha8(v *uint) {
	vArg, _ := internal.WrapNumberPtr[C.uchar, uint](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexPixelsAlpha8(selfArg, vArg)
}

// ImFontAtlas_GetTexPixelsAlpha8 returns value of ImFontAtlas.TexPixelsAlpha8
//
// 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
func (self *FontAtlas) TexPixelsAlpha8() *uint {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*uint)(unsafe.Pointer(C.wrap_ImFontAtlas_GetTexPixelsAlpha8(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))))
}

// ImFontAtlas_SetTexPixelsRGBA32 sets value of ImFontAtlas.TexPixelsRGBA32
//
// 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
func (self FontAtlas) SetTexPixelsRGBA32(v *uint32) {
	vArg, _ := internal.WrapNumberPtr[C.uint, uint32](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexPixelsRGBA32(selfArg, vArg)
}

// ImFontAtlas_GetTexPixelsRGBA32 returns value of ImFontAtlas.TexPixelsRGBA32
//
// 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
func (self *FontAtlas) TexPixelsRGBA32() *uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*uint32)(C.wrap_ImFontAtlas_GetTexPixelsRGBA32(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetTexWidth sets value of ImFontAtlas.TexWidth
//
// Texture width calculated during Build().
func (self FontAtlas) SetTexWidth(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexWidth(selfArg, C.int(v))
}

// ImFontAtlas_GetTexWidth returns value of ImFontAtlas.TexWidth
//
// Texture width calculated during Build().
func (self *FontAtlas) TexWidth() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexWidth(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetTexHeight sets value of ImFontAtlas.TexHeight
//
// Texture height calculated during Build().
func (self FontAtlas) SetTexHeight(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexHeight(selfArg, C.int(v))
}

// ImFontAtlas_GetTexHeight returns value of ImFontAtlas.TexHeight
//
// Texture height calculated during Build().
func (self *FontAtlas) TexHeight() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetTexHeight(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetTexUvScale sets value of ImFontAtlas.TexUvScale
//
// = (1.0f/TexWidth, 1.0f/TexHeight)
func (self FontAtlas) SetTexUvScale(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexUvScale(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImFontAtlas_GetTexUvScale returns value of ImFontAtlas.TexUvScale
//
// = (1.0f/TexWidth, 1.0f/TexHeight)
func (self *FontAtlas) TexUvScale() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImFontAtlas_GetTexUvScale(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImFontAtlas_SetTexUvWhitePixel sets value of ImFontAtlas.TexUvWhitePixel
//
// Texture coordinates to a white pixel
func (self FontAtlas) SetTexUvWhitePixel(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexUvWhitePixel(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImFontAtlas_GetTexUvWhitePixel returns value of ImFontAtlas.TexUvWhitePixel
//
// Texture coordinates to a white pixel
func (self *FontAtlas) TexUvWhitePixel() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImFontAtlas_GetTexUvWhitePixel(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImFontAtlas_SetCustomRects sets value of ImFontAtlas.CustomRects
//
// Rectangles for packing custom texture data into the atlas.
func (self FontAtlas) SetCustomRects(v vectors.Vector[FontAtlasCustomRect]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImFontAtlasCustomRect)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImFontAtlasCustomRect](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetCustomRects(selfArg, *vVecArg)
}

// ImFontAtlas_GetCustomRects returns value of ImFontAtlas.CustomRects
//
// Rectangles for packing custom texture data into the atlas.
func (self *FontAtlas) CustomRects() vectors.Vector[FontAtlasCustomRect] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImFontAtlas_GetCustomRects(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)).Size, C.wrap_ImFontAtlas_GetCustomRects(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)).Capacity, NewFontAtlasCustomRectFromC(C.wrap_ImFontAtlas_GetCustomRects(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)).Data))
}

// ImFontAtlas_SetConfigData sets value of ImFontAtlas.ConfigData
//
// Configuration data
func (self FontAtlas) SetConfigData(v vectors.Vector[FontConfig]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImFontConfig)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImFontConfig](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetConfigData(selfArg, *vVecArg)
}

// ImFontAtlas_GetConfigData returns value of ImFontAtlas.ConfigData
//
// Configuration data
func (self *FontAtlas) ConfigData() vectors.Vector[FontConfig] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImFontAtlas_GetConfigData(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)).Size, C.wrap_ImFontAtlas_GetConfigData(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)).Capacity, NewFontConfigFromC(C.wrap_ImFontAtlas_GetConfigData(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)).Data))
}

// ImFontAtlas_SetTexUvLines sets value of ImFontAtlas.TexUvLines[(63)+1]
//
// UVs for baked anti-aliased lines
func (self FontAtlas) SetTexUvLines(v *[64]Vec4) {
	vArg := make([]C.ImVec4, len(v))
	for i, vV := range v {
		vArg[i] = internal.ReinterpretCast[C.ImVec4](vV.ToC())
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetTexUvLines(selfArg, (*C.ImVec4)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() Vec4 { out := vV; return *(&Vec4{}).FromC(unsafe.Pointer(&out)) }()
	}
}

// ImFontAtlas_GetTexUvLines returns value of ImFontAtlas.TexUvLines[(63)+1]
//
// UVs for baked anti-aliased lines
func (self *FontAtlas) TexUvLines() [64]Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [64]Vec4 {
		result := [64]Vec4{}
		resultMirr := C.wrap_ImFontAtlas_GetTexUvLines(internal.ReinterpretCast[*C.ImFontAtlas](selfArg))
		for i := range result {
			result[i] = func() Vec4 {
				out := C.cimgui_ImVec4_GetAtIdx(resultMirr, C.int(i))
				return *(&Vec4{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}

// ImFontAtlas_SetFontBuilderIO sets value of ImFontAtlas.FontBuilderIO
//
//	// [Internal] Font builder
//
// Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).
func (self FontAtlas) SetFontBuilderIO(v *FontBuilderIO) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetFontBuilderIO(selfArg, internal.ReinterpretCast[*C.ImFontBuilderIO](vArg))
}

// ImFontAtlas_GetFontBuilderIO returns value of ImFontAtlas.FontBuilderIO
//
//	// [Internal] Font builder
//
// Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).
func (self *FontAtlas) FontBuilderIO() *FontBuilderIO {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontBuilderIOFromC(C.wrap_ImFontAtlas_GetFontBuilderIO(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetFontBuilderFlags sets value of ImFontAtlas.FontBuilderFlags
//
// Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.
func (self FontAtlas) SetFontBuilderFlags(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetFontBuilderFlags(selfArg, C.uint(v))
}

// ImFontAtlas_GetFontBuilderFlags returns value of ImFontAtlas.FontBuilderFlags
//
// Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.
func (self *FontAtlas) FontBuilderFlags() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontAtlas_GetFontBuilderFlags(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetPackIdMouseCursors sets value of ImFontAtlas.PackIdMouseCursors
//
//	// [Internal] Packing data
//
// Custom texture rectangle ID for white pixel and mouse cursors
func (self FontAtlas) SetPackIdMouseCursors(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetPackIdMouseCursors(selfArg, C.int(v))
}

// ImFontAtlas_GetPackIdMouseCursors returns value of ImFontAtlas.PackIdMouseCursors
//
//	// [Internal] Packing data
//
// Custom texture rectangle ID for white pixel and mouse cursors
func (self *FontAtlas) PackIdMouseCursors() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetPackIdMouseCursors(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlas_SetPackIdLines sets value of ImFontAtlas.PackIdLines
//
// Custom texture rectangle ID for baked anti-aliased lines
func (self FontAtlas) SetPackIdLines(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlas_SetPackIdLines(selfArg, C.int(v))
}

// ImFontAtlas_GetPackIdLines returns value of ImFontAtlas.PackIdLines
//
// Custom texture rectangle ID for baked anti-aliased lines
func (self *FontAtlas) PackIdLines() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontAtlas_GetPackIdLines(internal.ReinterpretCast[*C.ImFontAtlas](selfArg)))
}

// ImFontAtlasCustomRect_SetWidth sets value of ImFontAtlasCustomRect.Width
//
// Input    // Desired rectangle dimension
func (self FontAtlasCustomRect) SetWidth(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetWidth(selfArg, C.ushort(v))
}

// ImFontAtlasCustomRect_GetWidth returns value of ImFontAtlasCustomRect.Width
//
// Input    // Desired rectangle dimension
func (self *FontAtlasCustomRect) Width() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetWidth(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)))
}

// ImFontAtlasCustomRect_SetHeight sets value of ImFontAtlasCustomRect.Height
//
// Input    // Desired rectangle dimension
func (self FontAtlasCustomRect) SetHeight(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetHeight(selfArg, C.ushort(v))
}

// ImFontAtlasCustomRect_GetHeight returns value of ImFontAtlasCustomRect.Height
//
// Input    // Desired rectangle dimension
func (self *FontAtlasCustomRect) Height() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetHeight(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)))
}

// ImFontAtlasCustomRect_SetX sets value of ImFontAtlasCustomRect.X
//
// Output   // Packed position in Atlas
func (self FontAtlasCustomRect) SetX(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetX(selfArg, C.ushort(v))
}

// ImFontAtlasCustomRect_GetX returns value of ImFontAtlasCustomRect.X
//
// Output   // Packed position in Atlas
func (self *FontAtlasCustomRect) X() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetX(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)))
}

// ImFontAtlasCustomRect_SetY sets value of ImFontAtlasCustomRect.Y
//
// Output   // Packed position in Atlas
func (self FontAtlasCustomRect) SetY(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetY(selfArg, C.ushort(v))
}

// ImFontAtlasCustomRect_GetY returns value of ImFontAtlasCustomRect.Y
//
// Output   // Packed position in Atlas
func (self *FontAtlasCustomRect) Y() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImFontAtlasCustomRect_GetY(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)))
}

// ImFontAtlasCustomRect_SetGlyphID sets value of ImFontAtlasCustomRect.GlyphID
//
// Input    // For custom font glyphs only (ID < 0x110000)
func (self FontAtlasCustomRect) SetGlyphID(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetGlyphID(selfArg, C.uint(v))
}

// ImFontAtlasCustomRect_GetGlyphID returns value of ImFontAtlasCustomRect.GlyphID
//
// Input    // For custom font glyphs only (ID < 0x110000)
func (self *FontAtlasCustomRect) GlyphID() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontAtlasCustomRect_GetGlyphID(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)))
}

// ImFontAtlasCustomRect_SetGlyphAdvanceX sets value of ImFontAtlasCustomRect.GlyphAdvanceX
//
// Input    // For custom font glyphs only: glyph xadvance
func (self FontAtlasCustomRect) SetGlyphAdvanceX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetGlyphAdvanceX(selfArg, C.float(v))
}

// ImFontAtlasCustomRect_GetGlyphAdvanceX returns value of ImFontAtlasCustomRect.GlyphAdvanceX
//
// Input    // For custom font glyphs only: glyph xadvance
func (self *FontAtlasCustomRect) GlyphAdvanceX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontAtlasCustomRect_GetGlyphAdvanceX(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)))
}

// ImFontAtlasCustomRect_SetGlyphOffset sets value of ImFontAtlasCustomRect.GlyphOffset
//
// Input    // For custom font glyphs only: glyph display offset
func (self FontAtlasCustomRect) SetGlyphOffset(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetGlyphOffset(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImFontAtlasCustomRect_GetGlyphOffset returns value of ImFontAtlasCustomRect.GlyphOffset
//
// Input    // For custom font glyphs only: glyph display offset
func (self *FontAtlasCustomRect) GlyphOffset() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImFontAtlasCustomRect_GetGlyphOffset(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImFontAtlasCustomRect_SetFont sets value of ImFontAtlasCustomRect.Font
//
// Input    // For custom font glyphs only: target font
func (self FontAtlasCustomRect) SetFont(v *Font) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontAtlasCustomRect_SetFont(selfArg, internal.ReinterpretCast[*C.ImFont](vArg))
}

// ImFontAtlasCustomRect_GetFont returns value of ImFontAtlasCustomRect.Font
//
// Input    // For custom font glyphs only: target font
func (self *FontAtlasCustomRect) Font() *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImFontAtlasCustomRect_GetFont(internal.ReinterpretCast[*C.ImFontAtlasCustomRect](selfArg)))
}

// ImFontConfig_SetFontData sets value of ImFontConfig.FontData
//
//	// TTF/OTF data
func (self FontConfig) SetFontData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontData(selfArg, C.uintptr_t(v))
}

// ImFontConfig_GetFontData returns value of ImFontConfig.FontData
//
//	// TTF/OTF data
func (self *FontConfig) FontData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImFontConfig_GetFontData(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetFontDataSize sets value of ImFontConfig.FontDataSize
//
//	// TTF/OTF data size
func (self FontConfig) SetFontDataSize(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontDataSize(selfArg, C.int(v))
}

// ImFontConfig_GetFontDataSize returns value of ImFontConfig.FontDataSize
//
//	// TTF/OTF data size
func (self *FontConfig) FontDataSize() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetFontDataSize(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetFontDataOwnedByAtlas sets value of ImFontConfig.FontDataOwnedByAtlas
//
// true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
func (self FontConfig) SetFontDataOwnedByAtlas(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontDataOwnedByAtlas(selfArg, C.bool(v))
}

// ImFontConfig_GetFontDataOwnedByAtlas returns value of ImFontConfig.FontDataOwnedByAtlas
//
// true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
func (self *FontConfig) FontDataOwnedByAtlas() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontConfig_GetFontDataOwnedByAtlas(internal.ReinterpretCast[*C.ImFontConfig](selfArg)) == C.bool(true)
}

// ImFontConfig_SetFontNo sets value of ImFontConfig.FontNo
//
// 0        // Index of font within TTF/OTF file
func (self FontConfig) SetFontNo(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontNo(selfArg, C.int(v))
}

// ImFontConfig_GetFontNo returns value of ImFontConfig.FontNo
//
// 0        // Index of font within TTF/OTF file
func (self *FontConfig) FontNo() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetFontNo(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetSizePixels sets value of ImFontConfig.SizePixels
//
//	// Size in pixels for rasterizer (more or less maps to the resulting font height).
func (self FontConfig) SetSizePixels(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetSizePixels(selfArg, C.float(v))
}

// ImFontConfig_GetSizePixels returns value of ImFontConfig.SizePixels
//
//	// Size in pixels for rasterizer (more or less maps to the resulting font height).
func (self *FontConfig) SizePixels() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetSizePixels(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetOversampleH sets value of ImFontConfig.OversampleH
//
// 2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
func (self FontConfig) SetOversampleH(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetOversampleH(selfArg, C.int(v))
}

// ImFontConfig_GetOversampleH returns value of ImFontConfig.OversampleH
//
// 2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
func (self *FontConfig) OversampleH() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetOversampleH(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetOversampleV sets value of ImFontConfig.OversampleV
//
// 1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.
func (self FontConfig) SetOversampleV(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetOversampleV(selfArg, C.int(v))
}

// ImFontConfig_GetOversampleV returns value of ImFontConfig.OversampleV
//
// 1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.
func (self *FontConfig) OversampleV() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImFontConfig_GetOversampleV(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetPixelSnapH sets value of ImFontConfig.PixelSnapH
//
// false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
func (self FontConfig) SetPixelSnapH(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetPixelSnapH(selfArg, C.bool(v))
}

// ImFontConfig_GetPixelSnapH returns value of ImFontConfig.PixelSnapH
//
// false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
func (self *FontConfig) PixelSnapH() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontConfig_GetPixelSnapH(internal.ReinterpretCast[*C.ImFontConfig](selfArg)) == C.bool(true)
}

// ImFontConfig_SetGlyphExtraSpacing sets value of ImFontConfig.GlyphExtraSpacing
//
// 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
func (self FontConfig) SetGlyphExtraSpacing(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphExtraSpacing(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImFontConfig_GetGlyphExtraSpacing returns value of ImFontConfig.GlyphExtraSpacing
//
// 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
func (self *FontConfig) GlyphExtraSpacing() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImFontConfig_GetGlyphExtraSpacing(internal.ReinterpretCast[*C.ImFontConfig](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImFontConfig_SetGlyphOffset sets value of ImFontConfig.GlyphOffset
//
// 0, 0     // Offset all glyphs from this font input.
func (self FontConfig) SetGlyphOffset(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphOffset(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImFontConfig_GetGlyphOffset returns value of ImFontConfig.GlyphOffset
//
// 0, 0     // Offset all glyphs from this font input.
func (self *FontConfig) GlyphOffset() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImFontConfig_GetGlyphOffset(internal.ReinterpretCast[*C.ImFontConfig](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImFontConfig_SetGlyphRanges sets value of ImFontConfig.GlyphRanges
//
// NULL     // THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).
func (self FontConfig) SetGlyphRanges(v *Wchar) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphRanges(selfArg, (*C.ImWchar)(v))
}

// ImFontConfig_GetGlyphRanges returns value of ImFontConfig.GlyphRanges
//
// NULL     // THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).
func (self *FontConfig) GlyphRanges() *Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return (*Wchar)(C.wrap_ImFontConfig_GetGlyphRanges(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetGlyphMinAdvanceX sets value of ImFontConfig.GlyphMinAdvanceX
//
// 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
func (self FontConfig) SetGlyphMinAdvanceX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphMinAdvanceX(selfArg, C.float(v))
}

// ImFontConfig_GetGlyphMinAdvanceX returns value of ImFontConfig.GlyphMinAdvanceX
//
// 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
func (self *FontConfig) GlyphMinAdvanceX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetGlyphMinAdvanceX(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetGlyphMaxAdvanceX sets value of ImFontConfig.GlyphMaxAdvanceX
//
// FLT_MAX  // Maximum AdvanceX for glyphs
func (self FontConfig) SetGlyphMaxAdvanceX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetGlyphMaxAdvanceX(selfArg, C.float(v))
}

// ImFontConfig_GetGlyphMaxAdvanceX returns value of ImFontConfig.GlyphMaxAdvanceX
//
// FLT_MAX  // Maximum AdvanceX for glyphs
func (self *FontConfig) GlyphMaxAdvanceX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetGlyphMaxAdvanceX(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetMergeMode sets value of ImFontConfig.MergeMode
//
// false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
func (self FontConfig) SetMergeMode(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetMergeMode(selfArg, C.bool(v))
}

// ImFontConfig_GetMergeMode returns value of ImFontConfig.MergeMode
//
// false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
func (self *FontConfig) MergeMode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImFontConfig_GetMergeMode(internal.ReinterpretCast[*C.ImFontConfig](selfArg)) == C.bool(true)
}

// ImFontConfig_SetFontBuilderFlags sets value of ImFontConfig.FontBuilderFlags
//
// 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.
func (self FontConfig) SetFontBuilderFlags(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetFontBuilderFlags(selfArg, C.uint(v))
}

// ImFontConfig_GetFontBuilderFlags returns value of ImFontConfig.FontBuilderFlags
//
// 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.
func (self *FontConfig) FontBuilderFlags() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontConfig_GetFontBuilderFlags(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetRasterizerMultiply sets value of ImFontConfig.RasterizerMultiply
//
// 1.0f     // Linearly brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.
func (self FontConfig) SetRasterizerMultiply(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetRasterizerMultiply(selfArg, C.float(v))
}

// ImFontConfig_GetRasterizerMultiply returns value of ImFontConfig.RasterizerMultiply
//
// 1.0f     // Linearly brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.
func (self *FontConfig) RasterizerMultiply() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetRasterizerMultiply(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetRasterizerDensity sets value of ImFontConfig.RasterizerDensity
//
// 1.0f     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.
func (self FontConfig) SetRasterizerDensity(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetRasterizerDensity(selfArg, C.float(v))
}

// ImFontConfig_GetRasterizerDensity returns value of ImFontConfig.RasterizerDensity
//
// 1.0f     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.
func (self *FontConfig) RasterizerDensity() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontConfig_GetRasterizerDensity(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetEllipsisChar sets value of ImFontConfig.EllipsisChar
//
// -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
func (self FontConfig) SetEllipsisChar(v Wchar) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetEllipsisChar(selfArg, C.ImWchar(v))
}

// ImFontConfig_GetEllipsisChar returns value of ImFontConfig.EllipsisChar
//
// -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
func (self *FontConfig) EllipsisChar() Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImFontConfig_GetEllipsisChar(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontConfig_SetName sets value of ImFontConfig.Name[40]
//
//	// [Internal]
//
// Name (strictly to ease debugging)
func (self FontConfig) SetName(v *[40]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetName(selfArg, (*C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = rune(vV)
	}
}

// ImFontConfig_GetName returns value of ImFontConfig.Name[40]
//
//	// [Internal]
//
// Name (strictly to ease debugging)
func (self *FontConfig) Name() [40]rune {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [40]rune {
		result := [40]rune{}
		resultMirr := C.wrap_ImFontConfig_GetName(internal.ReinterpretCast[*C.ImFontConfig](selfArg))
		for i := range result {
			result[i] = rune(C.cimgui_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImFontConfig_SetDstFont sets value of ImFontConfig.DstFont
func (self FontConfig) SetDstFont(v *Font) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontConfig_SetDstFont(selfArg, internal.ReinterpretCast[*C.ImFont](vArg))
}

// ImFontConfig_GetDstFont returns value of ImFontConfig.DstFont
func (self *FontConfig) DstFont() *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImFontConfig_GetDstFont(internal.ReinterpretCast[*C.ImFontConfig](selfArg)))
}

// ImFontGlyph_SetColored sets value of ImFontGlyph.Colored
//
// Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)
func (self FontGlyph) SetColored(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetColored(selfArg, C.uint(v))
}

// ImFontGlyph_GetColored returns value of ImFontGlyph.Colored
//
// Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)
func (self *FontGlyph) Colored() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontGlyph_GetColored(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetVisible sets value of ImFontGlyph.Visible
//
// Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.
func (self FontGlyph) SetVisible(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetVisible(selfArg, C.uint(v))
}

// ImFontGlyph_GetVisible returns value of ImFontGlyph.Visible
//
// Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.
func (self *FontGlyph) Visible() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontGlyph_GetVisible(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetCodepoint sets value of ImFontGlyph.Codepoint
//
// 0x0000..0x10FFFF
func (self FontGlyph) SetCodepoint(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetCodepoint(selfArg, C.uint(v))
}

// ImFontGlyph_GetCodepoint returns value of ImFontGlyph.Codepoint
//
// 0x0000..0x10FFFF
func (self *FontGlyph) Codepoint() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImFontGlyph_GetCodepoint(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetAdvanceX sets value of ImFontGlyph.AdvanceX
//
// Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
func (self FontGlyph) SetAdvanceX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetAdvanceX(selfArg, C.float(v))
}

// ImFontGlyph_GetAdvanceX returns value of ImFontGlyph.AdvanceX
//
// Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
func (self *FontGlyph) AdvanceX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetAdvanceX(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetX0 sets value of ImFontGlyph.X0
//
// Glyph corners
func (self FontGlyph) SetX0(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetX0(selfArg, C.float(v))
}

// ImFontGlyph_GetX0 returns value of ImFontGlyph.X0
//
// Glyph corners
func (self *FontGlyph) X0() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetX0(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetY0 sets value of ImFontGlyph.Y0
//
// Glyph corners
func (self FontGlyph) SetY0(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetY0(selfArg, C.float(v))
}

// ImFontGlyph_GetY0 returns value of ImFontGlyph.Y0
//
// Glyph corners
func (self *FontGlyph) Y0() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetY0(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetX1 sets value of ImFontGlyph.X1
//
// Glyph corners
func (self FontGlyph) SetX1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetX1(selfArg, C.float(v))
}

// ImFontGlyph_GetX1 returns value of ImFontGlyph.X1
//
// Glyph corners
func (self *FontGlyph) X1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetX1(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetY1 sets value of ImFontGlyph.Y1
//
// Glyph corners
func (self FontGlyph) SetY1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetY1(selfArg, C.float(v))
}

// ImFontGlyph_GetY1 returns value of ImFontGlyph.Y1
//
// Glyph corners
func (self *FontGlyph) Y1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetY1(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetU0 sets value of ImFontGlyph.U0
//
// Texture coordinates
func (self FontGlyph) SetU0(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetU0(selfArg, C.float(v))
}

// ImFontGlyph_GetU0 returns value of ImFontGlyph.U0
//
// Texture coordinates
func (self *FontGlyph) U0() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetU0(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetV0 sets value of ImFontGlyph.V0
//
// Texture coordinates
func (self FontGlyph) SetV0(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetV0(selfArg, C.float(v))
}

// ImFontGlyph_GetV0 returns value of ImFontGlyph.V0
//
// Texture coordinates
func (self *FontGlyph) V0() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetV0(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetU1 sets value of ImFontGlyph.U1
//
// Texture coordinates
func (self FontGlyph) SetU1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetU1(selfArg, C.float(v))
}

// ImFontGlyph_GetU1 returns value of ImFontGlyph.U1
//
// Texture coordinates
func (self *FontGlyph) U1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetU1(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyph_SetV1 sets value of ImFontGlyph.V1
//
// Texture coordinates
func (self FontGlyph) SetV1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyph_SetV1(selfArg, C.float(v))
}

// ImFontGlyph_GetV1 returns value of ImFontGlyph.V1
//
// Texture coordinates
func (self *FontGlyph) V1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImFontGlyph_GetV1(internal.ReinterpretCast[*C.ImFontGlyph](selfArg)))
}

// ImFontGlyphRangesBuilder_SetUsedChars sets value of ImFontGlyphRangesBuilder.UsedChars
//
// Store 1-bit per Unicode code point (0=unused, 1=used)
func (self FontGlyphRangesBuilder) SetUsedChars(v vectors.Vector[uint32]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.ImU32, uint32](vData)
	vVecArg := new(C.ImVector_ImU32)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImFontGlyphRangesBuilder_SetUsedChars(selfArg, *vVecArg)
}

// ImFontGlyphRangesBuilder_GetUsedChars returns value of ImFontGlyphRangesBuilder.UsedChars
//
// Store 1-bit per Unicode code point (0=unused, 1=used)
func (self *FontGlyphRangesBuilder) UsedChars() vectors.Vector[uint32] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImFontGlyphRangesBuilder_GetUsedChars(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg)).Size, C.wrap_ImFontGlyphRangesBuilder_GetUsedChars(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg)).Capacity, (*uint32)(C.wrap_ImFontGlyphRangesBuilder_GetUsedChars(internal.ReinterpretCast[*C.ImFontGlyphRangesBuilder](selfArg)).Data))
}

// ImGuiBoxSelectState_SetID sets value of ImGuiBoxSelectState.ID
//
//	// Active box-selection data (persistent, 1 active at a time)
func (self BoxSelectState) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiBoxSelectState_GetID returns value of ImGuiBoxSelectState.ID
//
//	// Active box-selection data (persistent, 1 active at a time)
func (self *BoxSelectState) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiBoxSelectState_GetID(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return &result
	}())
}

// ImGuiBoxSelectState_SetIsActive sets value of ImGuiBoxSelectState.IsActive
func (self BoxSelectState) SetIsActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetIsActive(selfArg, C.bool(v))
}

// ImGuiBoxSelectState_GetIsActive returns value of ImGuiBoxSelectState.IsActive
func (self *BoxSelectState) IsActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiBoxSelectState_GetIsActive(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg)) == C.bool(true)
}

// ImGuiBoxSelectState_SetIsStarting sets value of ImGuiBoxSelectState.IsStarting
func (self BoxSelectState) SetIsStarting(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetIsStarting(selfArg, C.bool(v))
}

// ImGuiBoxSelectState_GetIsStarting returns value of ImGuiBoxSelectState.IsStarting
func (self *BoxSelectState) IsStarting() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiBoxSelectState_GetIsStarting(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg)) == C.bool(true)
}

// ImGuiBoxSelectState_SetIsStartedFromVoid sets value of ImGuiBoxSelectState.IsStartedFromVoid
//
// Starting click was not from an item.
func (self BoxSelectState) SetIsStartedFromVoid(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetIsStartedFromVoid(selfArg, C.bool(v))
}

// ImGuiBoxSelectState_GetIsStartedFromVoid returns value of ImGuiBoxSelectState.IsStartedFromVoid
//
// Starting click was not from an item.
func (self *BoxSelectState) IsStartedFromVoid() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiBoxSelectState_GetIsStartedFromVoid(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg)) == C.bool(true)
}

// ImGuiBoxSelectState_SetIsStartedSetNavIdOnce sets value of ImGuiBoxSelectState.IsStartedSetNavIdOnce
func (self BoxSelectState) SetIsStartedSetNavIdOnce(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetIsStartedSetNavIdOnce(selfArg, C.bool(v))
}

// ImGuiBoxSelectState_GetIsStartedSetNavIdOnce returns value of ImGuiBoxSelectState.IsStartedSetNavIdOnce
func (self *BoxSelectState) IsStartedSetNavIdOnce() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiBoxSelectState_GetIsStartedSetNavIdOnce(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg)) == C.bool(true)
}

// ImGuiBoxSelectState_SetRequestClear sets value of ImGuiBoxSelectState.RequestClear
func (self BoxSelectState) SetRequestClear(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetRequestClear(selfArg, C.bool(v))
}

// ImGuiBoxSelectState_GetRequestClear returns value of ImGuiBoxSelectState.RequestClear
func (self *BoxSelectState) RequestClear() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiBoxSelectState_GetRequestClear(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg)) == C.bool(true)
}

// ImGuiBoxSelectState_SetKeyMods sets value of ImGuiBoxSelectState.KeyMods
//
// Latched key-mods for box-select logic.
func (self BoxSelectState) SetKeyMods(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetKeyMods(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiBoxSelectState_GetKeyMods returns value of ImGuiBoxSelectState.KeyMods
//
// Latched key-mods for box-select logic.
func (self *BoxSelectState) KeyMods() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiBoxSelectState_GetKeyMods(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return &result
	}())
}

// ImGuiBoxSelectState_SetStartPosRel sets value of ImGuiBoxSelectState.StartPosRel
//
// Start position in window-contents relative space (to support scrolling)
func (self BoxSelectState) SetStartPosRel(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetStartPosRel(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiBoxSelectState_GetStartPosRel returns value of ImGuiBoxSelectState.StartPosRel
//
// Start position in window-contents relative space (to support scrolling)
func (self *BoxSelectState) StartPosRel() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiBoxSelectState_GetStartPosRel(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiBoxSelectState_SetEndPosRel sets value of ImGuiBoxSelectState.EndPosRel
//
// End position in window-contents relative space
func (self BoxSelectState) SetEndPosRel(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetEndPosRel(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiBoxSelectState_GetEndPosRel returns value of ImGuiBoxSelectState.EndPosRel
//
// End position in window-contents relative space
func (self *BoxSelectState) EndPosRel() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiBoxSelectState_GetEndPosRel(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiBoxSelectState_SetScrollAccum sets value of ImGuiBoxSelectState.ScrollAccum
//
// Scrolling accumulator (to behave at high-frame spaces)
func (self BoxSelectState) SetScrollAccum(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetScrollAccum(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiBoxSelectState_GetScrollAccum returns value of ImGuiBoxSelectState.ScrollAccum
//
// Scrolling accumulator (to behave at high-frame spaces)
func (self *BoxSelectState) ScrollAccum() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiBoxSelectState_GetScrollAccum(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiBoxSelectState_SetWindow sets value of ImGuiBoxSelectState.Window
func (self BoxSelectState) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiBoxSelectState_GetWindow returns value of ImGuiBoxSelectState.Window
func (self *BoxSelectState) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiBoxSelectState_GetWindow(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg)))
}

// ImGuiBoxSelectState_SetUnclipMode sets value of ImGuiBoxSelectState.UnclipMode
//
//	// Temporary/Transient data
//
// (Temp/Transient, here in hot area). Set/cleared by the BeginMultiSelect()/EndMultiSelect() owning active box-select.
func (self BoxSelectState) SetUnclipMode(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetUnclipMode(selfArg, C.bool(v))
}

// ImGuiBoxSelectState_GetUnclipMode returns value of ImGuiBoxSelectState.UnclipMode
//
//	// Temporary/Transient data
//
// (Temp/Transient, here in hot area). Set/cleared by the BeginMultiSelect()/EndMultiSelect() owning active box-select.
func (self *BoxSelectState) UnclipMode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiBoxSelectState_GetUnclipMode(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg)) == C.bool(true)
}

// ImGuiBoxSelectState_SetUnclipRect sets value of ImGuiBoxSelectState.UnclipRect
//
// Rectangle where ItemAdd() clipping may be temporarily disabled. Need support by multi-select supporting widgets.
func (self BoxSelectState) SetUnclipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetUnclipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiBoxSelectState_GetUnclipRect returns value of ImGuiBoxSelectState.UnclipRect
//
// Rectangle where ItemAdd() clipping may be temporarily disabled. Need support by multi-select supporting widgets.
func (self *BoxSelectState) UnclipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiBoxSelectState_GetUnclipRect(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiBoxSelectState_SetBoxSelectRectPrev sets value of ImGuiBoxSelectState.BoxSelectRectPrev
//
// Selection rectangle in absolute coordinates (derived every frame from BoxSelectStartPosRel and MousePos)
func (self BoxSelectState) SetBoxSelectRectPrev(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetBoxSelectRectPrev(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiBoxSelectState_GetBoxSelectRectPrev returns value of ImGuiBoxSelectState.BoxSelectRectPrev
//
// Selection rectangle in absolute coordinates (derived every frame from BoxSelectStartPosRel and MousePos)
func (self *BoxSelectState) BoxSelectRectPrev() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiBoxSelectState_GetBoxSelectRectPrev(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiBoxSelectState_SetBoxSelectRectCurr sets value of ImGuiBoxSelectState.BoxSelectRectCurr
func (self BoxSelectState) SetBoxSelectRectCurr(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiBoxSelectState_SetBoxSelectRectCurr(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiBoxSelectState_GetBoxSelectRectCurr returns value of ImGuiBoxSelectState.BoxSelectRectCurr
func (self *BoxSelectState) BoxSelectRectCurr() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiBoxSelectState_GetBoxSelectRectCurr(internal.ReinterpretCast[*C.ImGuiBoxSelectState](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiColorMod_SetCol sets value of ImGuiColorMod.Col
func (self ColorMod) SetCol(v Col) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiColorMod_SetCol(selfArg, C.ImGuiCol(v))
}

// ImGuiColorMod_GetCol returns value of ImGuiColorMod.Col
func (self *ColorMod) Col() Col {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Col(C.wrap_ImGuiColorMod_GetCol(internal.ReinterpretCast[*C.ImGuiColorMod](selfArg)))
}

// ImGuiColorMod_SetBackupValue sets value of ImGuiColorMod.BackupValue
func (self ColorMod) SetBackupValue(v Vec4) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiColorMod_SetBackupValue(selfArg, internal.ReinterpretCast[C.ImVec4](v.ToC()))
}

// ImGuiColorMod_GetBackupValue returns value of ImGuiColorMod.BackupValue
func (self *ColorMod) BackupValue() Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec4 {
		out := C.wrap_ImGuiColorMod_GetBackupValue(internal.ReinterpretCast[*C.ImGuiColorMod](selfArg))
		return *(&Vec4{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiComboPreviewData_SetPreviewRect sets value of ImGuiComboPreviewData.PreviewRect
func (self ComboPreviewData) SetPreviewRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetPreviewRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiComboPreviewData_GetPreviewRect returns value of ImGuiComboPreviewData.PreviewRect
func (self *ComboPreviewData) PreviewRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiComboPreviewData_GetPreviewRect(internal.ReinterpretCast[*C.ImGuiComboPreviewData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiComboPreviewData_SetBackupCursorPos sets value of ImGuiComboPreviewData.BackupCursorPos
func (self ComboPreviewData) SetBackupCursorPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupCursorPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiComboPreviewData_GetBackupCursorPos returns value of ImGuiComboPreviewData.BackupCursorPos
func (self *ComboPreviewData) BackupCursorPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiComboPreviewData_GetBackupCursorPos(internal.ReinterpretCast[*C.ImGuiComboPreviewData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiComboPreviewData_SetBackupCursorMaxPos sets value of ImGuiComboPreviewData.BackupCursorMaxPos
func (self ComboPreviewData) SetBackupCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupCursorMaxPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiComboPreviewData_GetBackupCursorMaxPos returns value of ImGuiComboPreviewData.BackupCursorMaxPos
func (self *ComboPreviewData) BackupCursorMaxPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiComboPreviewData_GetBackupCursorMaxPos(internal.ReinterpretCast[*C.ImGuiComboPreviewData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiComboPreviewData_SetBackupCursorPosPrevLine sets value of ImGuiComboPreviewData.BackupCursorPosPrevLine
func (self ComboPreviewData) SetBackupCursorPosPrevLine(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupCursorPosPrevLine(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiComboPreviewData_GetBackupCursorPosPrevLine returns value of ImGuiComboPreviewData.BackupCursorPosPrevLine
func (self *ComboPreviewData) BackupCursorPosPrevLine() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiComboPreviewData_GetBackupCursorPosPrevLine(internal.ReinterpretCast[*C.ImGuiComboPreviewData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiComboPreviewData_SetBackupPrevLineTextBaseOffset sets value of ImGuiComboPreviewData.BackupPrevLineTextBaseOffset
func (self ComboPreviewData) SetBackupPrevLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupPrevLineTextBaseOffset(selfArg, C.float(v))
}

// ImGuiComboPreviewData_GetBackupPrevLineTextBaseOffset returns value of ImGuiComboPreviewData.BackupPrevLineTextBaseOffset
func (self *ComboPreviewData) BackupPrevLineTextBaseOffset() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiComboPreviewData_GetBackupPrevLineTextBaseOffset(internal.ReinterpretCast[*C.ImGuiComboPreviewData](selfArg)))
}

// ImGuiComboPreviewData_SetBackupLayout sets value of ImGuiComboPreviewData.BackupLayout
func (self ComboPreviewData) SetBackupLayout(v LayoutType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiComboPreviewData_SetBackupLayout(selfArg, C.ImGuiLayoutType(v))
}

// ImGuiComboPreviewData_GetBackupLayout returns value of ImGuiComboPreviewData.BackupLayout
func (self *ComboPreviewData) BackupLayout() LayoutType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return LayoutType(C.wrap_ImGuiComboPreviewData_GetBackupLayout(internal.ReinterpretCast[*C.ImGuiComboPreviewData](selfArg)))
}

// ImGuiContext_SetInitialized sets value of ImGuiContext.Initialized
func (self Context) SetInitialized(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInitialized(selfArg, C.bool(v))
}

// ImGuiContext_GetInitialized returns value of ImGuiContext.Initialized
func (self *Context) Initialized() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetInitialized(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetFontAtlasOwnedByContext sets value of ImGuiContext.FontAtlasOwnedByContext
//
// IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
func (self Context) SetFontAtlasOwnedByContext(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFontAtlasOwnedByContext(selfArg, C.bool(v))
}

// ImGuiContext_GetFontAtlasOwnedByContext returns value of ImGuiContext.FontAtlasOwnedByContext
//
// IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
func (self *Context) FontAtlasOwnedByContext() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetFontAtlasOwnedByContext(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetIO sets value of ImGuiContext.IO
func (self Context) SetIO(v IO) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetIO(selfArg, internal.ReinterpretCast[C.ImGuiIO](vArg))
}

// ImGuiContext_GetIO returns value of ImGuiContext.IO
func (self *Context) IO() IO {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIOFromC(func() *C.ImGuiIO {
		result := C.wrap_ImGuiContext_GetIO(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetPlatformIO sets value of ImGuiContext.PlatformIO
func (self Context) SetPlatformIO(v PlatformIO) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformIO(selfArg, internal.ReinterpretCast[C.ImGuiPlatformIO](vArg))
}

// ImGuiContext_GetPlatformIO returns value of ImGuiContext.PlatformIO
func (self *Context) PlatformIO() PlatformIO {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewPlatformIOFromC(func() *C.ImGuiPlatformIO {
		result := C.wrap_ImGuiContext_GetPlatformIO(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetStyle sets value of ImGuiContext.Style
func (self Context) SetStyle(v Style) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetStyle(selfArg, internal.ReinterpretCast[C.ImGuiStyle](vArg))
}

// ImGuiContext_GetStyle returns value of ImGuiContext.Style
func (self *Context) Style() Style {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewStyleFromC(func() *C.ImGuiStyle {
		result := C.wrap_ImGuiContext_GetStyle(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetConfigFlagsCurrFrame sets value of ImGuiContext.ConfigFlagsCurrFrame
//
// = g.IO.ConfigFlags at the time of NewFrame()
func (self Context) SetConfigFlagsCurrFrame(v ConfigFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigFlagsCurrFrame(selfArg, C.ImGuiConfigFlags(v))
}

// ImGuiContext_GetConfigFlagsCurrFrame returns value of ImGuiContext.ConfigFlagsCurrFrame
//
// = g.IO.ConfigFlags at the time of NewFrame()
func (self *Context) ConfigFlagsCurrFrame() ConfigFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ConfigFlags(C.wrap_ImGuiContext_GetConfigFlagsCurrFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetConfigFlagsLastFrame sets value of ImGuiContext.ConfigFlagsLastFrame
func (self Context) SetConfigFlagsLastFrame(v ConfigFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigFlagsLastFrame(selfArg, C.ImGuiConfigFlags(v))
}

// ImGuiContext_GetConfigFlagsLastFrame returns value of ImGuiContext.ConfigFlagsLastFrame
func (self *Context) ConfigFlagsLastFrame() ConfigFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ConfigFlags(C.wrap_ImGuiContext_GetConfigFlagsLastFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFont sets value of ImGuiContext.Font
//
// (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
func (self Context) SetFont(v *Font) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFont(selfArg, internal.ReinterpretCast[*C.ImFont](vArg))
}

// ImGuiContext_GetFont returns value of ImGuiContext.Font
//
// (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
func (self *Context) Font() *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImGuiContext_GetFont(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFontSize sets value of ImGuiContext.FontSize
//
// (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
func (self Context) SetFontSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFontSize(selfArg, C.float(v))
}

// ImGuiContext_GetFontSize returns value of ImGuiContext.FontSize
//
// (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
func (self *Context) FontSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetFontSize(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFontBaseSize sets value of ImGuiContext.FontBaseSize
//
// (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
func (self Context) SetFontBaseSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFontBaseSize(selfArg, C.float(v))
}

// ImGuiContext_GetFontBaseSize returns value of ImGuiContext.FontBaseSize
//
// (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
func (self *Context) FontBaseSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetFontBaseSize(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFontScale sets value of ImGuiContext.FontScale
//
// == FontSize / Font->FontSize
func (self Context) SetFontScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFontScale(selfArg, C.float(v))
}

// ImGuiContext_GetFontScale returns value of ImGuiContext.FontScale
//
// == FontSize / Font->FontSize
func (self *Context) FontScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetFontScale(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetCurrentDpiScale sets value of ImGuiContext.CurrentDpiScale
//
// Current window/viewport DpiScale == CurrentViewport->DpiScale
func (self Context) SetCurrentDpiScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentDpiScale(selfArg, C.float(v))
}

// ImGuiContext_GetCurrentDpiScale returns value of ImGuiContext.CurrentDpiScale
//
// Current window/viewport DpiScale == CurrentViewport->DpiScale
func (self *Context) CurrentDpiScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetCurrentDpiScale(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDrawListSharedData sets value of ImGuiContext.DrawListSharedData
func (self Context) SetDrawListSharedData(v DrawListSharedData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDrawListSharedData(selfArg, internal.ReinterpretCast[C.ImDrawListSharedData](vArg))
}

// ImGuiContext_GetDrawListSharedData returns value of ImGuiContext.DrawListSharedData
func (self *Context) DrawListSharedData() DrawListSharedData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawListSharedDataFromC(func() *C.ImDrawListSharedData {
		result := C.wrap_ImGuiContext_GetDrawListSharedData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetTime sets value of ImGuiContext.Time
func (self Context) SetTime(v float64) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTime(selfArg, C.double(v))
}

// ImGuiContext_GetTime returns value of ImGuiContext.Time
func (self *Context) Time() float64 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImGuiContext_GetTime(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFrameCount sets value of ImGuiContext.FrameCount
func (self Context) SetFrameCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCount(selfArg, C.int(v))
}

// ImGuiContext_GetFrameCount returns value of ImGuiContext.FrameCount
func (self *Context) FrameCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFrameCountEnded sets value of ImGuiContext.FrameCountEnded
func (self Context) SetFrameCountEnded(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCountEnded(selfArg, C.int(v))
}

// ImGuiContext_GetFrameCountEnded returns value of ImGuiContext.FrameCountEnded
func (self *Context) FrameCountEnded() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCountEnded(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFrameCountPlatformEnded sets value of ImGuiContext.FrameCountPlatformEnded
func (self Context) SetFrameCountPlatformEnded(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCountPlatformEnded(selfArg, C.int(v))
}

// ImGuiContext_GetFrameCountPlatformEnded returns value of ImGuiContext.FrameCountPlatformEnded
func (self *Context) FrameCountPlatformEnded() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCountPlatformEnded(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFrameCountRendered sets value of ImGuiContext.FrameCountRendered
func (self Context) SetFrameCountRendered(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFrameCountRendered(selfArg, C.int(v))
}

// ImGuiContext_GetFrameCountRendered returns value of ImGuiContext.FrameCountRendered
func (self *Context) FrameCountRendered() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFrameCountRendered(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWithinFrameScope sets value of ImGuiContext.WithinFrameScope
//
// Set by NewFrame(), cleared by EndFrame()
func (self Context) SetWithinFrameScope(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWithinFrameScope(selfArg, C.bool(v))
}

// ImGuiContext_GetWithinFrameScope returns value of ImGuiContext.WithinFrameScope
//
// Set by NewFrame(), cleared by EndFrame()
func (self *Context) WithinFrameScope() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetWithinFrameScope(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetWithinFrameScopeWithImplicitWindow sets value of ImGuiContext.WithinFrameScopeWithImplicitWindow
//
// Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
func (self Context) SetWithinFrameScopeWithImplicitWindow(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWithinFrameScopeWithImplicitWindow(selfArg, C.bool(v))
}

// ImGuiContext_GetWithinFrameScopeWithImplicitWindow returns value of ImGuiContext.WithinFrameScopeWithImplicitWindow
//
// Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
func (self *Context) WithinFrameScopeWithImplicitWindow() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetWithinFrameScopeWithImplicitWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetWithinEndChild sets value of ImGuiContext.WithinEndChild
//
// Set within EndChild()
func (self Context) SetWithinEndChild(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWithinEndChild(selfArg, C.bool(v))
}

// ImGuiContext_GetWithinEndChild returns value of ImGuiContext.WithinEndChild
//
// Set within EndChild()
func (self *Context) WithinEndChild() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetWithinEndChild(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetGcCompactAll sets value of ImGuiContext.GcCompactAll
//
// Request full GC
func (self Context) SetGcCompactAll(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetGcCompactAll(selfArg, C.bool(v))
}

// ImGuiContext_GetGcCompactAll returns value of ImGuiContext.GcCompactAll
//
// Request full GC
func (self *Context) GcCompactAll() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetGcCompactAll(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetTestEngineHookItems sets value of ImGuiContext.TestEngineHookItems
//
// Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
func (self Context) SetTestEngineHookItems(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTestEngineHookItems(selfArg, C.bool(v))
}

// ImGuiContext_GetTestEngineHookItems returns value of ImGuiContext.TestEngineHookItems
//
// Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
func (self *Context) TestEngineHookItems() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetTestEngineHookItems(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetTestEngine sets value of ImGuiContext.TestEngine
//
// Test engine user data
func (self Context) SetTestEngine(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTestEngine(selfArg, C.uintptr_t(v))
}

// ImGuiContext_GetTestEngine returns value of ImGuiContext.TestEngine
//
// Test engine user data
func (self *Context) TestEngine() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiContext_GetTestEngine(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetContextName sets value of ImGuiContext.ContextName[16]
//
// Storage for a context name (to facilitate debugging multi-context setups)
func (self Context) SetContextName(v *[16]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetContextName(selfArg, (*C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = rune(vV)
	}
}

// ImGuiContext_GetContextName returns value of ImGuiContext.ContextName[16]
//
// Storage for a context name (to facilitate debugging multi-context setups)
func (self *Context) ContextName() [16]rune {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [16]rune {
		result := [16]rune{}
		resultMirr := C.wrap_ImGuiContext_GetContextName(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		for i := range result {
			result[i] = rune(C.cimgui_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiContext_SetInputEventsQueue sets value of ImGuiContext.InputEventsQueue
//
//	// Inputs
//
// Input events which will be trickled/written into IO structure.
func (self Context) SetInputEventsQueue(v vectors.Vector[InputEvent]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiInputEvent)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiInputEvent](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsQueue(selfArg, *vVecArg)
}

// ImGuiContext_GetInputEventsQueue returns value of ImGuiContext.InputEventsQueue
//
//	// Inputs
//
// Input events which will be trickled/written into IO structure.
func (self *Context) InputEventsQueue() vectors.Vector[InputEvent] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetInputEventsQueue(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetInputEventsQueue(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewInputEventFromC(C.wrap_ImGuiContext_GetInputEventsQueue(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetInputEventsTrail sets value of ImGuiContext.InputEventsTrail
//
// Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.
func (self Context) SetInputEventsTrail(v vectors.Vector[InputEvent]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiInputEvent)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiInputEvent](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsTrail(selfArg, *vVecArg)
}

// ImGuiContext_GetInputEventsTrail returns value of ImGuiContext.InputEventsTrail
//
// Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.
func (self *Context) InputEventsTrail() vectors.Vector[InputEvent] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetInputEventsTrail(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetInputEventsTrail(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewInputEventFromC(C.wrap_ImGuiContext_GetInputEventsTrail(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetInputEventsNextMouseSource sets value of ImGuiContext.InputEventsNextMouseSource
func (self Context) SetInputEventsNextMouseSource(v MouseSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsNextMouseSource(selfArg, C.ImGuiMouseSource(v))
}

// ImGuiContext_GetInputEventsNextMouseSource returns value of ImGuiContext.InputEventsNextMouseSource
func (self *Context) InputEventsNextMouseSource() MouseSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiContext_GetInputEventsNextMouseSource(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetInputEventsNextEventId sets value of ImGuiContext.InputEventsNextEventId
func (self Context) SetInputEventsNextEventId(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputEventsNextEventId(selfArg, C.ImU32(v))
}

// ImGuiContext_GetInputEventsNextEventId returns value of ImGuiContext.InputEventsNextEventId
func (self *Context) InputEventsNextEventId() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiContext_GetInputEventsNextEventId(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetCurrentWindowStack sets value of ImGuiContext.CurrentWindowStack
func (self Context) SetCurrentWindowStack(v vectors.Vector[WindowStackData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiWindowStackData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiWindowStackData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentWindowStack(selfArg, *vVecArg)
}

// ImGuiContext_GetCurrentWindowStack returns value of ImGuiContext.CurrentWindowStack
func (self *Context) CurrentWindowStack() vectors.Vector[WindowStackData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetCurrentWindowStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetCurrentWindowStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewWindowStackDataFromC(C.wrap_ImGuiContext_GetCurrentWindowStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetWindowsById sets value of ImGuiContext.WindowsById
//
// Map window's ImGuiID to ImGuiWindow*
func (self Context) SetWindowsById(v Storage) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowsById(selfArg, internal.ReinterpretCast[C.ImGuiStorage](vArg))
}

// ImGuiContext_GetWindowsById returns value of ImGuiContext.WindowsById
//
// Map window's ImGuiID to ImGuiWindow*
func (self *Context) WindowsById() Storage {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewStorageFromC(func() *C.ImGuiStorage {
		result := C.wrap_ImGuiContext_GetWindowsById(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetWindowsActiveCount sets value of ImGuiContext.WindowsActiveCount
//
// Number of unique windows submitted by frame
func (self Context) SetWindowsActiveCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowsActiveCount(selfArg, C.int(v))
}

// ImGuiContext_GetWindowsActiveCount returns value of ImGuiContext.WindowsActiveCount
//
// Number of unique windows submitted by frame
func (self *Context) WindowsActiveCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWindowsActiveCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWindowsHoverPadding sets value of ImGuiContext.WindowsHoverPadding
//
// Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING).
func (self Context) SetWindowsHoverPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowsHoverPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetWindowsHoverPadding returns value of ImGuiContext.WindowsHoverPadding
//
// Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING).
func (self *Context) WindowsHoverPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetWindowsHoverPadding(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetDebugBreakInWindow sets value of ImGuiContext.DebugBreakInWindow
//
// Set to break in Begin() call.
func (self Context) SetDebugBreakInWindow(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugBreakInWindow(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDebugBreakInWindow returns value of ImGuiContext.DebugBreakInWindow
//
// Set to break in Begin() call.
func (self *Context) DebugBreakInWindow() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDebugBreakInWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetCurrentWindow sets value of ImGuiContext.CurrentWindow
//
// Window being drawn into
func (self Context) SetCurrentWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetCurrentWindow returns value of ImGuiContext.CurrentWindow
//
// Window being drawn into
func (self *Context) CurrentWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetCurrentWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoveredWindow sets value of ImGuiContext.HoveredWindow
//
// Window the mouse is hovering. Will typically catch mouse inputs.
func (self Context) SetHoveredWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetHoveredWindow returns value of ImGuiContext.HoveredWindow
//
// Window the mouse is hovering. Will typically catch mouse inputs.
func (self *Context) HoveredWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetHoveredWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoveredWindowUnderMovingWindow sets value of ImGuiContext.HoveredWindowUnderMovingWindow
//
// Hovered window ignoring MovingWindow. Only set if MovingWindow is set.
func (self Context) SetHoveredWindowUnderMovingWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredWindowUnderMovingWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetHoveredWindowUnderMovingWindow returns value of ImGuiContext.HoveredWindowUnderMovingWindow
//
// Hovered window ignoring MovingWindow. Only set if MovingWindow is set.
func (self *Context) HoveredWindowUnderMovingWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetHoveredWindowUnderMovingWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoveredWindowBeforeClear sets value of ImGuiContext.HoveredWindowBeforeClear
//
// Window the mouse is hovering. Filled even with _NoMouse. This is currently useful for multi-context compositors.
func (self Context) SetHoveredWindowBeforeClear(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredWindowBeforeClear(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetHoveredWindowBeforeClear returns value of ImGuiContext.HoveredWindowBeforeClear
//
// Window the mouse is hovering. Filled even with _NoMouse. This is currently useful for multi-context compositors.
func (self *Context) HoveredWindowBeforeClear() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetHoveredWindowBeforeClear(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetMovingWindow sets value of ImGuiContext.MovingWindow
//
// Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindowDockTree.
func (self Context) SetMovingWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMovingWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetMovingWindow returns value of ImGuiContext.MovingWindow
//
// Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindowDockTree.
func (self *Context) MovingWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetMovingWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWheelingWindow sets value of ImGuiContext.WheelingWindow
//
// Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
func (self Context) SetWheelingWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetWheelingWindow returns value of ImGuiContext.WheelingWindow
//
// Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
func (self *Context) WheelingWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetWheelingWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWheelingWindowRefMousePos sets value of ImGuiContext.WheelingWindowRefMousePos
func (self Context) SetWheelingWindowRefMousePos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowRefMousePos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetWheelingWindowRefMousePos returns value of ImGuiContext.WheelingWindowRefMousePos
func (self *Context) WheelingWindowRefMousePos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetWheelingWindowRefMousePos(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetWheelingWindowStartFrame sets value of ImGuiContext.WheelingWindowStartFrame
//
// This may be set one frame before WheelingWindow is != NULL
func (self Context) SetWheelingWindowStartFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowStartFrame(selfArg, C.int(v))
}

// ImGuiContext_GetWheelingWindowStartFrame returns value of ImGuiContext.WheelingWindowStartFrame
//
// This may be set one frame before WheelingWindow is != NULL
func (self *Context) WheelingWindowStartFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWheelingWindowStartFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWheelingWindowScrolledFrame sets value of ImGuiContext.WheelingWindowScrolledFrame
func (self Context) SetWheelingWindowScrolledFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowScrolledFrame(selfArg, C.int(v))
}

// ImGuiContext_GetWheelingWindowScrolledFrame returns value of ImGuiContext.WheelingWindowScrolledFrame
func (self *Context) WheelingWindowScrolledFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWheelingWindowScrolledFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWheelingWindowReleaseTimer sets value of ImGuiContext.WheelingWindowReleaseTimer
func (self Context) SetWheelingWindowReleaseTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowReleaseTimer(selfArg, C.float(v))
}

// ImGuiContext_GetWheelingWindowReleaseTimer returns value of ImGuiContext.WheelingWindowReleaseTimer
func (self *Context) WheelingWindowReleaseTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetWheelingWindowReleaseTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWheelingWindowWheelRemainder sets value of ImGuiContext.WheelingWindowWheelRemainder
func (self Context) SetWheelingWindowWheelRemainder(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingWindowWheelRemainder(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetWheelingWindowWheelRemainder returns value of ImGuiContext.WheelingWindowWheelRemainder
func (self *Context) WheelingWindowWheelRemainder() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetWheelingWindowWheelRemainder(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetWheelingAxisAvg sets value of ImGuiContext.WheelingAxisAvg
func (self Context) SetWheelingAxisAvg(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWheelingAxisAvg(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetWheelingAxisAvg returns value of ImGuiContext.WheelingAxisAvg
func (self *Context) WheelingAxisAvg() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetWheelingAxisAvg(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetDebugDrawIdConflicts sets value of ImGuiContext.DebugDrawIdConflicts
//
//	// Item/widgets state and tracking information
//
// Set when we detect multiple items with the same identifier
func (self Context) SetDebugDrawIdConflicts(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugDrawIdConflicts(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDebugDrawIdConflicts returns value of ImGuiContext.DebugDrawIdConflicts
//
//	// Item/widgets state and tracking information
//
// Set when we detect multiple items with the same identifier
func (self *Context) DebugDrawIdConflicts() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDebugDrawIdConflicts(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugHookIdInfo sets value of ImGuiContext.DebugHookIdInfo
//
// Will call core hooks: DebugHookIdInfo() from GetID functions, used by ID Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]
func (self Context) SetDebugHookIdInfo(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugHookIdInfo(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDebugHookIdInfo returns value of ImGuiContext.DebugHookIdInfo
//
// Will call core hooks: DebugHookIdInfo() from GetID functions, used by ID Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]
func (self *Context) DebugHookIdInfo() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDebugHookIdInfo(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetHoveredId sets value of ImGuiContext.HoveredId
//
// Hovered widget, filled during the frame
func (self Context) SetHoveredId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetHoveredId returns value of ImGuiContext.HoveredId
//
// Hovered widget, filled during the frame
func (self *Context) HoveredId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetHoveredId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetHoveredIdPreviousFrame sets value of ImGuiContext.HoveredIdPreviousFrame
func (self Context) SetHoveredIdPreviousFrame(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdPreviousFrame(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetHoveredIdPreviousFrame returns value of ImGuiContext.HoveredIdPreviousFrame
func (self *Context) HoveredIdPreviousFrame() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetHoveredIdPreviousFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetHoveredIdPreviousFrameItemCount sets value of ImGuiContext.HoveredIdPreviousFrameItemCount
//
// Count numbers of items using the same ID as last frame's hovered id
func (self Context) SetHoveredIdPreviousFrameItemCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdPreviousFrameItemCount(selfArg, C.int(v))
}

// ImGuiContext_GetHoveredIdPreviousFrameItemCount returns value of ImGuiContext.HoveredIdPreviousFrameItemCount
//
// Count numbers of items using the same ID as last frame's hovered id
func (self *Context) HoveredIdPreviousFrameItemCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetHoveredIdPreviousFrameItemCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoveredIdTimer sets value of ImGuiContext.HoveredIdTimer
//
// Measure contiguous hovering time
func (self Context) SetHoveredIdTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdTimer(selfArg, C.float(v))
}

// ImGuiContext_GetHoveredIdTimer returns value of ImGuiContext.HoveredIdTimer
//
// Measure contiguous hovering time
func (self *Context) HoveredIdTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoveredIdTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoveredIdNotActiveTimer sets value of ImGuiContext.HoveredIdNotActiveTimer
//
// Measure contiguous hovering time where the item has not been active
func (self Context) SetHoveredIdNotActiveTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdNotActiveTimer(selfArg, C.float(v))
}

// ImGuiContext_GetHoveredIdNotActiveTimer returns value of ImGuiContext.HoveredIdNotActiveTimer
//
// Measure contiguous hovering time where the item has not been active
func (self *Context) HoveredIdNotActiveTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoveredIdNotActiveTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoveredIdAllowOverlap sets value of ImGuiContext.HoveredIdAllowOverlap
func (self Context) SetHoveredIdAllowOverlap(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdAllowOverlap(selfArg, C.bool(v))
}

// ImGuiContext_GetHoveredIdAllowOverlap returns value of ImGuiContext.HoveredIdAllowOverlap
func (self *Context) HoveredIdAllowOverlap() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetHoveredIdAllowOverlap(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetHoveredIdIsDisabled sets value of ImGuiContext.HoveredIdIsDisabled
//
// At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.
func (self Context) SetHoveredIdIsDisabled(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoveredIdIsDisabled(selfArg, C.bool(v))
}

// ImGuiContext_GetHoveredIdIsDisabled returns value of ImGuiContext.HoveredIdIsDisabled
//
// At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.
func (self *Context) HoveredIdIsDisabled() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetHoveredIdIsDisabled(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetItemUnclipByLog sets value of ImGuiContext.ItemUnclipByLog
//
// Disable ItemAdd() clipping, essentially a memory-locality friendly copy of LogEnabled
func (self Context) SetItemUnclipByLog(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetItemUnclipByLog(selfArg, C.bool(v))
}

// ImGuiContext_GetItemUnclipByLog returns value of ImGuiContext.ItemUnclipByLog
//
// Disable ItemAdd() clipping, essentially a memory-locality friendly copy of LogEnabled
func (self *Context) ItemUnclipByLog() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetItemUnclipByLog(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveId sets value of ImGuiContext.ActiveId
//
// Active widget
func (self Context) SetActiveId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetActiveId returns value of ImGuiContext.ActiveId
//
// Active widget
func (self *Context) ActiveId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetActiveId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetActiveIdIsAlive sets value of ImGuiContext.ActiveIdIsAlive
//
// Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
func (self Context) SetActiveIdIsAlive(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdIsAlive(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetActiveIdIsAlive returns value of ImGuiContext.ActiveIdIsAlive
//
// Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
func (self *Context) ActiveIdIsAlive() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetActiveIdIsAlive(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetActiveIdTimer sets value of ImGuiContext.ActiveIdTimer
func (self Context) SetActiveIdTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdTimer(selfArg, C.float(v))
}

// ImGuiContext_GetActiveIdTimer returns value of ImGuiContext.ActiveIdTimer
func (self *Context) ActiveIdTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetActiveIdTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetActiveIdIsJustActivated sets value of ImGuiContext.ActiveIdIsJustActivated
//
// Set at the time of activation for one frame
func (self Context) SetActiveIdIsJustActivated(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdIsJustActivated(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdIsJustActivated returns value of ImGuiContext.ActiveIdIsJustActivated
//
// Set at the time of activation for one frame
func (self *Context) ActiveIdIsJustActivated() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdIsJustActivated(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdAllowOverlap sets value of ImGuiContext.ActiveIdAllowOverlap
//
// Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
func (self Context) SetActiveIdAllowOverlap(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdAllowOverlap(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdAllowOverlap returns value of ImGuiContext.ActiveIdAllowOverlap
//
// Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
func (self *Context) ActiveIdAllowOverlap() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdAllowOverlap(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdNoClearOnFocusLoss sets value of ImGuiContext.ActiveIdNoClearOnFocusLoss
//
// Disable losing active id if the active id window gets unfocused.
func (self Context) SetActiveIdNoClearOnFocusLoss(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdNoClearOnFocusLoss(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdNoClearOnFocusLoss returns value of ImGuiContext.ActiveIdNoClearOnFocusLoss
//
// Disable losing active id if the active id window gets unfocused.
func (self *Context) ActiveIdNoClearOnFocusLoss() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdNoClearOnFocusLoss(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdHasBeenPressedBefore sets value of ImGuiContext.ActiveIdHasBeenPressedBefore
//
// Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
func (self Context) SetActiveIdHasBeenPressedBefore(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdHasBeenPressedBefore(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdHasBeenPressedBefore returns value of ImGuiContext.ActiveIdHasBeenPressedBefore
//
// Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
func (self *Context) ActiveIdHasBeenPressedBefore() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdHasBeenPressedBefore(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdHasBeenEditedBefore sets value of ImGuiContext.ActiveIdHasBeenEditedBefore
//
// Was the value associated to the widget Edited over the course of the Active state.
func (self Context) SetActiveIdHasBeenEditedBefore(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdHasBeenEditedBefore(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdHasBeenEditedBefore returns value of ImGuiContext.ActiveIdHasBeenEditedBefore
//
// Was the value associated to the widget Edited over the course of the Active state.
func (self *Context) ActiveIdHasBeenEditedBefore() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdHasBeenEditedBefore(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdHasBeenEditedThisFrame sets value of ImGuiContext.ActiveIdHasBeenEditedThisFrame
func (self Context) SetActiveIdHasBeenEditedThisFrame(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdHasBeenEditedThisFrame(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdHasBeenEditedThisFrame returns value of ImGuiContext.ActiveIdHasBeenEditedThisFrame
func (self *Context) ActiveIdHasBeenEditedThisFrame() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdHasBeenEditedThisFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdFromShortcut sets value of ImGuiContext.ActiveIdFromShortcut
func (self Context) SetActiveIdFromShortcut(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdFromShortcut(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdFromShortcut returns value of ImGuiContext.ActiveIdFromShortcut
func (self *Context) ActiveIdFromShortcut() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdFromShortcut(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdMouseButton sets value of ImGuiContext.ActiveIdMouseButton
func (self Context) SetActiveIdMouseButton(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdMouseButton(selfArg, C.int(v))
}

// ImGuiContext_GetActiveIdMouseButton returns value of ImGuiContext.ActiveIdMouseButton
func (self *Context) ActiveIdMouseButton() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetActiveIdMouseButton(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetActiveIdClickOffset sets value of ImGuiContext.ActiveIdClickOffset
//
// Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
func (self Context) SetActiveIdClickOffset(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdClickOffset(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetActiveIdClickOffset returns value of ImGuiContext.ActiveIdClickOffset
//
// Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
func (self *Context) ActiveIdClickOffset() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetActiveIdClickOffset(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetActiveIdWindow sets value of ImGuiContext.ActiveIdWindow
func (self Context) SetActiveIdWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetActiveIdWindow returns value of ImGuiContext.ActiveIdWindow
func (self *Context) ActiveIdWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetActiveIdWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetActiveIdSource sets value of ImGuiContext.ActiveIdSource
//
// Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad
func (self Context) SetActiveIdSource(v InputSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdSource(selfArg, C.ImGuiInputSource(v))
}

// ImGuiContext_GetActiveIdSource returns value of ImGuiContext.ActiveIdSource
//
// Activating source: ImGuiInputSource_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad
func (self *Context) ActiveIdSource() InputSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputSource(C.wrap_ImGuiContext_GetActiveIdSource(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetActiveIdPreviousFrame sets value of ImGuiContext.ActiveIdPreviousFrame
func (self Context) SetActiveIdPreviousFrame(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrame(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetActiveIdPreviousFrame returns value of ImGuiContext.ActiveIdPreviousFrame
func (self *Context) ActiveIdPreviousFrame() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetActiveIdPreviousFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetActiveIdPreviousFrameIsAlive sets value of ImGuiContext.ActiveIdPreviousFrameIsAlive
func (self Context) SetActiveIdPreviousFrameIsAlive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrameIsAlive(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdPreviousFrameIsAlive returns value of ImGuiContext.ActiveIdPreviousFrameIsAlive
func (self *Context) ActiveIdPreviousFrameIsAlive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdPreviousFrameIsAlive(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdPreviousFrameHasBeenEditedBefore sets value of ImGuiContext.ActiveIdPreviousFrameHasBeenEditedBefore
func (self Context) SetActiveIdPreviousFrameHasBeenEditedBefore(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrameHasBeenEditedBefore(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdPreviousFrameHasBeenEditedBefore returns value of ImGuiContext.ActiveIdPreviousFrameHasBeenEditedBefore
func (self *Context) ActiveIdPreviousFrameHasBeenEditedBefore() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdPreviousFrameHasBeenEditedBefore(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetActiveIdPreviousFrameWindow sets value of ImGuiContext.ActiveIdPreviousFrameWindow
func (self Context) SetActiveIdPreviousFrameWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdPreviousFrameWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetActiveIdPreviousFrameWindow returns value of ImGuiContext.ActiveIdPreviousFrameWindow
func (self *Context) ActiveIdPreviousFrameWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetActiveIdPreviousFrameWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLastActiveId sets value of ImGuiContext.LastActiveId
//
// Store the last non-zero ActiveId, useful for animation.
func (self Context) SetLastActiveId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastActiveId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetLastActiveId returns value of ImGuiContext.LastActiveId
//
// Store the last non-zero ActiveId, useful for animation.
func (self *Context) LastActiveId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetLastActiveId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetLastActiveIdTimer sets value of ImGuiContext.LastActiveIdTimer
//
// Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.
func (self Context) SetLastActiveIdTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastActiveIdTimer(selfArg, C.float(v))
}

// ImGuiContext_GetLastActiveIdTimer returns value of ImGuiContext.LastActiveIdTimer
//
// Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.
func (self *Context) LastActiveIdTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetLastActiveIdTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLastKeyModsChangeTime sets value of ImGuiContext.LastKeyModsChangeTime
//
//	// Key/Input Ownership + Shortcut Routing system
//	// - The idea is that instead of "eating" a given key, we can link to an owner.
//	// - Input query can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
//	// - Routing is requested ahead of time for a given chord (Key + Mods) and granted in NewFrame().
//
// Record the last time key mods changed (affect repeat delay when using shortcut logic)
func (self Context) SetLastKeyModsChangeTime(v float64) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastKeyModsChangeTime(selfArg, C.double(v))
}

// ImGuiContext_GetLastKeyModsChangeTime returns value of ImGuiContext.LastKeyModsChangeTime
//
//	// Key/Input Ownership + Shortcut Routing system
//	// - The idea is that instead of "eating" a given key, we can link to an owner.
//	// - Input query can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
//	// - Routing is requested ahead of time for a given chord (Key + Mods) and granted in NewFrame().
//
// Record the last time key mods changed (affect repeat delay when using shortcut logic)
func (self *Context) LastKeyModsChangeTime() float64 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImGuiContext_GetLastKeyModsChangeTime(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLastKeyModsChangeFromNoneTime sets value of ImGuiContext.LastKeyModsChangeFromNoneTime
//
// Record the last time key mods changed away from being 0 (affect repeat delay when using shortcut logic)
func (self Context) SetLastKeyModsChangeFromNoneTime(v float64) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastKeyModsChangeFromNoneTime(selfArg, C.double(v))
}

// ImGuiContext_GetLastKeyModsChangeFromNoneTime returns value of ImGuiContext.LastKeyModsChangeFromNoneTime
//
// Record the last time key mods changed away from being 0 (affect repeat delay when using shortcut logic)
func (self *Context) LastKeyModsChangeFromNoneTime() float64 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImGuiContext_GetLastKeyModsChangeFromNoneTime(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLastKeyboardKeyPressTime sets value of ImGuiContext.LastKeyboardKeyPressTime
//
// Record the last time a keyboard key (ignore mouse/gamepad ones) was pressed.
func (self Context) SetLastKeyboardKeyPressTime(v float64) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastKeyboardKeyPressTime(selfArg, C.double(v))
}

// ImGuiContext_GetLastKeyboardKeyPressTime returns value of ImGuiContext.LastKeyboardKeyPressTime
//
// Record the last time a keyboard key (ignore mouse/gamepad ones) was pressed.
func (self *Context) LastKeyboardKeyPressTime() float64 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImGuiContext_GetLastKeyboardKeyPressTime(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetKeysOwnerData sets value of ImGuiContext.KeysOwnerData[ImGuiKey_NamedKey_COUNT]
func (self Context) SetKeysOwnerData(v *[154]KeyOwnerData) {
	vArg := make([]C.ImGuiKeyOwnerData, len(v))
	for i, vV := range v {
		vVArg, _ := vV.C()
		vArg[i] = internal.ReinterpretCast[C.ImGuiKeyOwnerData](vVArg)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetKeysOwnerData(selfArg, (*C.ImGuiKeyOwnerData)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = *NewKeyOwnerDataFromC(func() *C.ImGuiKeyOwnerData { result := vV; return &result }())
	}
}

// ImGuiContext_GetKeysOwnerData returns value of ImGuiContext.KeysOwnerData[ImGuiKey_NamedKey_COUNT]
func (self *Context) KeysOwnerData() [154]KeyOwnerData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [154]KeyOwnerData {
		result := [154]KeyOwnerData{}
		resultMirr := C.wrap_ImGuiContext_GetKeysOwnerData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		for i := range result {
			result[i] = *NewKeyOwnerDataFromC(func() *C.ImGuiKeyOwnerData {
				result := C.cimgui_ImGuiKeyOwnerData_GetAtIdx(resultMirr, C.int(i))
				return &result
			}())
		}

		return result
	}()
}

// ImGuiContext_SetKeysRoutingTable sets value of ImGuiContext.KeysRoutingTable
func (self Context) SetKeysRoutingTable(v KeyRoutingTable) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetKeysRoutingTable(selfArg, internal.ReinterpretCast[C.ImGuiKeyRoutingTable](vArg))
}

// ImGuiContext_GetKeysRoutingTable returns value of ImGuiContext.KeysRoutingTable
func (self *Context) KeysRoutingTable() KeyRoutingTable {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyRoutingTableFromC(func() *C.ImGuiKeyRoutingTable {
		result := C.wrap_ImGuiContext_GetKeysRoutingTable(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetActiveIdUsingNavDirMask sets value of ImGuiContext.ActiveIdUsingNavDirMask
//
// Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
func (self Context) SetActiveIdUsingNavDirMask(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdUsingNavDirMask(selfArg, C.ImU32(v))
}

// ImGuiContext_GetActiveIdUsingNavDirMask returns value of ImGuiContext.ActiveIdUsingNavDirMask
//
// Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
func (self *Context) ActiveIdUsingNavDirMask() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiContext_GetActiveIdUsingNavDirMask(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetActiveIdUsingAllKeyboardKeys sets value of ImGuiContext.ActiveIdUsingAllKeyboardKeys
//
// Active widget will want to read all keyboard keys inputs. (this is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations)
func (self Context) SetActiveIdUsingAllKeyboardKeys(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetActiveIdUsingAllKeyboardKeys(selfArg, C.bool(v))
}

// ImGuiContext_GetActiveIdUsingAllKeyboardKeys returns value of ImGuiContext.ActiveIdUsingAllKeyboardKeys
//
// Active widget will want to read all keyboard keys inputs. (this is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations)
func (self *Context) ActiveIdUsingAllKeyboardKeys() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetActiveIdUsingAllKeyboardKeys(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDebugBreakInShortcutRouting sets value of ImGuiContext.DebugBreakInShortcutRouting
//
// Set to break in SetShortcutRouting()/Shortcut() calls.
func (self Context) SetDebugBreakInShortcutRouting(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugBreakInShortcutRouting(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiContext_GetDebugBreakInShortcutRouting returns value of ImGuiContext.DebugBreakInShortcutRouting
//
// Set to break in SetShortcutRouting()/Shortcut() calls.
func (self *Context) DebugBreakInShortcutRouting() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiContext_GetDebugBreakInShortcutRouting(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetCurrentFocusScopeId sets value of ImGuiContext.CurrentFocusScopeId
//
//	// Next window/item data
//
// Value for currently appending items == g.FocusScopeStack.back(). Not to be mistaken with g.NavFocusScopeId.
func (self Context) SetCurrentFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetCurrentFocusScopeId returns value of ImGuiContext.CurrentFocusScopeId
//
//	// Next window/item data
//
// Value for currently appending items == g.FocusScopeStack.back(). Not to be mistaken with g.NavFocusScopeId.
func (self *Context) CurrentFocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetCurrentFocusScopeId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetCurrentItemFlags sets value of ImGuiContext.CurrentItemFlags
//
// Value for currently appending items == g.ItemFlagsStack.back()
func (self Context) SetCurrentItemFlags(v ItemFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentItemFlags(selfArg, C.ImGuiItemFlags(v))
}

// ImGuiContext_GetCurrentItemFlags returns value of ImGuiContext.CurrentItemFlags
//
// Value for currently appending items == g.ItemFlagsStack.back()
func (self *Context) CurrentItemFlags() ItemFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiContext_GetCurrentItemFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugLocateId sets value of ImGuiContext.DebugLocateId
//
// Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location
func (self Context) SetDebugLocateId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLocateId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDebugLocateId returns value of ImGuiContext.DebugLocateId
//
// Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location
func (self *Context) DebugLocateId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDebugLocateId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNextItemData sets value of ImGuiContext.NextItemData
//
// Storage for SetNextItem** functions
func (self Context) SetNextItemData(v NextItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNextItemData(selfArg, internal.ReinterpretCast[C.ImGuiNextItemData](vArg))
}

// ImGuiContext_GetNextItemData returns value of ImGuiContext.NextItemData
//
// Storage for SetNextItem** functions
func (self *Context) NextItemData() NextItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewNextItemDataFromC(func() *C.ImGuiNextItemData {
		result := C.wrap_ImGuiContext_GetNextItemData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetLastItemData sets value of ImGuiContext.LastItemData
//
// Storage for last submitted item (setup by ItemAdd)
func (self Context) SetLastItemData(v LastItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLastItemData(selfArg, internal.ReinterpretCast[C.ImGuiLastItemData](vArg))
}

// ImGuiContext_GetLastItemData returns value of ImGuiContext.LastItemData
//
// Storage for last submitted item (setup by ItemAdd)
func (self *Context) LastItemData() LastItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewLastItemDataFromC(func() *C.ImGuiLastItemData {
		result := C.wrap_ImGuiContext_GetLastItemData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNextWindowData sets value of ImGuiContext.NextWindowData
//
// Storage for SetNextWindow** functions
func (self Context) SetNextWindowData(v NextWindowData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNextWindowData(selfArg, internal.ReinterpretCast[C.ImGuiNextWindowData](vArg))
}

// ImGuiContext_GetNextWindowData returns value of ImGuiContext.NextWindowData
//
// Storage for SetNextWindow** functions
func (self *Context) NextWindowData() NextWindowData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewNextWindowDataFromC(func() *C.ImGuiNextWindowData {
		result := C.wrap_ImGuiContext_GetNextWindowData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugShowGroupRects sets value of ImGuiContext.DebugShowGroupRects
func (self Context) SetDebugShowGroupRects(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugShowGroupRects(selfArg, C.bool(v))
}

// ImGuiContext_GetDebugShowGroupRects returns value of ImGuiContext.DebugShowGroupRects
func (self *Context) DebugShowGroupRects() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDebugShowGroupRects(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDebugFlashStyleColorIdx sets value of ImGuiContext.DebugFlashStyleColorIdx
//
//	// Shared stacks
//
// (Keep close to ColorStack to share cache line)
func (self Context) SetDebugFlashStyleColorIdx(v Col) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugFlashStyleColorIdx(selfArg, C.ImGuiCol(v))
}

// ImGuiContext_GetDebugFlashStyleColorIdx returns value of ImGuiContext.DebugFlashStyleColorIdx
//
//	// Shared stacks
//
// (Keep close to ColorStack to share cache line)
func (self *Context) DebugFlashStyleColorIdx() Col {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Col(C.wrap_ImGuiContext_GetDebugFlashStyleColorIdx(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetColorStack sets value of ImGuiContext.ColorStack
//
// Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()
func (self Context) SetColorStack(v vectors.Vector[ColorMod]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiColorMod)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiColorMod](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorStack(selfArg, *vVecArg)
}

// ImGuiContext_GetColorStack returns value of ImGuiContext.ColorStack
//
// Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()
func (self *Context) ColorStack() vectors.Vector[ColorMod] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetColorStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetColorStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewColorModFromC(C.wrap_ImGuiContext_GetColorStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetStyleVarStack sets value of ImGuiContext.StyleVarStack
//
// Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()
func (self Context) SetStyleVarStack(v vectors.Vector[StyleMod]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiStyleMod)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiStyleMod](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetStyleVarStack(selfArg, *vVecArg)
}

// ImGuiContext_GetStyleVarStack returns value of ImGuiContext.StyleVarStack
//
// Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()
func (self *Context) StyleVarStack() vectors.Vector[StyleMod] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetStyleVarStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetStyleVarStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewStyleModFromC(C.wrap_ImGuiContext_GetStyleVarStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetFocusScopeStack sets value of ImGuiContext.FocusScopeStack
//
// Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()
func (self Context) SetFocusScopeStack(v vectors.Vector[FocusScopeData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiFocusScopeData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiFocusScopeData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFocusScopeStack(selfArg, *vVecArg)
}

// ImGuiContext_GetFocusScopeStack returns value of ImGuiContext.FocusScopeStack
//
// Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()
func (self *Context) FocusScopeStack() vectors.Vector[FocusScopeData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetFocusScopeStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetFocusScopeStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewFocusScopeDataFromC(C.wrap_ImGuiContext_GetFocusScopeStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetItemFlagsStack sets value of ImGuiContext.ItemFlagsStack
//
// Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()
func (self Context) SetItemFlagsStack(v vectors.Vector[ItemFlags]) {
	vData := v.Data

	vVecArg := new(C.ImVector_ImGuiItemFlags)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = (*C.ImGuiItemFlags)(vData)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetItemFlagsStack(selfArg, *vVecArg)
}

// ImGuiContext_GetItemFlagsStack returns value of ImGuiContext.ItemFlagsStack
//
// Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()
func (self *Context) ItemFlagsStack() vectors.Vector[ItemFlags] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetItemFlagsStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetItemFlagsStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, (*ItemFlags)(C.wrap_ImGuiContext_GetItemFlagsStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetGroupStack sets value of ImGuiContext.GroupStack
//
// Stack for BeginGroup()/EndGroup() - not inherited by Begin()
func (self Context) SetGroupStack(v vectors.Vector[GroupData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiGroupData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiGroupData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetGroupStack(selfArg, *vVecArg)
}

// ImGuiContext_GetGroupStack returns value of ImGuiContext.GroupStack
//
// Stack for BeginGroup()/EndGroup() - not inherited by Begin()
func (self *Context) GroupStack() vectors.Vector[GroupData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetGroupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetGroupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewGroupDataFromC(C.wrap_ImGuiContext_GetGroupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetOpenPopupStack sets value of ImGuiContext.OpenPopupStack
//
// Which popups are open (persistent)
func (self Context) SetOpenPopupStack(v vectors.Vector[PopupData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiPopupData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiPopupData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetOpenPopupStack(selfArg, *vVecArg)
}

// ImGuiContext_GetOpenPopupStack returns value of ImGuiContext.OpenPopupStack
//
// Which popups are open (persistent)
func (self *Context) OpenPopupStack() vectors.Vector[PopupData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetOpenPopupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetOpenPopupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewPopupDataFromC(C.wrap_ImGuiContext_GetOpenPopupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetBeginPopupStack sets value of ImGuiContext.BeginPopupStack
//
// Which level of BeginPopup() we are in (reset every frame)
func (self Context) SetBeginPopupStack(v vectors.Vector[PopupData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiPopupData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiPopupData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetBeginPopupStack(selfArg, *vVecArg)
}

// ImGuiContext_GetBeginPopupStack returns value of ImGuiContext.BeginPopupStack
//
// Which level of BeginPopup() we are in (reset every frame)
func (self *Context) BeginPopupStack() vectors.Vector[PopupData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetBeginPopupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetBeginPopupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewPopupDataFromC(C.wrap_ImGuiContext_GetBeginPopupStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetTreeNodeStack sets value of ImGuiContext.TreeNodeStack
//
// Stack for TreeNode()
func (self Context) SetTreeNodeStack(v vectors.Vector[TreeNodeStackData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiTreeNodeStackData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiTreeNodeStackData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTreeNodeStack(selfArg, *vVecArg)
}

// ImGuiContext_GetTreeNodeStack returns value of ImGuiContext.TreeNodeStack
//
// Stack for TreeNode()
func (self *Context) TreeNodeStack() vectors.Vector[TreeNodeStackData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetTreeNodeStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetTreeNodeStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewTreeNodeStackDataFromC(C.wrap_ImGuiContext_GetTreeNodeStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetCurrentViewport sets value of ImGuiContext.CurrentViewport
//
// We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()
func (self Context) SetCurrentViewport(v *ViewportP) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentViewport(selfArg, internal.ReinterpretCast[*C.ImGuiViewportP](vArg))
}

// ImGuiContext_GetCurrentViewport returns value of ImGuiContext.CurrentViewport
//
// We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()
func (self *Context) CurrentViewport() *ViewportP {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewViewportPFromC(C.wrap_ImGuiContext_GetCurrentViewport(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetMouseViewport sets value of ImGuiContext.MouseViewport
func (self Context) SetMouseViewport(v *ViewportP) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseViewport(selfArg, internal.ReinterpretCast[*C.ImGuiViewportP](vArg))
}

// ImGuiContext_GetMouseViewport returns value of ImGuiContext.MouseViewport
func (self *Context) MouseViewport() *ViewportP {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewViewportPFromC(C.wrap_ImGuiContext_GetMouseViewport(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetMouseLastHoveredViewport sets value of ImGuiContext.MouseLastHoveredViewport
//
// Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.
func (self Context) SetMouseLastHoveredViewport(v *ViewportP) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseLastHoveredViewport(selfArg, internal.ReinterpretCast[*C.ImGuiViewportP](vArg))
}

// ImGuiContext_GetMouseLastHoveredViewport returns value of ImGuiContext.MouseLastHoveredViewport
//
// Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.
func (self *Context) MouseLastHoveredViewport() *ViewportP {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewViewportPFromC(C.wrap_ImGuiContext_GetMouseLastHoveredViewport(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetPlatformLastFocusedViewportId sets value of ImGuiContext.PlatformLastFocusedViewportId
func (self Context) SetPlatformLastFocusedViewportId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformLastFocusedViewportId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetPlatformLastFocusedViewportId returns value of ImGuiContext.PlatformLastFocusedViewportId
func (self *Context) PlatformLastFocusedViewportId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetPlatformLastFocusedViewportId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetFallbackMonitor sets value of ImGuiContext.FallbackMonitor
//
// Virtual monitor used as fallback if backend doesn't provide monitor information.
func (self Context) SetFallbackMonitor(v PlatformMonitor) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFallbackMonitor(selfArg, internal.ReinterpretCast[C.ImGuiPlatformMonitor](vArg))
}

// ImGuiContext_GetFallbackMonitor returns value of ImGuiContext.FallbackMonitor
//
// Virtual monitor used as fallback if backend doesn't provide monitor information.
func (self *Context) FallbackMonitor() PlatformMonitor {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewPlatformMonitorFromC(func() *C.ImGuiPlatformMonitor {
		result := C.wrap_ImGuiContext_GetFallbackMonitor(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetPlatformMonitorsFullWorkRect sets value of ImGuiContext.PlatformMonitorsFullWorkRect
//
// Bounding box of all platform monitors
func (self Context) SetPlatformMonitorsFullWorkRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformMonitorsFullWorkRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiContext_GetPlatformMonitorsFullWorkRect returns value of ImGuiContext.PlatformMonitorsFullWorkRect
//
// Bounding box of all platform monitors
func (self *Context) PlatformMonitorsFullWorkRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiContext_GetPlatformMonitorsFullWorkRect(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetViewportCreatedCount sets value of ImGuiContext.ViewportCreatedCount
//
// Unique sequential creation counter (mostly for testing/debugging)
func (self Context) SetViewportCreatedCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetViewportCreatedCount(selfArg, C.int(v))
}

// ImGuiContext_GetViewportCreatedCount returns value of ImGuiContext.ViewportCreatedCount
//
// Unique sequential creation counter (mostly for testing/debugging)
func (self *Context) ViewportCreatedCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetViewportCreatedCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetPlatformWindowsCreatedCount sets value of ImGuiContext.PlatformWindowsCreatedCount
//
// Unique sequential creation counter (mostly for testing/debugging)
func (self Context) SetPlatformWindowsCreatedCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformWindowsCreatedCount(selfArg, C.int(v))
}

// ImGuiContext_GetPlatformWindowsCreatedCount returns value of ImGuiContext.PlatformWindowsCreatedCount
//
// Unique sequential creation counter (mostly for testing/debugging)
func (self *Context) PlatformWindowsCreatedCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetPlatformWindowsCreatedCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetViewportFocusedStampCount sets value of ImGuiContext.ViewportFocusedStampCount
//
// Every time the front-most window changes, we stamp its viewport with an incrementing counter
func (self Context) SetViewportFocusedStampCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetViewportFocusedStampCount(selfArg, C.int(v))
}

// ImGuiContext_GetViewportFocusedStampCount returns value of ImGuiContext.ViewportFocusedStampCount
//
// Every time the front-most window changes, we stamp its viewport with an incrementing counter
func (self *Context) ViewportFocusedStampCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetViewportFocusedStampCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavCursorVisible sets value of ImGuiContext.NavCursorVisible
//
//	// Keyboard/Gamepad Navigation
//
// Nav focus cursor/rectangle is visible? We hide it after a mouse click. We show it after a nav move.
func (self Context) SetNavCursorVisible(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavCursorVisible(selfArg, C.bool(v))
}

// ImGuiContext_GetNavCursorVisible returns value of ImGuiContext.NavCursorVisible
//
//	// Keyboard/Gamepad Navigation
//
// Nav focus cursor/rectangle is visible? We hide it after a mouse click. We show it after a nav move.
func (self *Context) NavCursorVisible() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavCursorVisible(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavHighlightItemUnderNav sets value of ImGuiContext.NavHighlightItemUnderNav
//
// Disable mouse hovering highlight. Highlight navigation focused item instead of mouse hovered item.
func (self Context) SetNavHighlightItemUnderNav(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavHighlightItemUnderNav(selfArg, C.bool(v))
}

// ImGuiContext_GetNavHighlightItemUnderNav returns value of ImGuiContext.NavHighlightItemUnderNav
//
// Disable mouse hovering highlight. Highlight navigation focused item instead of mouse hovered item.
func (self *Context) NavHighlightItemUnderNav() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavHighlightItemUnderNav(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavMousePosDirty sets value of ImGuiContext.NavMousePosDirty
//
//	//bool                  NavDisableHighlight;                // Old name for !g.NavCursorVisible before 1.91.4 (2024/10/18). OPPOSITE VALUE (g.NavDisableHighlight == !g.NavCursorVisible)
//	//bool                  NavDisableMouseHover;               // Old name for g.NavHighlightItemUnderNav before 1.91.1 (2024/10/18) this was called When user starts using keyboard/gamepad, we hide mouse hovering highlight until mouse is touched again.
//
// When set we will update mouse position if io.ConfigNavMoveSetMousePos is set (not enabled by default)
func (self Context) SetNavMousePosDirty(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMousePosDirty(selfArg, C.bool(v))
}

// ImGuiContext_GetNavMousePosDirty returns value of ImGuiContext.NavMousePosDirty
//
//	//bool                  NavDisableHighlight;                // Old name for !g.NavCursorVisible before 1.91.4 (2024/10/18). OPPOSITE VALUE (g.NavDisableHighlight == !g.NavCursorVisible)
//	//bool                  NavDisableMouseHover;               // Old name for g.NavHighlightItemUnderNav before 1.91.1 (2024/10/18) this was called When user starts using keyboard/gamepad, we hide mouse hovering highlight until mouse is touched again.
//
// When set we will update mouse position if io.ConfigNavMoveSetMousePos is set (not enabled by default)
func (self *Context) NavMousePosDirty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMousePosDirty(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavIdIsAlive sets value of ImGuiContext.NavIdIsAlive
//
// Nav widget has been seen this frame ~~ NavRectRel is valid
func (self Context) SetNavIdIsAlive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavIdIsAlive(selfArg, C.bool(v))
}

// ImGuiContext_GetNavIdIsAlive returns value of ImGuiContext.NavIdIsAlive
//
// Nav widget has been seen this frame ~~ NavRectRel is valid
func (self *Context) NavIdIsAlive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavIdIsAlive(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavId sets value of ImGuiContext.NavId
//
// Focused item for navigation
func (self Context) SetNavId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavId returns value of ImGuiContext.NavId
//
// Focused item for navigation
func (self *Context) NavId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavWindow sets value of ImGuiContext.NavWindow
//
// Focused window for navigation. Could be called 'FocusedWindow'
func (self Context) SetNavWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetNavWindow returns value of ImGuiContext.NavWindow
//
// Focused window for navigation. Could be called 'FocusedWindow'
func (self *Context) NavWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetNavWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavFocusScopeId sets value of ImGuiContext.NavFocusScopeId
//
// Focused focus scope (e.g. selection code often wants to "clear other items" when landing on an item of the same scope)
func (self Context) SetNavFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavFocusScopeId returns value of ImGuiContext.NavFocusScopeId
//
// Focused focus scope (e.g. selection code often wants to "clear other items" when landing on an item of the same scope)
func (self *Context) NavFocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavFocusScopeId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavLayer sets value of ImGuiContext.NavLayer
//
// Focused layer (main scrolling layer, or menu/title bar layer)
func (self Context) SetNavLayer(v NavLayer) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavLayer(selfArg, C.ImGuiNavLayer(v))
}

// ImGuiContext_GetNavLayer returns value of ImGuiContext.NavLayer
//
// Focused layer (main scrolling layer, or menu/title bar layer)
func (self *Context) NavLayer() NavLayer {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NavLayer(C.wrap_ImGuiContext_GetNavLayer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavActivateId sets value of ImGuiContext.NavActivateId
//
// ~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()
func (self Context) SetNavActivateId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivateId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavActivateId returns value of ImGuiContext.NavActivateId
//
// ~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()
func (self *Context) NavActivateId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavActivateId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavActivateDownId sets value of ImGuiContext.NavActivateDownId
//
// ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0
func (self Context) SetNavActivateDownId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivateDownId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavActivateDownId returns value of ImGuiContext.NavActivateDownId
//
// ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0
func (self *Context) NavActivateDownId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavActivateDownId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavActivatePressedId sets value of ImGuiContext.NavActivatePressedId
//
// ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)
func (self Context) SetNavActivatePressedId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivatePressedId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavActivatePressedId returns value of ImGuiContext.NavActivatePressedId
//
// ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)
func (self *Context) NavActivatePressedId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavActivatePressedId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavActivateFlags sets value of ImGuiContext.NavActivateFlags
func (self Context) SetNavActivateFlags(v ActivateFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavActivateFlags(selfArg, C.ImGuiActivateFlags(v))
}

// ImGuiContext_GetNavActivateFlags returns value of ImGuiContext.NavActivateFlags
func (self *Context) NavActivateFlags() ActivateFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ActivateFlags(C.wrap_ImGuiContext_GetNavActivateFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavFocusRoute sets value of ImGuiContext.NavFocusRoute
//
// Reversed copy focus scope stack for NavId (should contains NavFocusScopeId). This essentially follow the window->ParentWindowForFocusRoute chain.
func (self Context) SetNavFocusRoute(v vectors.Vector[FocusScopeData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiFocusScopeData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiFocusScopeData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavFocusRoute(selfArg, *vVecArg)
}

// ImGuiContext_GetNavFocusRoute returns value of ImGuiContext.NavFocusRoute
//
// Reversed copy focus scope stack for NavId (should contains NavFocusScopeId). This essentially follow the window->ParentWindowForFocusRoute chain.
func (self *Context) NavFocusRoute() vectors.Vector[FocusScopeData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetNavFocusRoute(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetNavFocusRoute(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewFocusScopeDataFromC(C.wrap_ImGuiContext_GetNavFocusRoute(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetNavHighlightActivatedId sets value of ImGuiContext.NavHighlightActivatedId
func (self Context) SetNavHighlightActivatedId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavHighlightActivatedId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavHighlightActivatedId returns value of ImGuiContext.NavHighlightActivatedId
func (self *Context) NavHighlightActivatedId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavHighlightActivatedId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavHighlightActivatedTimer sets value of ImGuiContext.NavHighlightActivatedTimer
func (self Context) SetNavHighlightActivatedTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavHighlightActivatedTimer(selfArg, C.float(v))
}

// ImGuiContext_GetNavHighlightActivatedTimer returns value of ImGuiContext.NavHighlightActivatedTimer
func (self *Context) NavHighlightActivatedTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetNavHighlightActivatedTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavNextActivateId sets value of ImGuiContext.NavNextActivateId
//
// Set by ActivateItem(), queued until next frame.
func (self Context) SetNavNextActivateId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavNextActivateId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavNextActivateId returns value of ImGuiContext.NavNextActivateId
//
// Set by ActivateItem(), queued until next frame.
func (self *Context) NavNextActivateId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavNextActivateId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavNextActivateFlags sets value of ImGuiContext.NavNextActivateFlags
func (self Context) SetNavNextActivateFlags(v ActivateFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavNextActivateFlags(selfArg, C.ImGuiActivateFlags(v))
}

// ImGuiContext_GetNavNextActivateFlags returns value of ImGuiContext.NavNextActivateFlags
func (self *Context) NavNextActivateFlags() ActivateFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ActivateFlags(C.wrap_ImGuiContext_GetNavNextActivateFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavInputSource sets value of ImGuiContext.NavInputSource
//
// Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse
func (self Context) SetNavInputSource(v InputSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInputSource(selfArg, C.ImGuiInputSource(v))
}

// ImGuiContext_GetNavInputSource returns value of ImGuiContext.NavInputSource
//
// Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputSource_Mouse
func (self *Context) NavInputSource() InputSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputSource(C.wrap_ImGuiContext_GetNavInputSource(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavLastValidSelectionUserData sets value of ImGuiContext.NavLastValidSelectionUserData
//
// Last valid data passed to SetNextItemSelectionUser(), or -1. For current window. Not reset when focusing an item that doesn't have selection data.
func (self Context) SetNavLastValidSelectionUserData(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavLastValidSelectionUserData(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiContext_GetNavLastValidSelectionUserData returns value of ImGuiContext.NavLastValidSelectionUserData
//
// Last valid data passed to SetNextItemSelectionUser(), or -1. For current window. Not reset when focusing an item that doesn't have selection data.
func (self *Context) NavLastValidSelectionUserData() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiContext_GetNavLastValidSelectionUserData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavCursorHideFrames sets value of ImGuiContext.NavCursorHideFrames
func (self Context) SetNavCursorHideFrames(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavCursorHideFrames(selfArg, C.ImS8(v))
}

// ImGuiContext_GetNavCursorHideFrames returns value of ImGuiContext.NavCursorHideFrames
func (self *Context) NavCursorHideFrames() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiContext_GetNavCursorHideFrames(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavAnyRequest sets value of ImGuiContext.NavAnyRequest
//
//	// Navigation: Init & Move Requests
//
// ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()
func (self Context) SetNavAnyRequest(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavAnyRequest(selfArg, C.bool(v))
}

// ImGuiContext_GetNavAnyRequest returns value of ImGuiContext.NavAnyRequest
//
//	// Navigation: Init & Move Requests
//
// ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()
func (self *Context) NavAnyRequest() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavAnyRequest(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavInitRequest sets value of ImGuiContext.NavInitRequest
//
// Init request for appearing window to select first item
func (self Context) SetNavInitRequest(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInitRequest(selfArg, C.bool(v))
}

// ImGuiContext_GetNavInitRequest returns value of ImGuiContext.NavInitRequest
//
// Init request for appearing window to select first item
func (self *Context) NavInitRequest() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavInitRequest(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavInitRequestFromMove sets value of ImGuiContext.NavInitRequestFromMove
func (self Context) SetNavInitRequestFromMove(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInitRequestFromMove(selfArg, C.bool(v))
}

// ImGuiContext_GetNavInitRequestFromMove returns value of ImGuiContext.NavInitRequestFromMove
func (self *Context) NavInitRequestFromMove() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavInitRequestFromMove(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavInitResult sets value of ImGuiContext.NavInitResult
//
// Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)
func (self Context) SetNavInitResult(v NavItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavInitResult(selfArg, internal.ReinterpretCast[C.ImGuiNavItemData](vArg))
}

// ImGuiContext_GetNavInitResult returns value of ImGuiContext.NavInitResult
//
// Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)
func (self *Context) NavInitResult() NavItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewNavItemDataFromC(func() *C.ImGuiNavItemData {
		result := C.wrap_ImGuiContext_GetNavInitResult(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavMoveSubmitted sets value of ImGuiContext.NavMoveSubmitted
//
// Move request submitted, will process result on next NewFrame()
func (self Context) SetNavMoveSubmitted(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveSubmitted(selfArg, C.bool(v))
}

// ImGuiContext_GetNavMoveSubmitted returns value of ImGuiContext.NavMoveSubmitted
//
// Move request submitted, will process result on next NewFrame()
func (self *Context) NavMoveSubmitted() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMoveSubmitted(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavMoveScoringItems sets value of ImGuiContext.NavMoveScoringItems
//
// Move request submitted, still scoring incoming items
func (self Context) SetNavMoveScoringItems(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveScoringItems(selfArg, C.bool(v))
}

// ImGuiContext_GetNavMoveScoringItems returns value of ImGuiContext.NavMoveScoringItems
//
// Move request submitted, still scoring incoming items
func (self *Context) NavMoveScoringItems() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMoveScoringItems(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavMoveForwardToNextFrame sets value of ImGuiContext.NavMoveForwardToNextFrame
func (self Context) SetNavMoveForwardToNextFrame(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveForwardToNextFrame(selfArg, C.bool(v))
}

// ImGuiContext_GetNavMoveForwardToNextFrame returns value of ImGuiContext.NavMoveForwardToNextFrame
func (self *Context) NavMoveForwardToNextFrame() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavMoveForwardToNextFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavMoveFlags sets value of ImGuiContext.NavMoveFlags
func (self Context) SetNavMoveFlags(v NavMoveFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveFlags(selfArg, C.ImGuiNavMoveFlags(v))
}

// ImGuiContext_GetNavMoveFlags returns value of ImGuiContext.NavMoveFlags
func (self *Context) NavMoveFlags() NavMoveFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NavMoveFlags(C.wrap_ImGuiContext_GetNavMoveFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavMoveScrollFlags sets value of ImGuiContext.NavMoveScrollFlags
func (self Context) SetNavMoveScrollFlags(v ScrollFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveScrollFlags(selfArg, C.ImGuiScrollFlags(v))
}

// ImGuiContext_GetNavMoveScrollFlags returns value of ImGuiContext.NavMoveScrollFlags
func (self *Context) NavMoveScrollFlags() ScrollFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ScrollFlags(C.wrap_ImGuiContext_GetNavMoveScrollFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavMoveKeyMods sets value of ImGuiContext.NavMoveKeyMods
func (self Context) SetNavMoveKeyMods(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveKeyMods(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiContext_GetNavMoveKeyMods returns value of ImGuiContext.NavMoveKeyMods
func (self *Context) NavMoveKeyMods() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiContext_GetNavMoveKeyMods(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavMoveDir sets value of ImGuiContext.NavMoveDir
//
// Direction of the move request (left/right/up/down)
func (self Context) SetNavMoveDir(v Dir) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveDir(selfArg, C.ImGuiDir(v))
}

// ImGuiContext_GetNavMoveDir returns value of ImGuiContext.NavMoveDir
//
// Direction of the move request (left/right/up/down)
func (self *Context) NavMoveDir() Dir {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiContext_GetNavMoveDir(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavMoveDirForDebug sets value of ImGuiContext.NavMoveDirForDebug
func (self Context) SetNavMoveDirForDebug(v Dir) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveDirForDebug(selfArg, C.ImGuiDir(v))
}

// ImGuiContext_GetNavMoveDirForDebug returns value of ImGuiContext.NavMoveDirForDebug
func (self *Context) NavMoveDirForDebug() Dir {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiContext_GetNavMoveDirForDebug(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavMoveClipDir sets value of ImGuiContext.NavMoveClipDir
//
// FIXME-NAV: Describe the purpose of this better. Might want to rename?
func (self Context) SetNavMoveClipDir(v Dir) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveClipDir(selfArg, C.ImGuiDir(v))
}

// ImGuiContext_GetNavMoveClipDir returns value of ImGuiContext.NavMoveClipDir
//
// FIXME-NAV: Describe the purpose of this better. Might want to rename?
func (self *Context) NavMoveClipDir() Dir {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiContext_GetNavMoveClipDir(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavScoringRect sets value of ImGuiContext.NavScoringRect
//
// Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.
func (self Context) SetNavScoringRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavScoringRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiContext_GetNavScoringRect returns value of ImGuiContext.NavScoringRect
//
// Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.
func (self *Context) NavScoringRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiContext_GetNavScoringRect(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetNavScoringNoClipRect sets value of ImGuiContext.NavScoringNoClipRect
//
// Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted
func (self Context) SetNavScoringNoClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavScoringNoClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiContext_GetNavScoringNoClipRect returns value of ImGuiContext.NavScoringNoClipRect
//
// Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted
func (self *Context) NavScoringNoClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiContext_GetNavScoringNoClipRect(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetNavScoringDebugCount sets value of ImGuiContext.NavScoringDebugCount
//
// Metrics for debugging
func (self Context) SetNavScoringDebugCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavScoringDebugCount(selfArg, C.int(v))
}

// ImGuiContext_GetNavScoringDebugCount returns value of ImGuiContext.NavScoringDebugCount
//
// Metrics for debugging
func (self *Context) NavScoringDebugCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetNavScoringDebugCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavTabbingDir sets value of ImGuiContext.NavTabbingDir
//
// Generally -1 or +1, 0 when tabbing without a nav id
func (self Context) SetNavTabbingDir(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavTabbingDir(selfArg, C.int(v))
}

// ImGuiContext_GetNavTabbingDir returns value of ImGuiContext.NavTabbingDir
//
// Generally -1 or +1, 0 when tabbing without a nav id
func (self *Context) NavTabbingDir() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetNavTabbingDir(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavTabbingCounter sets value of ImGuiContext.NavTabbingCounter
//
// >0 when counting items for tabbing
func (self Context) SetNavTabbingCounter(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavTabbingCounter(selfArg, C.int(v))
}

// ImGuiContext_GetNavTabbingCounter returns value of ImGuiContext.NavTabbingCounter
//
// >0 when counting items for tabbing
func (self *Context) NavTabbingCounter() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetNavTabbingCounter(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavMoveResultLocal sets value of ImGuiContext.NavMoveResultLocal
//
// Best move request candidate within NavWindow
func (self Context) SetNavMoveResultLocal(v NavItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveResultLocal(selfArg, internal.ReinterpretCast[C.ImGuiNavItemData](vArg))
}

// ImGuiContext_GetNavMoveResultLocal returns value of ImGuiContext.NavMoveResultLocal
//
// Best move request candidate within NavWindow
func (self *Context) NavMoveResultLocal() NavItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewNavItemDataFromC(func() *C.ImGuiNavItemData {
		result := C.wrap_ImGuiContext_GetNavMoveResultLocal(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavMoveResultLocalVisible sets value of ImGuiContext.NavMoveResultLocalVisible
//
// Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
func (self Context) SetNavMoveResultLocalVisible(v NavItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveResultLocalVisible(selfArg, internal.ReinterpretCast[C.ImGuiNavItemData](vArg))
}

// ImGuiContext_GetNavMoveResultLocalVisible returns value of ImGuiContext.NavMoveResultLocalVisible
//
// Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
func (self *Context) NavMoveResultLocalVisible() NavItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewNavItemDataFromC(func() *C.ImGuiNavItemData {
		result := C.wrap_ImGuiContext_GetNavMoveResultLocalVisible(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavMoveResultOther sets value of ImGuiContext.NavMoveResultOther
//
// Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)
func (self Context) SetNavMoveResultOther(v NavItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavMoveResultOther(selfArg, internal.ReinterpretCast[C.ImGuiNavItemData](vArg))
}

// ImGuiContext_GetNavMoveResultOther returns value of ImGuiContext.NavMoveResultOther
//
// Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)
func (self *Context) NavMoveResultOther() NavItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewNavItemDataFromC(func() *C.ImGuiNavItemData {
		result := C.wrap_ImGuiContext_GetNavMoveResultOther(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavTabbingResultFirst sets value of ImGuiContext.NavTabbingResultFirst
//
// First tabbing request candidate within NavWindow and flattened hierarchy
func (self Context) SetNavTabbingResultFirst(v NavItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavTabbingResultFirst(selfArg, internal.ReinterpretCast[C.ImGuiNavItemData](vArg))
}

// ImGuiContext_GetNavTabbingResultFirst returns value of ImGuiContext.NavTabbingResultFirst
//
// First tabbing request candidate within NavWindow and flattened hierarchy
func (self *Context) NavTabbingResultFirst() NavItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewNavItemDataFromC(func() *C.ImGuiNavItemData {
		result := C.wrap_ImGuiContext_GetNavTabbingResultFirst(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavJustMovedFromFocusScopeId sets value of ImGuiContext.NavJustMovedFromFocusScopeId
//
//	// Navigation: record of last move request
//
// Just navigated from this focus scope id (result of a successfully MoveRequest).
func (self Context) SetNavJustMovedFromFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedFromFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavJustMovedFromFocusScopeId returns value of ImGuiContext.NavJustMovedFromFocusScopeId
//
//	// Navigation: record of last move request
//
// Just navigated from this focus scope id (result of a successfully MoveRequest).
func (self *Context) NavJustMovedFromFocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavJustMovedFromFocusScopeId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavJustMovedToId sets value of ImGuiContext.NavJustMovedToId
//
// Just navigated to this id (result of a successfully MoveRequest).
func (self Context) SetNavJustMovedToId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavJustMovedToId returns value of ImGuiContext.NavJustMovedToId
//
// Just navigated to this id (result of a successfully MoveRequest).
func (self *Context) NavJustMovedToId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavJustMovedToId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavJustMovedToFocusScopeId sets value of ImGuiContext.NavJustMovedToFocusScopeId
//
// Just navigated to this focus scope id (result of a successfully MoveRequest).
func (self Context) SetNavJustMovedToFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetNavJustMovedToFocusScopeId returns value of ImGuiContext.NavJustMovedToFocusScopeId
//
// Just navigated to this focus scope id (result of a successfully MoveRequest).
func (self *Context) NavJustMovedToFocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetNavJustMovedToFocusScopeId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavJustMovedToKeyMods sets value of ImGuiContext.NavJustMovedToKeyMods
func (self Context) SetNavJustMovedToKeyMods(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToKeyMods(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiContext_GetNavJustMovedToKeyMods returns value of ImGuiContext.NavJustMovedToKeyMods
func (self *Context) NavJustMovedToKeyMods() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiContext_GetNavJustMovedToKeyMods(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavJustMovedToIsTabbing sets value of ImGuiContext.NavJustMovedToIsTabbing
//
// Copy of ImGuiNavMoveFlags_IsTabbing. Maybe we should store whole flags.
func (self Context) SetNavJustMovedToIsTabbing(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToIsTabbing(selfArg, C.bool(v))
}

// ImGuiContext_GetNavJustMovedToIsTabbing returns value of ImGuiContext.NavJustMovedToIsTabbing
//
// Copy of ImGuiNavMoveFlags_IsTabbing. Maybe we should store whole flags.
func (self *Context) NavJustMovedToIsTabbing() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavJustMovedToIsTabbing(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavJustMovedToHasSelectionData sets value of ImGuiContext.NavJustMovedToHasSelectionData
//
// Copy of move result's ItemFlags & ImGuiItemFlags_HasSelectionUserData). Maybe we should just store ImGuiNavItemData.
func (self Context) SetNavJustMovedToHasSelectionData(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavJustMovedToHasSelectionData(selfArg, C.bool(v))
}

// ImGuiContext_GetNavJustMovedToHasSelectionData returns value of ImGuiContext.NavJustMovedToHasSelectionData
//
// Copy of move result's ItemFlags & ImGuiItemFlags_HasSelectionUserData). Maybe we should just store ImGuiNavItemData.
func (self *Context) NavJustMovedToHasSelectionData() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavJustMovedToHasSelectionData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetConfigNavWindowingKeyNext sets value of ImGuiContext.ConfigNavWindowingKeyNext
//
//	// Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)
//
// = ImGuiMod_Ctrl | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiKey_Tab on OS X). For reconfiguration (see #4828)
func (self Context) SetConfigNavWindowingKeyNext(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigNavWindowingKeyNext(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiContext_GetConfigNavWindowingKeyNext returns value of ImGuiContext.ConfigNavWindowingKeyNext
//
//	// Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)
//
// = ImGuiMod_Ctrl | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiKey_Tab on OS X). For reconfiguration (see #4828)
func (self *Context) ConfigNavWindowingKeyNext() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiContext_GetConfigNavWindowingKeyNext(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetConfigNavWindowingKeyPrev sets value of ImGuiContext.ConfigNavWindowingKeyPrev
//
// = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab on OS X)
func (self Context) SetConfigNavWindowingKeyPrev(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetConfigNavWindowingKeyPrev(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiContext_GetConfigNavWindowingKeyPrev returns value of ImGuiContext.ConfigNavWindowingKeyPrev
//
// = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab on OS X)
func (self *Context) ConfigNavWindowingKeyPrev() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiContext_GetConfigNavWindowingKeyPrev(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetNavWindowingTarget sets value of ImGuiContext.NavWindowingTarget
//
// Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!
func (self Context) SetNavWindowingTarget(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingTarget(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetNavWindowingTarget returns value of ImGuiContext.NavWindowingTarget
//
// Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!
func (self *Context) NavWindowingTarget() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetNavWindowingTarget(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavWindowingTargetAnim sets value of ImGuiContext.NavWindowingTargetAnim
//
// Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.
func (self Context) SetNavWindowingTargetAnim(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingTargetAnim(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetNavWindowingTargetAnim returns value of ImGuiContext.NavWindowingTargetAnim
//
// Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.
func (self *Context) NavWindowingTargetAnim() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetNavWindowingTargetAnim(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavWindowingListWindow sets value of ImGuiContext.NavWindowingListWindow
//
// Internal window actually listing the CTRL+Tab contents
func (self Context) SetNavWindowingListWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingListWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetNavWindowingListWindow returns value of ImGuiContext.NavWindowingListWindow
//
// Internal window actually listing the CTRL+Tab contents
func (self *Context) NavWindowingListWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetNavWindowingListWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavWindowingTimer sets value of ImGuiContext.NavWindowingTimer
func (self Context) SetNavWindowingTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingTimer(selfArg, C.float(v))
}

// ImGuiContext_GetNavWindowingTimer returns value of ImGuiContext.NavWindowingTimer
func (self *Context) NavWindowingTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetNavWindowingTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavWindowingHighlightAlpha sets value of ImGuiContext.NavWindowingHighlightAlpha
func (self Context) SetNavWindowingHighlightAlpha(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingHighlightAlpha(selfArg, C.float(v))
}

// ImGuiContext_GetNavWindowingHighlightAlpha returns value of ImGuiContext.NavWindowingHighlightAlpha
func (self *Context) NavWindowingHighlightAlpha() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetNavWindowingHighlightAlpha(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavWindowingToggleLayer sets value of ImGuiContext.NavWindowingToggleLayer
func (self Context) SetNavWindowingToggleLayer(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingToggleLayer(selfArg, C.bool(v))
}

// ImGuiContext_GetNavWindowingToggleLayer returns value of ImGuiContext.NavWindowingToggleLayer
func (self *Context) NavWindowingToggleLayer() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetNavWindowingToggleLayer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetNavWindowingToggleKey sets value of ImGuiContext.NavWindowingToggleKey
func (self Context) SetNavWindowingToggleKey(v Key) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingToggleKey(selfArg, C.ImGuiKey(v))
}

// ImGuiContext_GetNavWindowingToggleKey returns value of ImGuiContext.NavWindowingToggleKey
func (self *Context) NavWindowingToggleKey() Key {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Key(C.wrap_ImGuiContext_GetNavWindowingToggleKey(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetNavWindowingAccumDeltaPos sets value of ImGuiContext.NavWindowingAccumDeltaPos
func (self Context) SetNavWindowingAccumDeltaPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingAccumDeltaPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetNavWindowingAccumDeltaPos returns value of ImGuiContext.NavWindowingAccumDeltaPos
func (self *Context) NavWindowingAccumDeltaPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetNavWindowingAccumDeltaPos(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetNavWindowingAccumDeltaSize sets value of ImGuiContext.NavWindowingAccumDeltaSize
func (self Context) SetNavWindowingAccumDeltaSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetNavWindowingAccumDeltaSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetNavWindowingAccumDeltaSize returns value of ImGuiContext.NavWindowingAccumDeltaSize
func (self *Context) NavWindowingAccumDeltaSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetNavWindowingAccumDeltaSize(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetDimBgRatio sets value of ImGuiContext.DimBgRatio
//
//	// Render
//
// 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
func (self Context) SetDimBgRatio(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDimBgRatio(selfArg, C.float(v))
}

// ImGuiContext_GetDimBgRatio returns value of ImGuiContext.DimBgRatio
//
//	// Render
//
// 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
func (self *Context) DimBgRatio() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDimBgRatio(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragDropActive sets value of ImGuiContext.DragDropActive
//
//	// Drag and Drop
func (self Context) SetDragDropActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropActive(selfArg, C.bool(v))
}

// ImGuiContext_GetDragDropActive returns value of ImGuiContext.DragDropActive
//
//	// Drag and Drop
func (self *Context) DragDropActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragDropActive(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDragDropWithinSource sets value of ImGuiContext.DragDropWithinSource
//
// Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
func (self Context) SetDragDropWithinSource(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropWithinSource(selfArg, C.bool(v))
}

// ImGuiContext_GetDragDropWithinSource returns value of ImGuiContext.DragDropWithinSource
//
// Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
func (self *Context) DragDropWithinSource() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragDropWithinSource(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDragDropWithinTarget sets value of ImGuiContext.DragDropWithinTarget
//
// Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
func (self Context) SetDragDropWithinTarget(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropWithinTarget(selfArg, C.bool(v))
}

// ImGuiContext_GetDragDropWithinTarget returns value of ImGuiContext.DragDropWithinTarget
//
// Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
func (self *Context) DragDropWithinTarget() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragDropWithinTarget(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDragDropSourceFlags sets value of ImGuiContext.DragDropSourceFlags
func (self Context) SetDragDropSourceFlags(v DragDropFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropSourceFlags(selfArg, C.ImGuiDragDropFlags(v))
}

// ImGuiContext_GetDragDropSourceFlags returns value of ImGuiContext.DragDropSourceFlags
func (self *Context) DragDropSourceFlags() DragDropFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DragDropFlags(C.wrap_ImGuiContext_GetDragDropSourceFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragDropSourceFrameCount sets value of ImGuiContext.DragDropSourceFrameCount
func (self Context) SetDragDropSourceFrameCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropSourceFrameCount(selfArg, C.int(v))
}

// ImGuiContext_GetDragDropSourceFrameCount returns value of ImGuiContext.DragDropSourceFrameCount
func (self *Context) DragDropSourceFrameCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDragDropSourceFrameCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragDropMouseButton sets value of ImGuiContext.DragDropMouseButton
func (self Context) SetDragDropMouseButton(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropMouseButton(selfArg, C.int(v))
}

// ImGuiContext_GetDragDropMouseButton returns value of ImGuiContext.DragDropMouseButton
func (self *Context) DragDropMouseButton() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDragDropMouseButton(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragDropPayload sets value of ImGuiContext.DragDropPayload
func (self Context) SetDragDropPayload(v Payload) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropPayload(selfArg, internal.ReinterpretCast[C.ImGuiPayload](vArg))
}

// ImGuiContext_GetDragDropPayload returns value of ImGuiContext.DragDropPayload
func (self *Context) DragDropPayload() Payload {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewPayloadFromC(func() *C.ImGuiPayload {
		result := C.wrap_ImGuiContext_GetDragDropPayload(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDragDropTargetRect sets value of ImGuiContext.DragDropTargetRect
//
// Store rectangle of current target candidate (we favor small targets when overlapping)
func (self Context) SetDragDropTargetRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropTargetRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiContext_GetDragDropTargetRect returns value of ImGuiContext.DragDropTargetRect
//
// Store rectangle of current target candidate (we favor small targets when overlapping)
func (self *Context) DragDropTargetRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiContext_GetDragDropTargetRect(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetDragDropTargetClipRect sets value of ImGuiContext.DragDropTargetClipRect
//
// Store ClipRect at the time of item's drawing
func (self Context) SetDragDropTargetClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropTargetClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiContext_GetDragDropTargetClipRect returns value of ImGuiContext.DragDropTargetClipRect
//
// Store ClipRect at the time of item's drawing
func (self *Context) DragDropTargetClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiContext_GetDragDropTargetClipRect(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetDragDropTargetId sets value of ImGuiContext.DragDropTargetId
func (self Context) SetDragDropTargetId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropTargetId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDragDropTargetId returns value of ImGuiContext.DragDropTargetId
func (self *Context) DragDropTargetId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDragDropTargetId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDragDropAcceptFlags sets value of ImGuiContext.DragDropAcceptFlags
func (self Context) SetDragDropAcceptFlags(v DragDropFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptFlags(selfArg, C.ImGuiDragDropFlags(v))
}

// ImGuiContext_GetDragDropAcceptFlags returns value of ImGuiContext.DragDropAcceptFlags
func (self *Context) DragDropAcceptFlags() DragDropFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DragDropFlags(C.wrap_ImGuiContext_GetDragDropAcceptFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragDropAcceptIdCurrRectSurface sets value of ImGuiContext.DragDropAcceptIdCurrRectSurface
//
// Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
func (self Context) SetDragDropAcceptIdCurrRectSurface(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptIdCurrRectSurface(selfArg, C.float(v))
}

// ImGuiContext_GetDragDropAcceptIdCurrRectSurface returns value of ImGuiContext.DragDropAcceptIdCurrRectSurface
//
// Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
func (self *Context) DragDropAcceptIdCurrRectSurface() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDragDropAcceptIdCurrRectSurface(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragDropAcceptIdCurr sets value of ImGuiContext.DragDropAcceptIdCurr
//
// Target item id (set at the time of accepting the payload)
func (self Context) SetDragDropAcceptIdCurr(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptIdCurr(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDragDropAcceptIdCurr returns value of ImGuiContext.DragDropAcceptIdCurr
//
// Target item id (set at the time of accepting the payload)
func (self *Context) DragDropAcceptIdCurr() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDragDropAcceptIdCurr(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDragDropAcceptIdPrev sets value of ImGuiContext.DragDropAcceptIdPrev
//
// Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
func (self Context) SetDragDropAcceptIdPrev(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptIdPrev(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDragDropAcceptIdPrev returns value of ImGuiContext.DragDropAcceptIdPrev
//
// Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
func (self *Context) DragDropAcceptIdPrev() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDragDropAcceptIdPrev(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDragDropAcceptFrameCount sets value of ImGuiContext.DragDropAcceptFrameCount
//
// Last time a target expressed a desire to accept the source
func (self Context) SetDragDropAcceptFrameCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropAcceptFrameCount(selfArg, C.int(v))
}

// ImGuiContext_GetDragDropAcceptFrameCount returns value of ImGuiContext.DragDropAcceptFrameCount
//
// Last time a target expressed a desire to accept the source
func (self *Context) DragDropAcceptFrameCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDragDropAcceptFrameCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragDropHoldJustPressedId sets value of ImGuiContext.DragDropHoldJustPressedId
//
// Set when holding a payload just made ButtonBehavior() return a press.
func (self Context) SetDragDropHoldJustPressedId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropHoldJustPressedId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDragDropHoldJustPressedId returns value of ImGuiContext.DragDropHoldJustPressedId
//
// Set when holding a payload just made ButtonBehavior() return a press.
func (self *Context) DragDropHoldJustPressedId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDragDropHoldJustPressedId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDragDropPayloadBufLocal sets value of ImGuiContext.DragDropPayloadBufLocal[16]
//
// Local buffer for small payloads
func (self Context) SetDragDropPayloadBufLocal(v *[16]uint) {
	vArg := make([]C.uchar, len(v))
	for i, vV := range v {
		vArg[i] = C.uchar(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragDropPayloadBufLocal(selfArg, (*C.uchar)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = uint(vV)
	}
}

// ImGuiContext_GetDragDropPayloadBufLocal returns value of ImGuiContext.DragDropPayloadBufLocal[16]
//
// Local buffer for small payloads
func (self *Context) DragDropPayloadBufLocal() [16]uint {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [16]uint {
		result := [16]uint{}
		resultMirr := C.wrap_ImGuiContext_GetDragDropPayloadBufLocal(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		for i := range result {
			result[i] = uint(C.cimgui_unsigned_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiContext_SetClipperTempDataStacked sets value of ImGuiContext.ClipperTempDataStacked
//
//	// Clipper
func (self Context) SetClipperTempDataStacked(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetClipperTempDataStacked(selfArg, C.int(v))
}

// ImGuiContext_GetClipperTempDataStacked returns value of ImGuiContext.ClipperTempDataStacked
//
//	// Clipper
func (self *Context) ClipperTempDataStacked() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetClipperTempDataStacked(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetClipperTempData sets value of ImGuiContext.ClipperTempData
func (self Context) SetClipperTempData(v vectors.Vector[ListClipperData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiListClipperData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiListClipperData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetClipperTempData(selfArg, *vVecArg)
}

// ImGuiContext_GetClipperTempData returns value of ImGuiContext.ClipperTempData
func (self *Context) ClipperTempData() vectors.Vector[ListClipperData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetClipperTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetClipperTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewListClipperDataFromC(C.wrap_ImGuiContext_GetClipperTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetCurrentTable sets value of ImGuiContext.CurrentTable
//
//	// Tables
func (self Context) SetCurrentTable(v *Table) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentTable(selfArg, internal.ReinterpretCast[*C.ImGuiTable](vArg))
}

// ImGuiContext_GetCurrentTable returns value of ImGuiContext.CurrentTable
//
//	// Tables
func (self *Context) CurrentTable() *Table {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewTableFromC(C.wrap_ImGuiContext_GetCurrentTable(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugBreakInTable sets value of ImGuiContext.DebugBreakInTable
//
// Set to break in BeginTable() call.
func (self Context) SetDebugBreakInTable(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugBreakInTable(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDebugBreakInTable returns value of ImGuiContext.DebugBreakInTable
//
// Set to break in BeginTable() call.
func (self *Context) DebugBreakInTable() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDebugBreakInTable(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetTablesTempDataStacked sets value of ImGuiContext.TablesTempDataStacked
//
// Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)
func (self Context) SetTablesTempDataStacked(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTablesTempDataStacked(selfArg, C.int(v))
}

// ImGuiContext_GetTablesTempDataStacked returns value of ImGuiContext.TablesTempDataStacked
//
// Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)
func (self *Context) TablesTempDataStacked() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetTablesTempDataStacked(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetTablesTempData sets value of ImGuiContext.TablesTempData
//
// Temporary table data (buffers reused/shared across instances, support nesting)
func (self Context) SetTablesTempData(v vectors.Vector[TableTempData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiTableTempData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiTableTempData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTablesTempData(selfArg, *vVecArg)
}

// ImGuiContext_GetTablesTempData returns value of ImGuiContext.TablesTempData
//
// Temporary table data (buffers reused/shared across instances, support nesting)
func (self *Context) TablesTempData() vectors.Vector[TableTempData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetTablesTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetTablesTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewTableTempDataFromC(C.wrap_ImGuiContext_GetTablesTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetTablesLastTimeActive sets value of ImGuiContext.TablesLastTimeActive
//
// Last used timestamp of each tables (SOA, for efficient GC)
func (self Context) SetTablesLastTimeActive(v vectors.Vector[float32]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTablesLastTimeActive(selfArg, *vVecArg)
}

// ImGuiContext_GetTablesLastTimeActive returns value of ImGuiContext.TablesLastTimeActive
//
// Last used timestamp of each tables (SOA, for efficient GC)
func (self *Context) TablesLastTimeActive() vectors.Vector[float32] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetTablesLastTimeActive(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetTablesLastTimeActive(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, (*float32)(C.wrap_ImGuiContext_GetTablesLastTimeActive(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetDrawChannelsTempMergeBuffer sets value of ImGuiContext.DrawChannelsTempMergeBuffer
func (self Context) SetDrawChannelsTempMergeBuffer(v vectors.Vector[DrawChannel]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImDrawChannel)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImDrawChannel](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDrawChannelsTempMergeBuffer(selfArg, *vVecArg)
}

// ImGuiContext_GetDrawChannelsTempMergeBuffer returns value of ImGuiContext.DrawChannelsTempMergeBuffer
func (self *Context) DrawChannelsTempMergeBuffer() vectors.Vector[DrawChannel] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetDrawChannelsTempMergeBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetDrawChannelsTempMergeBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewDrawChannelFromC(C.wrap_ImGuiContext_GetDrawChannelsTempMergeBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetCurrentTabBar sets value of ImGuiContext.CurrentTabBar
//
//	// Tab bars
func (self Context) SetCurrentTabBar(v *TabBar) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentTabBar(selfArg, internal.ReinterpretCast[*C.ImGuiTabBar](vArg))
}

// ImGuiContext_GetCurrentTabBar returns value of ImGuiContext.CurrentTabBar
//
//	// Tab bars
func (self *Context) CurrentTabBar() *TabBar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewTabBarFromC(C.wrap_ImGuiContext_GetCurrentTabBar(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetCurrentTabBarStack sets value of ImGuiContext.CurrentTabBarStack
func (self Context) SetCurrentTabBarStack(v vectors.Vector[PtrOrIndex]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiPtrOrIndex)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiPtrOrIndex](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentTabBarStack(selfArg, *vVecArg)
}

// ImGuiContext_GetCurrentTabBarStack returns value of ImGuiContext.CurrentTabBarStack
func (self *Context) CurrentTabBarStack() vectors.Vector[PtrOrIndex] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetCurrentTabBarStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetCurrentTabBarStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewPtrOrIndexFromC(C.wrap_ImGuiContext_GetCurrentTabBarStack(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetShrinkWidthBuffer sets value of ImGuiContext.ShrinkWidthBuffer
func (self Context) SetShrinkWidthBuffer(v vectors.Vector[ShrinkWidthItem]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiShrinkWidthItem)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiShrinkWidthItem](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetShrinkWidthBuffer(selfArg, *vVecArg)
}

// ImGuiContext_GetShrinkWidthBuffer returns value of ImGuiContext.ShrinkWidthBuffer
func (self *Context) ShrinkWidthBuffer() vectors.Vector[ShrinkWidthItem] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetShrinkWidthBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetShrinkWidthBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewShrinkWidthItemFromC(C.wrap_ImGuiContext_GetShrinkWidthBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetBoxSelectState sets value of ImGuiContext.BoxSelectState
//
//	// Multi-Select state
func (self Context) SetBoxSelectState(v BoxSelectState) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetBoxSelectState(selfArg, internal.ReinterpretCast[C.ImGuiBoxSelectState](vArg))
}

// ImGuiContext_GetBoxSelectState returns value of ImGuiContext.BoxSelectState
//
//	// Multi-Select state
func (self *Context) BoxSelectState() BoxSelectState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewBoxSelectStateFromC(func() *C.ImGuiBoxSelectState {
		result := C.wrap_ImGuiContext_GetBoxSelectState(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetCurrentMultiSelect sets value of ImGuiContext.CurrentMultiSelect
func (self Context) SetCurrentMultiSelect(v *MultiSelectTempData) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetCurrentMultiSelect(selfArg, internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](vArg))
}

// ImGuiContext_GetCurrentMultiSelect returns value of ImGuiContext.CurrentMultiSelect
func (self *Context) CurrentMultiSelect() *MultiSelectTempData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewMultiSelectTempDataFromC(C.wrap_ImGuiContext_GetCurrentMultiSelect(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetMultiSelectTempDataStacked sets value of ImGuiContext.MultiSelectTempDataStacked
//
// Temporary multi-select data size (because we leave previous instances undestructed, we generally don't use MultiSelectTempData.Size)
func (self Context) SetMultiSelectTempDataStacked(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMultiSelectTempDataStacked(selfArg, C.int(v))
}

// ImGuiContext_GetMultiSelectTempDataStacked returns value of ImGuiContext.MultiSelectTempDataStacked
//
// Temporary multi-select data size (because we leave previous instances undestructed, we generally don't use MultiSelectTempData.Size)
func (self *Context) MultiSelectTempDataStacked() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetMultiSelectTempDataStacked(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetMultiSelectTempData sets value of ImGuiContext.MultiSelectTempData
func (self Context) SetMultiSelectTempData(v vectors.Vector[MultiSelectTempData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiMultiSelectTempData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMultiSelectTempData(selfArg, *vVecArg)
}

// ImGuiContext_GetMultiSelectTempData returns value of ImGuiContext.MultiSelectTempData
func (self *Context) MultiSelectTempData() vectors.Vector[MultiSelectTempData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetMultiSelectTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetMultiSelectTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewMultiSelectTempDataFromC(C.wrap_ImGuiContext_GetMultiSelectTempData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetHoverItemDelayId sets value of ImGuiContext.HoverItemDelayId
//
//	// Hover Delay system
func (self Context) SetHoverItemDelayId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetHoverItemDelayId returns value of ImGuiContext.HoverItemDelayId
//
//	// Hover Delay system
func (self *Context) HoverItemDelayId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetHoverItemDelayId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetHoverItemDelayIdPreviousFrame sets value of ImGuiContext.HoverItemDelayIdPreviousFrame
func (self Context) SetHoverItemDelayIdPreviousFrame(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayIdPreviousFrame(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetHoverItemDelayIdPreviousFrame returns value of ImGuiContext.HoverItemDelayIdPreviousFrame
func (self *Context) HoverItemDelayIdPreviousFrame() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetHoverItemDelayIdPreviousFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetHoverItemDelayTimer sets value of ImGuiContext.HoverItemDelayTimer
//
// Currently used by IsItemHovered()
func (self Context) SetHoverItemDelayTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayTimer(selfArg, C.float(v))
}

// ImGuiContext_GetHoverItemDelayTimer returns value of ImGuiContext.HoverItemDelayTimer
//
// Currently used by IsItemHovered()
func (self *Context) HoverItemDelayTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoverItemDelayTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoverItemDelayClearTimer sets value of ImGuiContext.HoverItemDelayClearTimer
//
// Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.
func (self Context) SetHoverItemDelayClearTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemDelayClearTimer(selfArg, C.float(v))
}

// ImGuiContext_GetHoverItemDelayClearTimer returns value of ImGuiContext.HoverItemDelayClearTimer
//
// Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.
func (self *Context) HoverItemDelayClearTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetHoverItemDelayClearTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetHoverItemUnlockedStationaryId sets value of ImGuiContext.HoverItemUnlockedStationaryId
//
// Mouse has once been stationary on this item. Only reset after departing the item.
func (self Context) SetHoverItemUnlockedStationaryId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverItemUnlockedStationaryId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetHoverItemUnlockedStationaryId returns value of ImGuiContext.HoverItemUnlockedStationaryId
//
// Mouse has once been stationary on this item. Only reset after departing the item.
func (self *Context) HoverItemUnlockedStationaryId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetHoverItemUnlockedStationaryId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetHoverWindowUnlockedStationaryId sets value of ImGuiContext.HoverWindowUnlockedStationaryId
//
// Mouse has once been stationary on this window. Only reset after departing the window.
func (self Context) SetHoverWindowUnlockedStationaryId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHoverWindowUnlockedStationaryId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetHoverWindowUnlockedStationaryId returns value of ImGuiContext.HoverWindowUnlockedStationaryId
//
// Mouse has once been stationary on this window. Only reset after departing the window.
func (self *Context) HoverWindowUnlockedStationaryId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetHoverWindowUnlockedStationaryId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetMouseCursor sets value of ImGuiContext.MouseCursor
//
//	// Mouse state
func (self Context) SetMouseCursor(v MouseCursor) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseCursor(selfArg, C.ImGuiMouseCursor(v))
}

// ImGuiContext_GetMouseCursor returns value of ImGuiContext.MouseCursor
//
//	// Mouse state
func (self *Context) MouseCursor() MouseCursor {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return MouseCursor(C.wrap_ImGuiContext_GetMouseCursor(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetMouseStationaryTimer sets value of ImGuiContext.MouseStationaryTimer
//
// Time the mouse has been stationary (with some loose heuristic)
func (self Context) SetMouseStationaryTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseStationaryTimer(selfArg, C.float(v))
}

// ImGuiContext_GetMouseStationaryTimer returns value of ImGuiContext.MouseStationaryTimer
//
// Time the mouse has been stationary (with some loose heuristic)
func (self *Context) MouseStationaryTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetMouseStationaryTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetMouseLastValidPos sets value of ImGuiContext.MouseLastValidPos
func (self Context) SetMouseLastValidPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMouseLastValidPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetMouseLastValidPos returns value of ImGuiContext.MouseLastValidPos
func (self *Context) MouseLastValidPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetMouseLastValidPos(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetInputTextState sets value of ImGuiContext.InputTextState
//
//	// Widget state
func (self Context) SetInputTextState(v InputTextState) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputTextState(selfArg, internal.ReinterpretCast[C.ImGuiInputTextState](vArg))
}

// ImGuiContext_GetInputTextState returns value of ImGuiContext.InputTextState
//
//	// Widget state
func (self *Context) InputTextState() InputTextState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewInputTextStateFromC(func() *C.ImGuiInputTextState {
		result := C.wrap_ImGuiContext_GetInputTextState(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetInputTextDeactivatedState sets value of ImGuiContext.InputTextDeactivatedState
func (self Context) SetInputTextDeactivatedState(v InputTextDeactivatedState) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputTextDeactivatedState(selfArg, internal.ReinterpretCast[C.ImGuiInputTextDeactivatedState](vArg))
}

// ImGuiContext_GetInputTextDeactivatedState returns value of ImGuiContext.InputTextDeactivatedState
func (self *Context) InputTextDeactivatedState() InputTextDeactivatedState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewInputTextDeactivatedStateFromC(func() *C.ImGuiInputTextDeactivatedState {
		result := C.wrap_ImGuiContext_GetInputTextDeactivatedState(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetInputTextPasswordFont sets value of ImGuiContext.InputTextPasswordFont
func (self Context) SetInputTextPasswordFont(v Font) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetInputTextPasswordFont(selfArg, internal.ReinterpretCast[C.ImFont](vArg))
}

// ImGuiContext_GetInputTextPasswordFont returns value of ImGuiContext.InputTextPasswordFont
func (self *Context) InputTextPasswordFont() Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewFontFromC(func() *C.ImFont {
		result := C.wrap_ImGuiContext_GetInputTextPasswordFont(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetTempInputId sets value of ImGuiContext.TempInputId
//
// Temporary text input when CTRL+clicking on a slider, etc.
func (self Context) SetTempInputId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTempInputId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetTempInputId returns value of ImGuiContext.TempInputId
//
// Temporary text input when CTRL+clicking on a slider, etc.
func (self *Context) TempInputId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetTempInputId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDataTypeZeroValue sets value of ImGuiContext.DataTypeZeroValue
//
// 0 for all data types
func (self Context) SetDataTypeZeroValue(v DataTypeStorage) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDataTypeZeroValue(selfArg, internal.ReinterpretCast[C.ImGuiDataTypeStorage](vArg))
}

// ImGuiContext_GetDataTypeZeroValue returns value of ImGuiContext.DataTypeZeroValue
//
// 0 for all data types
func (self *Context) DataTypeZeroValue() DataTypeStorage {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDataTypeStorageFromC(func() *C.ImGuiDataTypeStorage {
		result := C.wrap_ImGuiContext_GetDataTypeZeroValue(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetBeginMenuDepth sets value of ImGuiContext.BeginMenuDepth
func (self Context) SetBeginMenuDepth(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetBeginMenuDepth(selfArg, C.int(v))
}

// ImGuiContext_GetBeginMenuDepth returns value of ImGuiContext.BeginMenuDepth
func (self *Context) BeginMenuDepth() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetBeginMenuDepth(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetBeginComboDepth sets value of ImGuiContext.BeginComboDepth
func (self Context) SetBeginComboDepth(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetBeginComboDepth(selfArg, C.int(v))
}

// ImGuiContext_GetBeginComboDepth returns value of ImGuiContext.BeginComboDepth
func (self *Context) BeginComboDepth() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetBeginComboDepth(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetColorEditOptions sets value of ImGuiContext.ColorEditOptions
//
// Store user options for color edit widgets
func (self Context) SetColorEditOptions(v ColorEditFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditOptions(selfArg, C.ImGuiColorEditFlags(v))
}

// ImGuiContext_GetColorEditOptions returns value of ImGuiContext.ColorEditOptions
//
// Store user options for color edit widgets
func (self *Context) ColorEditOptions() ColorEditFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ColorEditFlags(C.wrap_ImGuiContext_GetColorEditOptions(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetColorEditCurrentID sets value of ImGuiContext.ColorEditCurrentID
//
// Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).
func (self Context) SetColorEditCurrentID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditCurrentID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetColorEditCurrentID returns value of ImGuiContext.ColorEditCurrentID
//
// Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).
func (self *Context) ColorEditCurrentID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetColorEditCurrentID(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetColorEditSavedID sets value of ImGuiContext.ColorEditSavedID
//
// ID we are saving/restoring HS for
func (self Context) SetColorEditSavedID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetColorEditSavedID returns value of ImGuiContext.ColorEditSavedID
//
// ID we are saving/restoring HS for
func (self *Context) ColorEditSavedID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetColorEditSavedID(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetColorEditSavedHue sets value of ImGuiContext.ColorEditSavedHue
//
// Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips
func (self Context) SetColorEditSavedHue(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedHue(selfArg, C.float(v))
}

// ImGuiContext_GetColorEditSavedHue returns value of ImGuiContext.ColorEditSavedHue
//
// Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips
func (self *Context) ColorEditSavedHue() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetColorEditSavedHue(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetColorEditSavedSat sets value of ImGuiContext.ColorEditSavedSat
//
// Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips
func (self Context) SetColorEditSavedSat(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedSat(selfArg, C.float(v))
}

// ImGuiContext_GetColorEditSavedSat returns value of ImGuiContext.ColorEditSavedSat
//
// Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips
func (self *Context) ColorEditSavedSat() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetColorEditSavedSat(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetColorEditSavedColor sets value of ImGuiContext.ColorEditSavedColor
//
// RGB value with alpha set to 0.
func (self Context) SetColorEditSavedColor(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorEditSavedColor(selfArg, C.ImU32(v))
}

// ImGuiContext_GetColorEditSavedColor returns value of ImGuiContext.ColorEditSavedColor
//
// RGB value with alpha set to 0.
func (self *Context) ColorEditSavedColor() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiContext_GetColorEditSavedColor(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetColorPickerRef sets value of ImGuiContext.ColorPickerRef
//
// Initial/reference color at the time of opening the color picker.
func (self Context) SetColorPickerRef(v Vec4) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetColorPickerRef(selfArg, internal.ReinterpretCast[C.ImVec4](v.ToC()))
}

// ImGuiContext_GetColorPickerRef returns value of ImGuiContext.ColorPickerRef
//
// Initial/reference color at the time of opening the color picker.
func (self *Context) ColorPickerRef() Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec4 {
		out := C.wrap_ImGuiContext_GetColorPickerRef(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec4{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetComboPreviewData sets value of ImGuiContext.ComboPreviewData
func (self Context) SetComboPreviewData(v ComboPreviewData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetComboPreviewData(selfArg, internal.ReinterpretCast[C.ImGuiComboPreviewData](vArg))
}

// ImGuiContext_GetComboPreviewData returns value of ImGuiContext.ComboPreviewData
func (self *Context) ComboPreviewData() ComboPreviewData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewComboPreviewDataFromC(func() *C.ImGuiComboPreviewData {
		result := C.wrap_ImGuiContext_GetComboPreviewData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetWindowResizeBorderExpectedRect sets value of ImGuiContext.WindowResizeBorderExpectedRect
//
// Expected border rect, switch to relative edit if moving
func (self Context) SetWindowResizeBorderExpectedRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowResizeBorderExpectedRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiContext_GetWindowResizeBorderExpectedRect returns value of ImGuiContext.WindowResizeBorderExpectedRect
//
// Expected border rect, switch to relative edit if moving
func (self *Context) WindowResizeBorderExpectedRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiContext_GetWindowResizeBorderExpectedRect(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetWindowResizeRelativeMode sets value of ImGuiContext.WindowResizeRelativeMode
func (self Context) SetWindowResizeRelativeMode(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWindowResizeRelativeMode(selfArg, C.bool(v))
}

// ImGuiContext_GetWindowResizeRelativeMode returns value of ImGuiContext.WindowResizeRelativeMode
func (self *Context) WindowResizeRelativeMode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetWindowResizeRelativeMode(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetScrollbarSeekMode sets value of ImGuiContext.ScrollbarSeekMode
//
// 0: scroll to clicked location, -1/+1: prev/next page.
func (self Context) SetScrollbarSeekMode(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetScrollbarSeekMode(selfArg, C.short(v))
}

// ImGuiContext_GetScrollbarSeekMode returns value of ImGuiContext.ScrollbarSeekMode
//
// 0: scroll to clicked location, -1/+1: prev/next page.
func (self *Context) ScrollbarSeekMode() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiContext_GetScrollbarSeekMode(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetScrollbarClickDeltaToGrabCenter sets value of ImGuiContext.ScrollbarClickDeltaToGrabCenter
//
// When scrolling to mouse location: distance between mouse and center of grab box, normalized in parent space.
func (self Context) SetScrollbarClickDeltaToGrabCenter(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetScrollbarClickDeltaToGrabCenter(selfArg, C.float(v))
}

// ImGuiContext_GetScrollbarClickDeltaToGrabCenter returns value of ImGuiContext.ScrollbarClickDeltaToGrabCenter
//
// When scrolling to mouse location: distance between mouse and center of grab box, normalized in parent space.
func (self *Context) ScrollbarClickDeltaToGrabCenter() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetScrollbarClickDeltaToGrabCenter(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetSliderGrabClickOffset sets value of ImGuiContext.SliderGrabClickOffset
func (self Context) SetSliderGrabClickOffset(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSliderGrabClickOffset(selfArg, C.float(v))
}

// ImGuiContext_GetSliderGrabClickOffset returns value of ImGuiContext.SliderGrabClickOffset
func (self *Context) SliderGrabClickOffset() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetSliderGrabClickOffset(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetSliderCurrentAccum sets value of ImGuiContext.SliderCurrentAccum
//
// Accumulated slider delta when using navigation controls.
func (self Context) SetSliderCurrentAccum(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSliderCurrentAccum(selfArg, C.float(v))
}

// ImGuiContext_GetSliderCurrentAccum returns value of ImGuiContext.SliderCurrentAccum
//
// Accumulated slider delta when using navigation controls.
func (self *Context) SliderCurrentAccum() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetSliderCurrentAccum(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetSliderCurrentAccumDirty sets value of ImGuiContext.SliderCurrentAccumDirty
//
// Has the accumulated slider delta changed since last time we tried to apply it?
func (self Context) SetSliderCurrentAccumDirty(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSliderCurrentAccumDirty(selfArg, C.bool(v))
}

// ImGuiContext_GetSliderCurrentAccumDirty returns value of ImGuiContext.SliderCurrentAccumDirty
//
// Has the accumulated slider delta changed since last time we tried to apply it?
func (self *Context) SliderCurrentAccumDirty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetSliderCurrentAccumDirty(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDragCurrentAccumDirty sets value of ImGuiContext.DragCurrentAccumDirty
func (self Context) SetDragCurrentAccumDirty(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragCurrentAccumDirty(selfArg, C.bool(v))
}

// ImGuiContext_GetDragCurrentAccumDirty returns value of ImGuiContext.DragCurrentAccumDirty
func (self *Context) DragCurrentAccumDirty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDragCurrentAccumDirty(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDragCurrentAccum sets value of ImGuiContext.DragCurrentAccum
//
// Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
func (self Context) SetDragCurrentAccum(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragCurrentAccum(selfArg, C.float(v))
}

// ImGuiContext_GetDragCurrentAccum returns value of ImGuiContext.DragCurrentAccum
//
// Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
func (self *Context) DragCurrentAccum() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDragCurrentAccum(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDragSpeedDefaultRatio sets value of ImGuiContext.DragSpeedDefaultRatio
//
// If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
func (self Context) SetDragSpeedDefaultRatio(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDragSpeedDefaultRatio(selfArg, C.float(v))
}

// ImGuiContext_GetDragSpeedDefaultRatio returns value of ImGuiContext.DragSpeedDefaultRatio
//
// If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
func (self *Context) DragSpeedDefaultRatio() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDragSpeedDefaultRatio(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDisabledAlphaBackup sets value of ImGuiContext.DisabledAlphaBackup
//
// Backup for style.Alpha for BeginDisabled()
func (self Context) SetDisabledAlphaBackup(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDisabledAlphaBackup(selfArg, C.float(v))
}

// ImGuiContext_GetDisabledAlphaBackup returns value of ImGuiContext.DisabledAlphaBackup
//
// Backup for style.Alpha for BeginDisabled()
func (self *Context) DisabledAlphaBackup() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDisabledAlphaBackup(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDisabledStackSize sets value of ImGuiContext.DisabledStackSize
func (self Context) SetDisabledStackSize(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDisabledStackSize(selfArg, C.short(v))
}

// ImGuiContext_GetDisabledStackSize returns value of ImGuiContext.DisabledStackSize
func (self *Context) DisabledStackSize() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiContext_GetDisabledStackSize(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetTooltipOverrideCount sets value of ImGuiContext.TooltipOverrideCount
func (self Context) SetTooltipOverrideCount(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTooltipOverrideCount(selfArg, C.short(v))
}

// ImGuiContext_GetTooltipOverrideCount returns value of ImGuiContext.TooltipOverrideCount
func (self *Context) TooltipOverrideCount() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiContext_GetTooltipOverrideCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetTooltipPreviousWindow sets value of ImGuiContext.TooltipPreviousWindow
//
// Window of last tooltip submitted during the frame
func (self Context) SetTooltipPreviousWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTooltipPreviousWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiContext_GetTooltipPreviousWindow returns value of ImGuiContext.TooltipPreviousWindow
//
// Window of last tooltip submitted during the frame
func (self *Context) TooltipPreviousWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiContext_GetTooltipPreviousWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetClipboardHandlerData sets value of ImGuiContext.ClipboardHandlerData
//
// If no custom clipboard handler is defined
func (self Context) SetClipboardHandlerData(v vectors.Vector[int8]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.char, int8](vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetClipboardHandlerData(selfArg, *vVecArg)
}

// ImGuiContext_GetClipboardHandlerData returns value of ImGuiContext.ClipboardHandlerData
//
// If no custom clipboard handler is defined
func (self *Context) ClipboardHandlerData() vectors.Vector[int8] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetClipboardHandlerData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetClipboardHandlerData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, (*int8)(C.wrap_ImGuiContext_GetClipboardHandlerData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetMenusIdSubmittedThisFrame sets value of ImGuiContext.MenusIdSubmittedThisFrame
//
// A list of menu IDs that were rendered at least once
func (self Context) SetMenusIdSubmittedThisFrame(v vectors.Vector[ID]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiID)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiID](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetMenusIdSubmittedThisFrame(selfArg, *vVecArg)
}

// ImGuiContext_GetMenusIdSubmittedThisFrame returns value of ImGuiContext.MenusIdSubmittedThisFrame
//
// A list of menu IDs that were rendered at least once
func (self *Context) MenusIdSubmittedThisFrame() vectors.Vector[ID] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetMenusIdSubmittedThisFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetMenusIdSubmittedThisFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewIDFromC(C.wrap_ImGuiContext_GetMenusIdSubmittedThisFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetTypingSelectState sets value of ImGuiContext.TypingSelectState
//
// State for GetTypingSelectRequest()
func (self Context) SetTypingSelectState(v TypingSelectState) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTypingSelectState(selfArg, internal.ReinterpretCast[C.ImGuiTypingSelectState](vArg))
}

// ImGuiContext_GetTypingSelectState returns value of ImGuiContext.TypingSelectState
//
// State for GetTypingSelectRequest()
func (self *Context) TypingSelectState() TypingSelectState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTypingSelectStateFromC(func() *C.ImGuiTypingSelectState {
		result := C.wrap_ImGuiContext_GetTypingSelectState(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetPlatformImeData sets value of ImGuiContext.PlatformImeData
//
//	// Platform support
//
// Data updated by current frame
func (self Context) SetPlatformImeData(v PlatformImeData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformImeData(selfArg, internal.ReinterpretCast[C.ImGuiPlatformImeData](vArg))
}

// ImGuiContext_GetPlatformImeData returns value of ImGuiContext.PlatformImeData
//
//	// Platform support
//
// Data updated by current frame
func (self *Context) PlatformImeData() PlatformImeData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewPlatformImeDataFromC(func() *C.ImGuiPlatformImeData {
		result := C.wrap_ImGuiContext_GetPlatformImeData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetPlatformImeDataPrev sets value of ImGuiContext.PlatformImeDataPrev
//
// Previous frame data. When changed we call the platform_io.Platform_SetImeDataFn() handler.
func (self Context) SetPlatformImeDataPrev(v PlatformImeData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformImeDataPrev(selfArg, internal.ReinterpretCast[C.ImGuiPlatformImeData](vArg))
}

// ImGuiContext_GetPlatformImeDataPrev returns value of ImGuiContext.PlatformImeDataPrev
//
// Previous frame data. When changed we call the platform_io.Platform_SetImeDataFn() handler.
func (self *Context) PlatformImeDataPrev() PlatformImeData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewPlatformImeDataFromC(func() *C.ImGuiPlatformImeData {
		result := C.wrap_ImGuiContext_GetPlatformImeDataPrev(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetPlatformImeViewport sets value of ImGuiContext.PlatformImeViewport
func (self Context) SetPlatformImeViewport(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetPlatformImeViewport(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetPlatformImeViewport returns value of ImGuiContext.PlatformImeViewport
func (self *Context) PlatformImeViewport() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetPlatformImeViewport(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDockContext sets value of ImGuiContext.DockContext
//
//	// Extensions
//	// FIXME: We could provide an API to register one slot in an array held in ImGuiContext?
func (self Context) SetDockContext(v DockContext) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDockContext(selfArg, internal.ReinterpretCast[C.ImGuiDockContext](vArg))
}

// ImGuiContext_GetDockContext returns value of ImGuiContext.DockContext
//
//	// Extensions
//	// FIXME: We could provide an API to register one slot in an array held in ImGuiContext?
func (self *Context) DockContext() DockContext {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDockContextFromC(func() *C.ImGuiDockContext {
		result := C.wrap_ImGuiContext_GetDockContext(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetSettingsLoaded sets value of ImGuiContext.SettingsLoaded
//
//	// Settings
func (self Context) SetSettingsLoaded(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsLoaded(selfArg, C.bool(v))
}

// ImGuiContext_GetSettingsLoaded returns value of ImGuiContext.SettingsLoaded
//
//	// Settings
func (self *Context) SettingsLoaded() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetSettingsLoaded(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetSettingsDirtyTimer sets value of ImGuiContext.SettingsDirtyTimer
//
// Save .ini Settings to memory when time reaches zero
func (self Context) SetSettingsDirtyTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsDirtyTimer(selfArg, C.float(v))
}

// ImGuiContext_GetSettingsDirtyTimer returns value of ImGuiContext.SettingsDirtyTimer
//
// Save .ini Settings to memory when time reaches zero
func (self *Context) SettingsDirtyTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetSettingsDirtyTimer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetSettingsIniData sets value of ImGuiContext.SettingsIniData
//
// In memory .ini settings
func (self Context) SetSettingsIniData(v TextBuffer) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsIniData(selfArg, internal.ReinterpretCast[C.ImGuiTextBuffer](vArg))
}

// ImGuiContext_GetSettingsIniData returns value of ImGuiContext.SettingsIniData
//
// In memory .ini settings
func (self *Context) SettingsIniData() TextBuffer {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextBufferFromC(func() *C.ImGuiTextBuffer {
		result := C.wrap_ImGuiContext_GetSettingsIniData(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetSettingsHandlers sets value of ImGuiContext.SettingsHandlers
//
// List of .ini settings handlers
func (self Context) SetSettingsHandlers(v vectors.Vector[SettingsHandler]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiSettingsHandler)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiSettingsHandler](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetSettingsHandlers(selfArg, *vVecArg)
}

// ImGuiContext_GetSettingsHandlers returns value of ImGuiContext.SettingsHandlers
//
// List of .ini settings handlers
func (self *Context) SettingsHandlers() vectors.Vector[SettingsHandler] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetSettingsHandlers(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetSettingsHandlers(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewSettingsHandlerFromC(C.wrap_ImGuiContext_GetSettingsHandlers(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetHooks sets value of ImGuiContext.Hooks
//
// Hooks for extensions (e.g. test engine)
func (self Context) SetHooks(v vectors.Vector[ContextHook]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiContextHook)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiContextHook](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHooks(selfArg, *vVecArg)
}

// ImGuiContext_GetHooks returns value of ImGuiContext.Hooks
//
// Hooks for extensions (e.g. test engine)
func (self *Context) Hooks() vectors.Vector[ContextHook] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetHooks(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetHooks(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, NewContextHookFromC(C.wrap_ImGuiContext_GetHooks(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetHookIdNext sets value of ImGuiContext.HookIdNext
//
// Next available HookId
func (self Context) SetHookIdNext(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetHookIdNext(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetHookIdNext returns value of ImGuiContext.HookIdNext
//
// Next available HookId
func (self *Context) HookIdNext() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetHookIdNext(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetLocalizationTable sets value of ImGuiContext.LocalizationTable[ImGuiLocKey_COUNT]
//
//	// Localization
func (self Context) SetLocalizationTable(v *[13]string) {
	vArg := make([]*C.char, len(v))
	for i, vV := range v {
		vVArg, _ := internal.WrapString[C.char](vV)
		vArg[i] = vVArg
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLocalizationTable(selfArg, (**C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() string { result := vV; defer C.free(unsafe.Pointer(result)); return C.GoString(result) }()
	}
}

// ImGuiContext_GetLocalizationTable returns value of ImGuiContext.LocalizationTable[ImGuiLocKey_COUNT]
//
//	// Localization
func (self *Context) LocalizationTable() [13]string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [13]string {
		result := [13]string{}
		resultMirr := C.wrap_ImGuiContext_GetLocalizationTable(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		for i := range result {
			result[i] = func() string {
				result := C.cimgui_const_charPtr_GetAtIdx(resultMirr, C.int(i))
				defer C.free(unsafe.Pointer(result))
				return C.GoString(result)
			}()
		}

		return result
	}()
}

// ImGuiContext_SetLogEnabled sets value of ImGuiContext.LogEnabled
//
//	// Capture/Logging
//
// Currently capturing
func (self Context) SetLogEnabled(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogEnabled(selfArg, C.bool(v))
}

// ImGuiContext_GetLogEnabled returns value of ImGuiContext.LogEnabled
//
//	// Capture/Logging
//
// Currently capturing
func (self *Context) LogEnabled() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetLogEnabled(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetLogType sets value of ImGuiContext.LogType
//
// Capture target
func (self Context) SetLogType(v LogType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogType(selfArg, C.ImGuiLogType(v))
}

// ImGuiContext_GetLogType returns value of ImGuiContext.LogType
//
// Capture target
func (self *Context) LogType() LogType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return LogType(C.wrap_ImGuiContext_GetLogType(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLogBuffer sets value of ImGuiContext.LogBuffer
//
// Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
func (self Context) SetLogBuffer(v TextBuffer) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogBuffer(selfArg, internal.ReinterpretCast[C.ImGuiTextBuffer](vArg))
}

// ImGuiContext_GetLogBuffer returns value of ImGuiContext.LogBuffer
//
// Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
func (self *Context) LogBuffer() TextBuffer {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextBufferFromC(func() *C.ImGuiTextBuffer {
		result := C.wrap_ImGuiContext_GetLogBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetLogNextPrefix sets value of ImGuiContext.LogNextPrefix
func (self Context) SetLogNextPrefix(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogNextPrefix(selfArg, vArg)
}

// ImGuiContext_GetLogNextPrefix returns value of ImGuiContext.LogNextPrefix
func (self *Context) LogNextPrefix() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiContext_GetLogNextPrefix(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiContext_SetLogNextSuffix sets value of ImGuiContext.LogNextSuffix
func (self Context) SetLogNextSuffix(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogNextSuffix(selfArg, vArg)
}

// ImGuiContext_GetLogNextSuffix returns value of ImGuiContext.LogNextSuffix
func (self *Context) LogNextSuffix() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiContext_GetLogNextSuffix(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiContext_SetLogLinePosY sets value of ImGuiContext.LogLinePosY
func (self Context) SetLogLinePosY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogLinePosY(selfArg, C.float(v))
}

// ImGuiContext_GetLogLinePosY returns value of ImGuiContext.LogLinePosY
func (self *Context) LogLinePosY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetLogLinePosY(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLogLineFirstItem sets value of ImGuiContext.LogLineFirstItem
func (self Context) SetLogLineFirstItem(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogLineFirstItem(selfArg, C.bool(v))
}

// ImGuiContext_GetLogLineFirstItem returns value of ImGuiContext.LogLineFirstItem
func (self *Context) LogLineFirstItem() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetLogLineFirstItem(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetLogDepthRef sets value of ImGuiContext.LogDepthRef
func (self Context) SetLogDepthRef(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogDepthRef(selfArg, C.int(v))
}

// ImGuiContext_GetLogDepthRef returns value of ImGuiContext.LogDepthRef
func (self *Context) LogDepthRef() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetLogDepthRef(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLogDepthToExpand sets value of ImGuiContext.LogDepthToExpand
func (self Context) SetLogDepthToExpand(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogDepthToExpand(selfArg, C.int(v))
}

// ImGuiContext_GetLogDepthToExpand returns value of ImGuiContext.LogDepthToExpand
func (self *Context) LogDepthToExpand() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetLogDepthToExpand(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetLogDepthToExpandDefault sets value of ImGuiContext.LogDepthToExpandDefault
//
// Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.
func (self Context) SetLogDepthToExpandDefault(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetLogDepthToExpandDefault(selfArg, C.int(v))
}

// ImGuiContext_GetLogDepthToExpandDefault returns value of ImGuiContext.LogDepthToExpandDefault
//
// Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.
func (self *Context) LogDepthToExpandDefault() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetLogDepthToExpandDefault(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetErrorCallback sets value of ImGuiContext.ErrorCallback
//
//	// Error Handling
//
// = NULL. May be exposed in public API eventually.
func (self Context) SetErrorCallback(v ErrorCallback) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetErrorCallback(selfArg, internal.ReinterpretCast[C.ImGuiErrorCallback](vArg))
}

// ImGuiContext_GetErrorCallback returns value of ImGuiContext.ErrorCallback
//
//	// Error Handling
//
// = NULL. May be exposed in public API eventually.
func (self *Context) ErrorCallback() ErrorCallback {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewErrorCallbackFromC(func() *C.ImGuiErrorCallback {
		result := C.wrap_ImGuiContext_GetErrorCallback(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetErrorCallbackUserData sets value of ImGuiContext.ErrorCallbackUserData
//
// = NULL
func (self Context) SetErrorCallbackUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetErrorCallbackUserData(selfArg, C.uintptr_t(v))
}

// ImGuiContext_GetErrorCallbackUserData returns value of ImGuiContext.ErrorCallbackUserData
//
// = NULL
func (self *Context) ErrorCallbackUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiContext_GetErrorCallbackUserData(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetErrorTooltipLockedPos sets value of ImGuiContext.ErrorTooltipLockedPos
func (self Context) SetErrorTooltipLockedPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetErrorTooltipLockedPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiContext_GetErrorTooltipLockedPos returns value of ImGuiContext.ErrorTooltipLockedPos
func (self *Context) ErrorTooltipLockedPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiContext_GetErrorTooltipLockedPos(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetErrorFirst sets value of ImGuiContext.ErrorFirst
func (self Context) SetErrorFirst(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetErrorFirst(selfArg, C.bool(v))
}

// ImGuiContext_GetErrorFirst returns value of ImGuiContext.ErrorFirst
func (self *Context) ErrorFirst() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetErrorFirst(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetErrorCountCurrentFrame sets value of ImGuiContext.ErrorCountCurrentFrame
//
// [Internal] Number of errors submitted this frame.
func (self Context) SetErrorCountCurrentFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetErrorCountCurrentFrame(selfArg, C.int(v))
}

// ImGuiContext_GetErrorCountCurrentFrame returns value of ImGuiContext.ErrorCountCurrentFrame
//
// [Internal] Number of errors submitted this frame.
func (self *Context) ErrorCountCurrentFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetErrorCountCurrentFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetStackSizesInNewFrame sets value of ImGuiContext.StackSizesInNewFrame
//
// [Internal]
func (self Context) SetStackSizesInNewFrame(v ErrorRecoveryState) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetStackSizesInNewFrame(selfArg, internal.ReinterpretCast[C.ImGuiErrorRecoveryState](vArg))
}

// ImGuiContext_GetStackSizesInNewFrame returns value of ImGuiContext.StackSizesInNewFrame
//
// [Internal]
func (self *Context) StackSizesInNewFrame() ErrorRecoveryState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewErrorRecoveryStateFromC(func() *C.ImGuiErrorRecoveryState {
		result := C.wrap_ImGuiContext_GetStackSizesInNewFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetStackSizesInBeginForCurrentWindow sets value of ImGuiContext.StackSizesInBeginForCurrentWindow
//
// [Internal]
func (self Context) SetStackSizesInBeginForCurrentWindow(v *ErrorRecoveryState) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetStackSizesInBeginForCurrentWindow(selfArg, internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](vArg))
}

// ImGuiContext_GetStackSizesInBeginForCurrentWindow returns value of ImGuiContext.StackSizesInBeginForCurrentWindow
//
// [Internal]
func (self *Context) StackSizesInBeginForCurrentWindow() *ErrorRecoveryState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewErrorRecoveryStateFromC(C.wrap_ImGuiContext_GetStackSizesInBeginForCurrentWindow(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugDrawIdConflictsCount sets value of ImGuiContext.DebugDrawIdConflictsCount
//
//	// Debug Tools
//	// (some of the highly frequently used data are interleaved in other structures above: DebugBreakXXX fields, DebugHookIdInfo, DebugLocateId etc.)
//
// Locked count (preserved when holding CTRL)
func (self Context) SetDebugDrawIdConflictsCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugDrawIdConflictsCount(selfArg, C.int(v))
}

// ImGuiContext_GetDebugDrawIdConflictsCount returns value of ImGuiContext.DebugDrawIdConflictsCount
//
//	// Debug Tools
//	// (some of the highly frequently used data are interleaved in other structures above: DebugBreakXXX fields, DebugHookIdInfo, DebugLocateId etc.)
//
// Locked count (preserved when holding CTRL)
func (self *Context) DebugDrawIdConflictsCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDebugDrawIdConflictsCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugLogFlags sets value of ImGuiContext.DebugLogFlags
func (self Context) SetDebugLogFlags(v DebugLogFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogFlags(selfArg, C.ImGuiDebugLogFlags(v))
}

// ImGuiContext_GetDebugLogFlags returns value of ImGuiContext.DebugLogFlags
func (self *Context) DebugLogFlags() DebugLogFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DebugLogFlags(C.wrap_ImGuiContext_GetDebugLogFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugLogBuf sets value of ImGuiContext.DebugLogBuf
func (self Context) SetDebugLogBuf(v TextBuffer) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogBuf(selfArg, internal.ReinterpretCast[C.ImGuiTextBuffer](vArg))
}

// ImGuiContext_GetDebugLogBuf returns value of ImGuiContext.DebugLogBuf
func (self *Context) DebugLogBuf() TextBuffer {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextBufferFromC(func() *C.ImGuiTextBuffer {
		result := C.wrap_ImGuiContext_GetDebugLogBuf(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugLogIndex sets value of ImGuiContext.DebugLogIndex
func (self Context) SetDebugLogIndex(v TextIndex) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogIndex(selfArg, internal.ReinterpretCast[C.ImGuiTextIndex](vArg))
}

// ImGuiContext_GetDebugLogIndex returns value of ImGuiContext.DebugLogIndex
func (self *Context) DebugLogIndex() TextIndex {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextIndexFromC(func() *C.ImGuiTextIndex {
		result := C.wrap_ImGuiContext_GetDebugLogIndex(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugLogSkippedErrors sets value of ImGuiContext.DebugLogSkippedErrors
func (self Context) SetDebugLogSkippedErrors(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogSkippedErrors(selfArg, C.int(v))
}

// ImGuiContext_GetDebugLogSkippedErrors returns value of ImGuiContext.DebugLogSkippedErrors
func (self *Context) DebugLogSkippedErrors() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetDebugLogSkippedErrors(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugLogAutoDisableFlags sets value of ImGuiContext.DebugLogAutoDisableFlags
func (self Context) SetDebugLogAutoDisableFlags(v DebugLogFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogAutoDisableFlags(selfArg, C.ImGuiDebugLogFlags(v))
}

// ImGuiContext_GetDebugLogAutoDisableFlags returns value of ImGuiContext.DebugLogAutoDisableFlags
func (self *Context) DebugLogAutoDisableFlags() DebugLogFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DebugLogFlags(C.wrap_ImGuiContext_GetDebugLogAutoDisableFlags(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugLogAutoDisableFrames sets value of ImGuiContext.DebugLogAutoDisableFrames
func (self Context) SetDebugLogAutoDisableFrames(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLogAutoDisableFrames(selfArg, C.ImU8(v))
}

// ImGuiContext_GetDebugLogAutoDisableFrames returns value of ImGuiContext.DebugLogAutoDisableFrames
func (self *Context) DebugLogAutoDisableFrames() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiContext_GetDebugLogAutoDisableFrames(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugLocateFrames sets value of ImGuiContext.DebugLocateFrames
//
// For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.
func (self Context) SetDebugLocateFrames(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugLocateFrames(selfArg, C.ImU8(v))
}

// ImGuiContext_GetDebugLocateFrames returns value of ImGuiContext.DebugLocateFrames
//
// For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.
func (self *Context) DebugLocateFrames() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiContext_GetDebugLocateFrames(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugBreakInLocateId sets value of ImGuiContext.DebugBreakInLocateId
//
// Debug break in ItemAdd() call for g.DebugLocateId.
func (self Context) SetDebugBreakInLocateId(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugBreakInLocateId(selfArg, C.bool(v))
}

// ImGuiContext_GetDebugBreakInLocateId returns value of ImGuiContext.DebugBreakInLocateId
//
// Debug break in ItemAdd() call for g.DebugLocateId.
func (self *Context) DebugBreakInLocateId() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDebugBreakInLocateId(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDebugBreakKeyChord sets value of ImGuiContext.DebugBreakKeyChord
//
// = ImGuiKey_Pause
func (self Context) SetDebugBreakKeyChord(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugBreakKeyChord(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiContext_GetDebugBreakKeyChord returns value of ImGuiContext.DebugBreakKeyChord
//
// = ImGuiKey_Pause
func (self *Context) DebugBreakKeyChord() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiContext_GetDebugBreakKeyChord(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugBeginReturnValueCullDepth sets value of ImGuiContext.DebugBeginReturnValueCullDepth
//
// Cycle between 0..9 then wrap around.
func (self Context) SetDebugBeginReturnValueCullDepth(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugBeginReturnValueCullDepth(selfArg, C.ImS8(v))
}

// ImGuiContext_GetDebugBeginReturnValueCullDepth returns value of ImGuiContext.DebugBeginReturnValueCullDepth
//
// Cycle between 0..9 then wrap around.
func (self *Context) DebugBeginReturnValueCullDepth() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiContext_GetDebugBeginReturnValueCullDepth(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugItemPickerActive sets value of ImGuiContext.DebugItemPickerActive
//
// Item picker is active (started with DebugStartItemPicker())
func (self Context) SetDebugItemPickerActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugItemPickerActive(selfArg, C.bool(v))
}

// ImGuiContext_GetDebugItemPickerActive returns value of ImGuiContext.DebugItemPickerActive
//
// Item picker is active (started with DebugStartItemPicker())
func (self *Context) DebugItemPickerActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiContext_GetDebugItemPickerActive(internal.ReinterpretCast[*C.ImGuiContext](selfArg)) == C.bool(true)
}

// ImGuiContext_SetDebugItemPickerMouseButton sets value of ImGuiContext.DebugItemPickerMouseButton
func (self Context) SetDebugItemPickerMouseButton(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugItemPickerMouseButton(selfArg, C.ImU8(v))
}

// ImGuiContext_GetDebugItemPickerMouseButton returns value of ImGuiContext.DebugItemPickerMouseButton
func (self *Context) DebugItemPickerMouseButton() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiContext_GetDebugItemPickerMouseButton(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugItemPickerBreakId sets value of ImGuiContext.DebugItemPickerBreakId
//
// Will call IM_DEBUG_BREAK() when encountering this ID
func (self Context) SetDebugItemPickerBreakId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugItemPickerBreakId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContext_GetDebugItemPickerBreakId returns value of ImGuiContext.DebugItemPickerBreakId
//
// Will call IM_DEBUG_BREAK() when encountering this ID
func (self *Context) DebugItemPickerBreakId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContext_GetDebugItemPickerBreakId(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugFlashStyleColorTime sets value of ImGuiContext.DebugFlashStyleColorTime
func (self Context) SetDebugFlashStyleColorTime(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugFlashStyleColorTime(selfArg, C.float(v))
}

// ImGuiContext_GetDebugFlashStyleColorTime returns value of ImGuiContext.DebugFlashStyleColorTime
func (self *Context) DebugFlashStyleColorTime() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetDebugFlashStyleColorTime(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetDebugFlashStyleColorBackup sets value of ImGuiContext.DebugFlashStyleColorBackup
func (self Context) SetDebugFlashStyleColorBackup(v Vec4) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugFlashStyleColorBackup(selfArg, internal.ReinterpretCast[C.ImVec4](v.ToC()))
}

// ImGuiContext_GetDebugFlashStyleColorBackup returns value of ImGuiContext.DebugFlashStyleColorBackup
func (self *Context) DebugFlashStyleColorBackup() Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec4 {
		out := C.wrap_ImGuiContext_GetDebugFlashStyleColorBackup(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return *(&Vec4{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiContext_SetDebugMetricsConfig sets value of ImGuiContext.DebugMetricsConfig
func (self Context) SetDebugMetricsConfig(v MetricsConfig) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugMetricsConfig(selfArg, internal.ReinterpretCast[C.ImGuiMetricsConfig](vArg))
}

// ImGuiContext_GetDebugMetricsConfig returns value of ImGuiContext.DebugMetricsConfig
func (self *Context) DebugMetricsConfig() MetricsConfig {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewMetricsConfigFromC(func() *C.ImGuiMetricsConfig {
		result := C.wrap_ImGuiContext_GetDebugMetricsConfig(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugIDStackTool sets value of ImGuiContext.DebugIDStackTool
func (self Context) SetDebugIDStackTool(v IDStackTool) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugIDStackTool(selfArg, internal.ReinterpretCast[C.ImGuiIDStackTool](vArg))
}

// ImGuiContext_GetDebugIDStackTool returns value of ImGuiContext.DebugIDStackTool
func (self *Context) DebugIDStackTool() IDStackTool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDStackToolFromC(func() *C.ImGuiIDStackTool {
		result := C.wrap_ImGuiContext_GetDebugIDStackTool(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugAllocInfo sets value of ImGuiContext.DebugAllocInfo
func (self Context) SetDebugAllocInfo(v DebugAllocInfo) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugAllocInfo(selfArg, internal.ReinterpretCast[C.ImGuiDebugAllocInfo](vArg))
}

// ImGuiContext_GetDebugAllocInfo returns value of ImGuiContext.DebugAllocInfo
func (self *Context) DebugAllocInfo() DebugAllocInfo {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDebugAllocInfoFromC(func() *C.ImGuiDebugAllocInfo {
		result := C.wrap_ImGuiContext_GetDebugAllocInfo(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		return &result
	}())
}

// ImGuiContext_SetDebugHoveredDockNode sets value of ImGuiContext.DebugHoveredDockNode
//
// Hovered dock node.
func (self Context) SetDebugHoveredDockNode(v *DockNode) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetDebugHoveredDockNode(selfArg, internal.ReinterpretCast[*C.ImGuiDockNode](vArg))
}

// ImGuiContext_GetDebugHoveredDockNode returns value of ImGuiContext.DebugHoveredDockNode
//
// Hovered dock node.
func (self *Context) DebugHoveredDockNode() *DockNode {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDockNodeFromC(C.wrap_ImGuiContext_GetDebugHoveredDockNode(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFramerateSecPerFrame sets value of ImGuiContext.FramerateSecPerFrame[60]
//
//	// Misc
//
// Calculate estimate of framerate for user over the last 60 frames..
func (self Context) SetFramerateSecPerFrame(v *[60]float32) {
	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFramerateSecPerFrame(selfArg, (*C.float)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = float32(vV)
	}
}

// ImGuiContext_GetFramerateSecPerFrame returns value of ImGuiContext.FramerateSecPerFrame[60]
//
//	// Misc
//
// Calculate estimate of framerate for user over the last 60 frames..
func (self *Context) FramerateSecPerFrame() [60]float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [60]float32 {
		result := [60]float32{}
		resultMirr := C.wrap_ImGuiContext_GetFramerateSecPerFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		for i := range result {
			result[i] = float32(C.cimgui_float_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiContext_SetFramerateSecPerFrameIdx sets value of ImGuiContext.FramerateSecPerFrameIdx
func (self Context) SetFramerateSecPerFrameIdx(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFramerateSecPerFrameIdx(selfArg, C.int(v))
}

// ImGuiContext_GetFramerateSecPerFrameIdx returns value of ImGuiContext.FramerateSecPerFrameIdx
func (self *Context) FramerateSecPerFrameIdx() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFramerateSecPerFrameIdx(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFramerateSecPerFrameCount sets value of ImGuiContext.FramerateSecPerFrameCount
func (self Context) SetFramerateSecPerFrameCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFramerateSecPerFrameCount(selfArg, C.int(v))
}

// ImGuiContext_GetFramerateSecPerFrameCount returns value of ImGuiContext.FramerateSecPerFrameCount
func (self *Context) FramerateSecPerFrameCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetFramerateSecPerFrameCount(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetFramerateSecPerFrameAccum sets value of ImGuiContext.FramerateSecPerFrameAccum
func (self Context) SetFramerateSecPerFrameAccum(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetFramerateSecPerFrameAccum(selfArg, C.float(v))
}

// ImGuiContext_GetFramerateSecPerFrameAccum returns value of ImGuiContext.FramerateSecPerFrameAccum
func (self *Context) FramerateSecPerFrameAccum() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiContext_GetFramerateSecPerFrameAccum(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWantCaptureMouseNextFrame sets value of ImGuiContext.WantCaptureMouseNextFrame
//
// Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.
func (self Context) SetWantCaptureMouseNextFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWantCaptureMouseNextFrame(selfArg, C.int(v))
}

// ImGuiContext_GetWantCaptureMouseNextFrame returns value of ImGuiContext.WantCaptureMouseNextFrame
//
// Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.
func (self *Context) WantCaptureMouseNextFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWantCaptureMouseNextFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWantCaptureKeyboardNextFrame sets value of ImGuiContext.WantCaptureKeyboardNextFrame
//
// "
func (self Context) SetWantCaptureKeyboardNextFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWantCaptureKeyboardNextFrame(selfArg, C.int(v))
}

// ImGuiContext_GetWantCaptureKeyboardNextFrame returns value of ImGuiContext.WantCaptureKeyboardNextFrame
//
// "
func (self *Context) WantCaptureKeyboardNextFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWantCaptureKeyboardNextFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetWantTextInputNextFrame sets value of ImGuiContext.WantTextInputNextFrame
func (self Context) SetWantTextInputNextFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetWantTextInputNextFrame(selfArg, C.int(v))
}

// ImGuiContext_GetWantTextInputNextFrame returns value of ImGuiContext.WantTextInputNextFrame
func (self *Context) WantTextInputNextFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiContext_GetWantTextInputNextFrame(internal.ReinterpretCast[*C.ImGuiContext](selfArg)))
}

// ImGuiContext_SetTempBuffer sets value of ImGuiContext.TempBuffer
//
// Temporary text buffer
func (self Context) SetTempBuffer(v vectors.Vector[int8]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.char, int8](vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTempBuffer(selfArg, *vVecArg)
}

// ImGuiContext_GetTempBuffer returns value of ImGuiContext.TempBuffer
//
// Temporary text buffer
func (self *Context) TempBuffer() vectors.Vector[int8] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiContext_GetTempBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Size, C.wrap_ImGuiContext_GetTempBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Capacity, (*int8)(C.wrap_ImGuiContext_GetTempBuffer(internal.ReinterpretCast[*C.ImGuiContext](selfArg)).Data))
}

// ImGuiContext_SetTempKeychordName sets value of ImGuiContext.TempKeychordName[64]
func (self Context) SetTempKeychordName(v *[64]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContext_SetTempKeychordName(selfArg, (*C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = rune(vV)
	}
}

// ImGuiContext_GetTempKeychordName returns value of ImGuiContext.TempKeychordName[64]
func (self *Context) TempKeychordName() [64]rune {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [64]rune {
		result := [64]rune{}
		resultMirr := C.wrap_ImGuiContext_GetTempKeychordName(internal.ReinterpretCast[*C.ImGuiContext](selfArg))
		for i := range result {
			result[i] = rune(C.cimgui_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiContextHook_SetHookId sets value of ImGuiContextHook.HookId
//
// A unique ID assigned by AddContextHook()
func (self ContextHook) SetHookId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetHookId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContextHook_GetHookId returns value of ImGuiContextHook.HookId
//
// A unique ID assigned by AddContextHook()
func (self *ContextHook) HookId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContextHook_GetHookId(internal.ReinterpretCast[*C.ImGuiContextHook](selfArg))
		return &result
	}())
}

// ImGuiContextHook_SetType sets value of ImGuiContextHook.Type
func (self ContextHook) SetType(v ContextHookType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetType(selfArg, C.ImGuiContextHookType(v))
}

// ImGuiContextHook_GetType returns value of ImGuiContextHook.Type
func (self *ContextHook) Type() ContextHookType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ContextHookType(C.wrap_ImGuiContextHook_GetType(internal.ReinterpretCast[*C.ImGuiContextHook](selfArg)))
}

// ImGuiContextHook_SetOwner sets value of ImGuiContextHook.Owner
func (self ContextHook) SetOwner(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetOwner(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiContextHook_GetOwner returns value of ImGuiContextHook.Owner
func (self *ContextHook) Owner() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiContextHook_GetOwner(internal.ReinterpretCast[*C.ImGuiContextHook](selfArg))
		return &result
	}())
}

// ImGuiContextHook_SetCallback sets value of ImGuiContextHook.Callback
func (self ContextHook) SetCallback(v ContextHookCallback) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetCallback(selfArg, internal.ReinterpretCast[C.ImGuiContextHookCallback](vArg))
}

// ImGuiContextHook_GetCallback returns value of ImGuiContextHook.Callback
func (self *ContextHook) Callback() ContextHookCallback {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewContextHookCallbackFromC(func() *C.ImGuiContextHookCallback {
		result := C.wrap_ImGuiContextHook_GetCallback(internal.ReinterpretCast[*C.ImGuiContextHook](selfArg))
		return &result
	}())
}

// ImGuiContextHook_SetUserData sets value of ImGuiContextHook.UserData
func (self ContextHook) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiContextHook_SetUserData(selfArg, C.uintptr_t(v))
}

// ImGuiContextHook_GetUserData returns value of ImGuiContextHook.UserData
func (self *ContextHook) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiContextHook_GetUserData(internal.ReinterpretCast[*C.ImGuiContextHook](selfArg)))
}

// ImGuiDataTypeInfo_SetSize sets value of ImGuiDataTypeInfo.Size
//
// Size in bytes
func (self DataTypeInfo) SetSize(v uint64) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetSize(selfArg, C.xulong(v))
}

// ImGuiDataTypeInfo_GetSize returns value of ImGuiDataTypeInfo.Size
//
// Size in bytes
func (self *DataTypeInfo) Size() uint64 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint64(C.wrap_ImGuiDataTypeInfo_GetSize(internal.ReinterpretCast[*C.ImGuiDataTypeInfo](selfArg)))
}

// ImGuiDataTypeInfo_SetName sets value of ImGuiDataTypeInfo.Name
//
// Short descriptive name for the type, for debugging
func (self DataTypeInfo) SetName(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetName(selfArg, vArg)
}

// ImGuiDataTypeInfo_GetName returns value of ImGuiDataTypeInfo.Name
//
// Short descriptive name for the type, for debugging
func (self *DataTypeInfo) Name() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiDataTypeInfo_GetName(internal.ReinterpretCast[*C.ImGuiDataTypeInfo](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiDataTypeInfo_SetPrintFmt sets value of ImGuiDataTypeInfo.PrintFmt
//
// Default printf format for the type
func (self DataTypeInfo) SetPrintFmt(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetPrintFmt(selfArg, vArg)
}

// ImGuiDataTypeInfo_GetPrintFmt returns value of ImGuiDataTypeInfo.PrintFmt
//
// Default printf format for the type
func (self *DataTypeInfo) PrintFmt() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiDataTypeInfo_GetPrintFmt(internal.ReinterpretCast[*C.ImGuiDataTypeInfo](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiDataTypeInfo_SetScanFmt sets value of ImGuiDataTypeInfo.ScanFmt
//
// Default scanf format for the type
func (self DataTypeInfo) SetScanFmt(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeInfo_SetScanFmt(selfArg, vArg)
}

// ImGuiDataTypeInfo_GetScanFmt returns value of ImGuiDataTypeInfo.ScanFmt
//
// Default scanf format for the type
func (self *DataTypeInfo) ScanFmt() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiDataTypeInfo_GetScanFmt(internal.ReinterpretCast[*C.ImGuiDataTypeInfo](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiDataTypeStorage_SetData sets value of ImGuiDataTypeStorage.Data[8]
//
// Opaque storage to fit any data up to ImGuiDataType_COUNT
func (self DataTypeStorage) SetData(v *[8]byte) {
	vArg := make([]C.ImU8, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU8(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataTypeStorage_SetData(selfArg, (*C.ImU8)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = byte(vV)
	}
}

// ImGuiDataTypeStorage_GetData returns value of ImGuiDataTypeStorage.Data[8]
//
// Opaque storage to fit any data up to ImGuiDataType_COUNT
func (self *DataTypeStorage) Data() [8]byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [8]byte {
		result := [8]byte{}
		resultMirr := C.wrap_ImGuiDataTypeStorage_GetData(internal.ReinterpretCast[*C.ImGuiDataTypeStorage](selfArg))
		for i := range result {
			result[i] = byte(C.cimgui_ImU8_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiDataVarInfo_SetType sets value of ImGuiDataVarInfo.Type
func (self DataVarInfo) SetType(v DataType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataVarInfo_SetType(selfArg, C.ImGuiDataType(v))
}

// ImGuiDataVarInfo_GetType returns value of ImGuiDataVarInfo.Type
func (self *DataVarInfo) Type() DataType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DataType(C.wrap_ImGuiDataVarInfo_GetType(internal.ReinterpretCast[*C.ImGuiDataVarInfo](selfArg)))
}

// ImGuiDataVarInfo_SetCount sets value of ImGuiDataVarInfo.Count
//
// 1+
func (self DataVarInfo) SetCount(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataVarInfo_SetCount(selfArg, C.ImU32(v))
}

// ImGuiDataVarInfo_GetCount returns value of ImGuiDataVarInfo.Count
//
// 1+
func (self *DataVarInfo) Count() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiDataVarInfo_GetCount(internal.ReinterpretCast[*C.ImGuiDataVarInfo](selfArg)))
}

// ImGuiDataVarInfo_SetOffset sets value of ImGuiDataVarInfo.Offset
//
// Offset in parent structure
func (self DataVarInfo) SetOffset(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDataVarInfo_SetOffset(selfArg, C.ImU32(v))
}

// ImGuiDataVarInfo_GetOffset returns value of ImGuiDataVarInfo.Offset
//
// Offset in parent structure
func (self *DataVarInfo) Offset() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiDataVarInfo_GetOffset(internal.ReinterpretCast[*C.ImGuiDataVarInfo](selfArg)))
}

// ImGuiDebugAllocEntry_SetFrameCount sets value of ImGuiDebugAllocEntry.FrameCount
func (self DebugAllocEntry) SetFrameCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDebugAllocEntry_SetFrameCount(selfArg, C.int(v))
}

// ImGuiDebugAllocEntry_GetFrameCount returns value of ImGuiDebugAllocEntry.FrameCount
func (self *DebugAllocEntry) FrameCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDebugAllocEntry_GetFrameCount(internal.ReinterpretCast[*C.ImGuiDebugAllocEntry](selfArg)))
}

// ImGuiDebugAllocEntry_SetAllocCount sets value of ImGuiDebugAllocEntry.AllocCount
func (self DebugAllocEntry) SetAllocCount(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDebugAllocEntry_SetAllocCount(selfArg, C.ImS16(v))
}

// ImGuiDebugAllocEntry_GetAllocCount returns value of ImGuiDebugAllocEntry.AllocCount
func (self *DebugAllocEntry) AllocCount() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiDebugAllocEntry_GetAllocCount(internal.ReinterpretCast[*C.ImGuiDebugAllocEntry](selfArg)))
}

// ImGuiDebugAllocEntry_SetFreeCount sets value of ImGuiDebugAllocEntry.FreeCount
func (self DebugAllocEntry) SetFreeCount(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDebugAllocEntry_SetFreeCount(selfArg, C.ImS16(v))
}

// ImGuiDebugAllocEntry_GetFreeCount returns value of ImGuiDebugAllocEntry.FreeCount
func (self *DebugAllocEntry) FreeCount() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiDebugAllocEntry_GetFreeCount(internal.ReinterpretCast[*C.ImGuiDebugAllocEntry](selfArg)))
}

// ImGuiDebugAllocInfo_SetTotalAllocCount sets value of ImGuiDebugAllocInfo.TotalAllocCount
//
// Number of call to MemAlloc().
func (self DebugAllocInfo) SetTotalAllocCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDebugAllocInfo_SetTotalAllocCount(selfArg, C.int(v))
}

// ImGuiDebugAllocInfo_GetTotalAllocCount returns value of ImGuiDebugAllocInfo.TotalAllocCount
//
// Number of call to MemAlloc().
func (self *DebugAllocInfo) TotalAllocCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDebugAllocInfo_GetTotalAllocCount(internal.ReinterpretCast[*C.ImGuiDebugAllocInfo](selfArg)))
}

// ImGuiDebugAllocInfo_SetTotalFreeCount sets value of ImGuiDebugAllocInfo.TotalFreeCount
func (self DebugAllocInfo) SetTotalFreeCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDebugAllocInfo_SetTotalFreeCount(selfArg, C.int(v))
}

// ImGuiDebugAllocInfo_GetTotalFreeCount returns value of ImGuiDebugAllocInfo.TotalFreeCount
func (self *DebugAllocInfo) TotalFreeCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDebugAllocInfo_GetTotalFreeCount(internal.ReinterpretCast[*C.ImGuiDebugAllocInfo](selfArg)))
}

// ImGuiDebugAllocInfo_SetLastEntriesIdx sets value of ImGuiDebugAllocInfo.LastEntriesIdx
//
// Current index in buffer
func (self DebugAllocInfo) SetLastEntriesIdx(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDebugAllocInfo_SetLastEntriesIdx(selfArg, C.ImS16(v))
}

// ImGuiDebugAllocInfo_GetLastEntriesIdx returns value of ImGuiDebugAllocInfo.LastEntriesIdx
//
// Current index in buffer
func (self *DebugAllocInfo) LastEntriesIdx() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiDebugAllocInfo_GetLastEntriesIdx(internal.ReinterpretCast[*C.ImGuiDebugAllocInfo](selfArg)))
}

// ImGuiDebugAllocInfo_SetLastEntriesBuf sets value of ImGuiDebugAllocInfo.LastEntriesBuf[6]
//
// Track last 6 frames that had allocations
func (self DebugAllocInfo) SetLastEntriesBuf(v *[6]DebugAllocEntry) {
	vArg := make([]C.ImGuiDebugAllocEntry, len(v))
	for i, vV := range v {
		vVArg, _ := vV.C()
		vArg[i] = internal.ReinterpretCast[C.ImGuiDebugAllocEntry](vVArg)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDebugAllocInfo_SetLastEntriesBuf(selfArg, (*C.ImGuiDebugAllocEntry)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = *NewDebugAllocEntryFromC(func() *C.ImGuiDebugAllocEntry { result := vV; return &result }())
	}
}

// ImGuiDebugAllocInfo_GetLastEntriesBuf returns value of ImGuiDebugAllocInfo.LastEntriesBuf[6]
//
// Track last 6 frames that had allocations
func (self *DebugAllocInfo) LastEntriesBuf() [6]DebugAllocEntry {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [6]DebugAllocEntry {
		result := [6]DebugAllocEntry{}
		resultMirr := C.wrap_ImGuiDebugAllocInfo_GetLastEntriesBuf(internal.ReinterpretCast[*C.ImGuiDebugAllocInfo](selfArg))
		for i := range result {
			result[i] = *NewDebugAllocEntryFromC(func() *C.ImGuiDebugAllocEntry {
				result := C.cimgui_ImGuiDebugAllocEntry_GetAtIdx(resultMirr, C.int(i))
				return &result
			}())
		}

		return result
	}()
}

// ImGuiDockContext_SetNodes sets value of ImGuiDockContext.Nodes
//
// Map ID -> ImGuiDockNode*: Active nodes
func (self DockContext) SetNodes(v Storage) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetNodes(selfArg, internal.ReinterpretCast[C.ImGuiStorage](vArg))
}

// ImGuiDockContext_GetNodes returns value of ImGuiDockContext.Nodes
//
// Map ID -> ImGuiDockNode*: Active nodes
func (self *DockContext) Nodes() Storage {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewStorageFromC(func() *C.ImGuiStorage {
		result := C.wrap_ImGuiDockContext_GetNodes(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg))
		return &result
	}())
}

// ImGuiDockContext_SetRequests sets value of ImGuiDockContext.Requests
func (self DockContext) SetRequests(v vectors.Vector[DockRequest]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiDockRequest)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiDockRequest](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetRequests(selfArg, *vVecArg)
}

// ImGuiDockContext_GetRequests returns value of ImGuiDockContext.Requests
func (self *DockContext) Requests() vectors.Vector[DockRequest] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiDockContext_GetRequests(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg)).Size, C.wrap_ImGuiDockContext_GetRequests(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg)).Capacity, NewDockRequestFromC(C.wrap_ImGuiDockContext_GetRequests(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg)).Data))
}

// ImGuiDockContext_SetNodesSettings sets value of ImGuiDockContext.NodesSettings
func (self DockContext) SetNodesSettings(v vectors.Vector[DockNodeSettings]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiDockNodeSettings)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiDockNodeSettings](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetNodesSettings(selfArg, *vVecArg)
}

// ImGuiDockContext_GetNodesSettings returns value of ImGuiDockContext.NodesSettings
func (self *DockContext) NodesSettings() vectors.Vector[DockNodeSettings] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiDockContext_GetNodesSettings(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg)).Size, C.wrap_ImGuiDockContext_GetNodesSettings(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg)).Capacity, NewDockNodeSettingsFromC(C.wrap_ImGuiDockContext_GetNodesSettings(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg)).Data))
}

// ImGuiDockContext_SetWantFullRebuild sets value of ImGuiDockContext.WantFullRebuild
func (self DockContext) SetWantFullRebuild(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockContext_SetWantFullRebuild(selfArg, C.bool(v))
}

// ImGuiDockContext_GetWantFullRebuild returns value of ImGuiDockContext.WantFullRebuild
func (self *DockContext) WantFullRebuild() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockContext_GetWantFullRebuild(internal.ReinterpretCast[*C.ImGuiDockContext](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetID sets value of ImGuiDockNode.ID
func (self DockNode) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiDockNode_GetID returns value of ImGuiDockNode.ID
func (self *DockNode) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiDockNode_GetID(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return &result
	}())
}

// ImGuiDockNode_SetSharedFlags sets value of ImGuiDockNode.SharedFlags
//
// (Write) Flags shared by all nodes of a same dockspace hierarchy (inherited from the root node)
func (self DockNode) SetSharedFlags(v DockNodeFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSharedFlags(selfArg, C.ImGuiDockNodeFlags(v))
}

// ImGuiDockNode_GetSharedFlags returns value of ImGuiDockNode.SharedFlags
//
// (Write) Flags shared by all nodes of a same dockspace hierarchy (inherited from the root node)
func (self *DockNode) SharedFlags() DockNodeFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiDockNode_GetSharedFlags(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetLocalFlagsInWindows sets value of ImGuiDockNode.LocalFlagsInWindows
//
// (Write) Flags specific to this node, applied from windows
func (self DockNode) SetLocalFlagsInWindows(v DockNodeFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLocalFlagsInWindows(selfArg, C.ImGuiDockNodeFlags(v))
}

// ImGuiDockNode_GetLocalFlagsInWindows returns value of ImGuiDockNode.LocalFlagsInWindows
//
// (Write) Flags specific to this node, applied from windows
func (self *DockNode) LocalFlagsInWindows() DockNodeFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiDockNode_GetLocalFlagsInWindows(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetMergedFlags sets value of ImGuiDockNode.MergedFlags
//
// (Read)  Effective flags (== SharedFlags | LocalFlagsInNode | LocalFlagsInWindows)
func (self DockNode) SetMergedFlags(v DockNodeFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetMergedFlags(selfArg, C.ImGuiDockNodeFlags(v))
}

// ImGuiDockNode_GetMergedFlags returns value of ImGuiDockNode.MergedFlags
//
// (Read)  Effective flags (== SharedFlags | LocalFlagsInNode | LocalFlagsInWindows)
func (self *DockNode) MergedFlags() DockNodeFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiDockNode_GetMergedFlags(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetState sets value of ImGuiDockNode.State
func (self DockNode) SetState(v DockNodeState) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetState(selfArg, C.ImGuiDockNodeState(v))
}

// ImGuiDockNode_GetState returns value of ImGuiDockNode.State
func (self *DockNode) State() DockNodeState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DockNodeState(C.wrap_ImGuiDockNode_GetState(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetParentNode sets value of ImGuiDockNode.ParentNode
func (self DockNode) SetParentNode(v *DockNode) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetParentNode(selfArg, internal.ReinterpretCast[*C.ImGuiDockNode](vArg))
}

// ImGuiDockNode_GetParentNode returns value of ImGuiDockNode.ParentNode
func (self *DockNode) ParentNode() *DockNode {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDockNodeFromC(C.wrap_ImGuiDockNode_GetParentNode(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetChildNodes sets value of ImGuiDockNode.ChildNodes[2]
//
// [Split node only] Child nodes (left/right or top/bottom). Consider switching to an array.
func (self DockNode) SetChildNodes(v *[2]*DockNode) {
	vArg := make([]*C.ImGuiDockNode, len(v))
	for i, vV := range v {
		vVArg, _ := vV.Handle()
		vArg[i] = internal.ReinterpretCast[*C.ImGuiDockNode](vVArg)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetChildNodes(selfArg, (**C.ImGuiDockNode)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = NewDockNodeFromC(vV)
	}
}

// ImGuiDockNode_GetChildNodes returns value of ImGuiDockNode.ChildNodes[2]
//
// [Split node only] Child nodes (left/right or top/bottom). Consider switching to an array.
func (self *DockNode) ChildNodes() [2]*DockNode {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [2]*DockNode {
		result := [2]*DockNode{}
		resultMirr := C.wrap_ImGuiDockNode_GetChildNodes(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		for i := range result {
			result[i] = NewDockNodeFromC(C.cimgui_ImGuiDockNodePtr_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiDockNode_SetTabBar sets value of ImGuiDockNode.TabBar
func (self DockNode) SetTabBar(v *TabBar) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetTabBar(selfArg, internal.ReinterpretCast[*C.ImGuiTabBar](vArg))
}

// ImGuiDockNode_GetTabBar returns value of ImGuiDockNode.TabBar
func (self *DockNode) TabBar() *TabBar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewTabBarFromC(C.wrap_ImGuiDockNode_GetTabBar(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetPos sets value of ImGuiDockNode.Pos
//
// Current position
func (self DockNode) SetPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiDockNode_GetPos returns value of ImGuiDockNode.Pos
//
// Current position
func (self *DockNode) Pos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiDockNode_GetPos(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiDockNode_SetSize sets value of ImGuiDockNode.Size
//
// Current size
func (self DockNode) SetSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiDockNode_GetSize returns value of ImGuiDockNode.Size
//
// Current size
func (self *DockNode) Size() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiDockNode_GetSize(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiDockNode_SetSizeRef sets value of ImGuiDockNode.SizeRef
//
// [Split node only] Last explicitly written-to size (overridden when using a splitter affecting the node), used to calculate Size.
func (self DockNode) SetSizeRef(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSizeRef(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiDockNode_GetSizeRef returns value of ImGuiDockNode.SizeRef
//
// [Split node only] Last explicitly written-to size (overridden when using a splitter affecting the node), used to calculate Size.
func (self *DockNode) SizeRef() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiDockNode_GetSizeRef(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiDockNode_SetSplitAxis sets value of ImGuiDockNode.SplitAxis
//
// [Split node only] Split axis (X or Y)
func (self DockNode) SetSplitAxis(v Axis) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSplitAxis(selfArg, C.ImGuiAxis(v))
}

// ImGuiDockNode_GetSplitAxis returns value of ImGuiDockNode.SplitAxis
//
// [Split node only] Split axis (X or Y)
func (self *DockNode) SplitAxis() Axis {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Axis(C.wrap_ImGuiDockNode_GetSplitAxis(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetWindowClass sets value of ImGuiDockNode.WindowClass
//
// [Root node only]
func (self DockNode) SetWindowClass(v WindowClass) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWindowClass(selfArg, internal.ReinterpretCast[C.ImGuiWindowClass](vArg))
}

// ImGuiDockNode_GetWindowClass returns value of ImGuiDockNode.WindowClass
//
// [Root node only]
func (self *DockNode) WindowClass() WindowClass {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewWindowClassFromC(func() *C.ImGuiWindowClass {
		result := C.wrap_ImGuiDockNode_GetWindowClass(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return &result
	}())
}

// ImGuiDockNode_SetLastBgColor sets value of ImGuiDockNode.LastBgColor
func (self DockNode) SetLastBgColor(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastBgColor(selfArg, C.ImU32(v))
}

// ImGuiDockNode_GetLastBgColor returns value of ImGuiDockNode.LastBgColor
func (self *DockNode) LastBgColor() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiDockNode_GetLastBgColor(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetHostWindow sets value of ImGuiDockNode.HostWindow
func (self DockNode) SetHostWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHostWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiDockNode_GetHostWindow returns value of ImGuiDockNode.HostWindow
func (self *DockNode) HostWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiDockNode_GetHostWindow(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetVisibleWindow sets value of ImGuiDockNode.VisibleWindow
//
// Generally point to window which is ID is == SelectedTabID, but when CTRL+Tabbing this can be a different window.
func (self DockNode) SetVisibleWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetVisibleWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiDockNode_GetVisibleWindow returns value of ImGuiDockNode.VisibleWindow
//
// Generally point to window which is ID is == SelectedTabID, but when CTRL+Tabbing this can be a different window.
func (self *DockNode) VisibleWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiDockNode_GetVisibleWindow(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetCentralNode sets value of ImGuiDockNode.CentralNode
//
// [Root node only] Pointer to central node.
func (self DockNode) SetCentralNode(v *DockNode) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetCentralNode(selfArg, internal.ReinterpretCast[*C.ImGuiDockNode](vArg))
}

// ImGuiDockNode_GetCentralNode returns value of ImGuiDockNode.CentralNode
//
// [Root node only] Pointer to central node.
func (self *DockNode) CentralNode() *DockNode {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDockNodeFromC(C.wrap_ImGuiDockNode_GetCentralNode(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetOnlyNodeWithWindows sets value of ImGuiDockNode.OnlyNodeWithWindows
//
// [Root node only] Set when there is a single visible node within the hierarchy.
func (self DockNode) SetOnlyNodeWithWindows(v *DockNode) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetOnlyNodeWithWindows(selfArg, internal.ReinterpretCast[*C.ImGuiDockNode](vArg))
}

// ImGuiDockNode_GetOnlyNodeWithWindows returns value of ImGuiDockNode.OnlyNodeWithWindows
//
// [Root node only] Set when there is a single visible node within the hierarchy.
func (self *DockNode) OnlyNodeWithWindows() *DockNode {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDockNodeFromC(C.wrap_ImGuiDockNode_GetOnlyNodeWithWindows(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetCountNodeWithWindows sets value of ImGuiDockNode.CountNodeWithWindows
//
// [Root node only]
func (self DockNode) SetCountNodeWithWindows(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetCountNodeWithWindows(selfArg, C.int(v))
}

// ImGuiDockNode_GetCountNodeWithWindows returns value of ImGuiDockNode.CountNodeWithWindows
//
// [Root node only]
func (self *DockNode) CountNodeWithWindows() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetCountNodeWithWindows(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetLastFrameAlive sets value of ImGuiDockNode.LastFrameAlive
//
// Last frame number the node was updated or kept alive explicitly with DockSpace() + ImGuiDockNodeFlags_KeepAliveOnly
func (self DockNode) SetLastFrameAlive(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFrameAlive(selfArg, C.int(v))
}

// ImGuiDockNode_GetLastFrameAlive returns value of ImGuiDockNode.LastFrameAlive
//
// Last frame number the node was updated or kept alive explicitly with DockSpace() + ImGuiDockNodeFlags_KeepAliveOnly
func (self *DockNode) LastFrameAlive() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetLastFrameAlive(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetLastFrameActive sets value of ImGuiDockNode.LastFrameActive
//
// Last frame number the node was updated.
func (self DockNode) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFrameActive(selfArg, C.int(v))
}

// ImGuiDockNode_GetLastFrameActive returns value of ImGuiDockNode.LastFrameActive
//
// Last frame number the node was updated.
func (self *DockNode) LastFrameActive() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetLastFrameActive(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetLastFrameFocused sets value of ImGuiDockNode.LastFrameFocused
//
// Last frame number the node was focused.
func (self DockNode) SetLastFrameFocused(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFrameFocused(selfArg, C.int(v))
}

// ImGuiDockNode_GetLastFrameFocused returns value of ImGuiDockNode.LastFrameFocused
//
// Last frame number the node was focused.
func (self *DockNode) LastFrameFocused() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiDockNode_GetLastFrameFocused(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetLastFocusedNodeId sets value of ImGuiDockNode.LastFocusedNodeId
//
// [Root node only] Which of our child docking node (any ancestor in the hierarchy) was last focused.
func (self DockNode) SetLastFocusedNodeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetLastFocusedNodeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiDockNode_GetLastFocusedNodeId returns value of ImGuiDockNode.LastFocusedNodeId
//
// [Root node only] Which of our child docking node (any ancestor in the hierarchy) was last focused.
func (self *DockNode) LastFocusedNodeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiDockNode_GetLastFocusedNodeId(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return &result
	}())
}

// ImGuiDockNode_SetSelectedTabId sets value of ImGuiDockNode.SelectedTabId
//
// [Leaf node only] Which of our tab/window is selected.
func (self DockNode) SetSelectedTabId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetSelectedTabId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiDockNode_GetSelectedTabId returns value of ImGuiDockNode.SelectedTabId
//
// [Leaf node only] Which of our tab/window is selected.
func (self *DockNode) SelectedTabId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiDockNode_GetSelectedTabId(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return &result
	}())
}

// ImGuiDockNode_SetWantCloseTabId sets value of ImGuiDockNode.WantCloseTabId
//
// [Leaf node only] Set when closing a specific tab/window.
func (self DockNode) SetWantCloseTabId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantCloseTabId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiDockNode_GetWantCloseTabId returns value of ImGuiDockNode.WantCloseTabId
//
// [Leaf node only] Set when closing a specific tab/window.
func (self *DockNode) WantCloseTabId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiDockNode_GetWantCloseTabId(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return &result
	}())
}

// ImGuiDockNode_SetRefViewportId sets value of ImGuiDockNode.RefViewportId
//
// Reference viewport ID from visible window when HostWindow == NULL.
func (self DockNode) SetRefViewportId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetRefViewportId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiDockNode_GetRefViewportId returns value of ImGuiDockNode.RefViewportId
//
// Reference viewport ID from visible window when HostWindow == NULL.
func (self *DockNode) RefViewportId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiDockNode_GetRefViewportId(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg))
		return &result
	}())
}

// ImGuiDockNode_SetAuthorityForPos sets value of ImGuiDockNode.AuthorityForPos
func (self DockNode) SetAuthorityForPos(v DataAuthority) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetAuthorityForPos(selfArg, C.ImGuiDataAuthority(v))
}

// ImGuiDockNode_GetAuthorityForPos returns value of ImGuiDockNode.AuthorityForPos
func (self *DockNode) AuthorityForPos() DataAuthority {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DataAuthority(C.wrap_ImGuiDockNode_GetAuthorityForPos(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetAuthorityForSize sets value of ImGuiDockNode.AuthorityForSize
func (self DockNode) SetAuthorityForSize(v DataAuthority) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetAuthorityForSize(selfArg, C.ImGuiDataAuthority(v))
}

// ImGuiDockNode_GetAuthorityForSize returns value of ImGuiDockNode.AuthorityForSize
func (self *DockNode) AuthorityForSize() DataAuthority {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DataAuthority(C.wrap_ImGuiDockNode_GetAuthorityForSize(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetAuthorityForViewport sets value of ImGuiDockNode.AuthorityForViewport
func (self DockNode) SetAuthorityForViewport(v DataAuthority) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetAuthorityForViewport(selfArg, C.ImGuiDataAuthority(v))
}

// ImGuiDockNode_GetAuthorityForViewport returns value of ImGuiDockNode.AuthorityForViewport
func (self *DockNode) AuthorityForViewport() DataAuthority {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DataAuthority(C.wrap_ImGuiDockNode_GetAuthorityForViewport(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)))
}

// ImGuiDockNode_SetIsVisible sets value of ImGuiDockNode.IsVisible
//
// Set to false when the node is hidden (usually disabled as it has no active window)
func (self DockNode) SetIsVisible(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetIsVisible(selfArg, C.bool(v))
}

// ImGuiDockNode_GetIsVisible returns value of ImGuiDockNode.IsVisible
//
// Set to false when the node is hidden (usually disabled as it has no active window)
func (self *DockNode) IsVisible() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetIsVisible(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetIsFocused sets value of ImGuiDockNode.IsFocused
func (self DockNode) SetIsFocused(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetIsFocused(selfArg, C.bool(v))
}

// ImGuiDockNode_GetIsFocused returns value of ImGuiDockNode.IsFocused
func (self *DockNode) IsFocused() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetIsFocused(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetIsBgDrawnThisFrame sets value of ImGuiDockNode.IsBgDrawnThisFrame
func (self DockNode) SetIsBgDrawnThisFrame(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetIsBgDrawnThisFrame(selfArg, C.bool(v))
}

// ImGuiDockNode_GetIsBgDrawnThisFrame returns value of ImGuiDockNode.IsBgDrawnThisFrame
func (self *DockNode) IsBgDrawnThisFrame() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetIsBgDrawnThisFrame(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetHasCloseButton sets value of ImGuiDockNode.HasCloseButton
//
// Provide space for a close button (if any of the docked window has one). Note that button may be hidden on window without one.
func (self DockNode) SetHasCloseButton(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHasCloseButton(selfArg, C.bool(v))
}

// ImGuiDockNode_GetHasCloseButton returns value of ImGuiDockNode.HasCloseButton
//
// Provide space for a close button (if any of the docked window has one). Note that button may be hidden on window without one.
func (self *DockNode) HasCloseButton() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetHasCloseButton(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetHasWindowMenuButton sets value of ImGuiDockNode.HasWindowMenuButton
func (self DockNode) SetHasWindowMenuButton(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHasWindowMenuButton(selfArg, C.bool(v))
}

// ImGuiDockNode_GetHasWindowMenuButton returns value of ImGuiDockNode.HasWindowMenuButton
func (self *DockNode) HasWindowMenuButton() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetHasWindowMenuButton(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetHasCentralNodeChild sets value of ImGuiDockNode.HasCentralNodeChild
func (self DockNode) SetHasCentralNodeChild(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetHasCentralNodeChild(selfArg, C.bool(v))
}

// ImGuiDockNode_GetHasCentralNodeChild returns value of ImGuiDockNode.HasCentralNodeChild
func (self *DockNode) HasCentralNodeChild() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetHasCentralNodeChild(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetWantCloseAll sets value of ImGuiDockNode.WantCloseAll
//
// Set when closing all tabs at once.
func (self DockNode) SetWantCloseAll(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantCloseAll(selfArg, C.bool(v))
}

// ImGuiDockNode_GetWantCloseAll returns value of ImGuiDockNode.WantCloseAll
//
// Set when closing all tabs at once.
func (self *DockNode) WantCloseAll() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantCloseAll(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetWantLockSizeOnce sets value of ImGuiDockNode.WantLockSizeOnce
func (self DockNode) SetWantLockSizeOnce(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantLockSizeOnce(selfArg, C.bool(v))
}

// ImGuiDockNode_GetWantLockSizeOnce returns value of ImGuiDockNode.WantLockSizeOnce
func (self *DockNode) WantLockSizeOnce() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantLockSizeOnce(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetWantMouseMove sets value of ImGuiDockNode.WantMouseMove
//
// After a node extraction we need to transition toward moving the newly created host window
func (self DockNode) SetWantMouseMove(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantMouseMove(selfArg, C.bool(v))
}

// ImGuiDockNode_GetWantMouseMove returns value of ImGuiDockNode.WantMouseMove
//
// After a node extraction we need to transition toward moving the newly created host window
func (self *DockNode) WantMouseMove() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantMouseMove(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetWantHiddenTabBarUpdate sets value of ImGuiDockNode.WantHiddenTabBarUpdate
func (self DockNode) SetWantHiddenTabBarUpdate(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantHiddenTabBarUpdate(selfArg, C.bool(v))
}

// ImGuiDockNode_GetWantHiddenTabBarUpdate returns value of ImGuiDockNode.WantHiddenTabBarUpdate
func (self *DockNode) WantHiddenTabBarUpdate() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantHiddenTabBarUpdate(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiDockNode_SetWantHiddenTabBarToggle sets value of ImGuiDockNode.WantHiddenTabBarToggle
func (self DockNode) SetWantHiddenTabBarToggle(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiDockNode_SetWantHiddenTabBarToggle(selfArg, C.bool(v))
}

// ImGuiDockNode_GetWantHiddenTabBarToggle returns value of ImGuiDockNode.WantHiddenTabBarToggle
func (self *DockNode) WantHiddenTabBarToggle() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiDockNode_GetWantHiddenTabBarToggle(internal.ReinterpretCast[*C.ImGuiDockNode](selfArg)) == C.bool(true)
}

// ImGuiErrorRecoveryState_SetSizeOfWindowStack sets value of ImGuiErrorRecoveryState.SizeOfWindowStack
func (self ErrorRecoveryState) SetSizeOfWindowStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfWindowStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfWindowStack returns value of ImGuiErrorRecoveryState.SizeOfWindowStack
func (self *ErrorRecoveryState) SizeOfWindowStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfWindowStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfIDStack sets value of ImGuiErrorRecoveryState.SizeOfIDStack
func (self ErrorRecoveryState) SetSizeOfIDStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfIDStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfIDStack returns value of ImGuiErrorRecoveryState.SizeOfIDStack
func (self *ErrorRecoveryState) SizeOfIDStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfIDStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfTreeStack sets value of ImGuiErrorRecoveryState.SizeOfTreeStack
func (self ErrorRecoveryState) SetSizeOfTreeStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfTreeStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfTreeStack returns value of ImGuiErrorRecoveryState.SizeOfTreeStack
func (self *ErrorRecoveryState) SizeOfTreeStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfTreeStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfColorStack sets value of ImGuiErrorRecoveryState.SizeOfColorStack
func (self ErrorRecoveryState) SetSizeOfColorStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfColorStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfColorStack returns value of ImGuiErrorRecoveryState.SizeOfColorStack
func (self *ErrorRecoveryState) SizeOfColorStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfColorStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfStyleVarStack sets value of ImGuiErrorRecoveryState.SizeOfStyleVarStack
func (self ErrorRecoveryState) SetSizeOfStyleVarStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfStyleVarStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfStyleVarStack returns value of ImGuiErrorRecoveryState.SizeOfStyleVarStack
func (self *ErrorRecoveryState) SizeOfStyleVarStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfStyleVarStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfFontStack sets value of ImGuiErrorRecoveryState.SizeOfFontStack
func (self ErrorRecoveryState) SetSizeOfFontStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfFontStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfFontStack returns value of ImGuiErrorRecoveryState.SizeOfFontStack
func (self *ErrorRecoveryState) SizeOfFontStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfFontStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfFocusScopeStack sets value of ImGuiErrorRecoveryState.SizeOfFocusScopeStack
func (self ErrorRecoveryState) SetSizeOfFocusScopeStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfFocusScopeStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfFocusScopeStack returns value of ImGuiErrorRecoveryState.SizeOfFocusScopeStack
func (self *ErrorRecoveryState) SizeOfFocusScopeStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfFocusScopeStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfGroupStack sets value of ImGuiErrorRecoveryState.SizeOfGroupStack
func (self ErrorRecoveryState) SetSizeOfGroupStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfGroupStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfGroupStack returns value of ImGuiErrorRecoveryState.SizeOfGroupStack
func (self *ErrorRecoveryState) SizeOfGroupStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfGroupStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfItemFlagsStack sets value of ImGuiErrorRecoveryState.SizeOfItemFlagsStack
func (self ErrorRecoveryState) SetSizeOfItemFlagsStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfItemFlagsStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfItemFlagsStack returns value of ImGuiErrorRecoveryState.SizeOfItemFlagsStack
func (self *ErrorRecoveryState) SizeOfItemFlagsStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfItemFlagsStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfBeginPopupStack sets value of ImGuiErrorRecoveryState.SizeOfBeginPopupStack
func (self ErrorRecoveryState) SetSizeOfBeginPopupStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfBeginPopupStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfBeginPopupStack returns value of ImGuiErrorRecoveryState.SizeOfBeginPopupStack
func (self *ErrorRecoveryState) SizeOfBeginPopupStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfBeginPopupStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiErrorRecoveryState_SetSizeOfDisabledStack sets value of ImGuiErrorRecoveryState.SizeOfDisabledStack
func (self ErrorRecoveryState) SetSizeOfDisabledStack(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiErrorRecoveryState_SetSizeOfDisabledStack(selfArg, C.short(v))
}

// ImGuiErrorRecoveryState_GetSizeOfDisabledStack returns value of ImGuiErrorRecoveryState.SizeOfDisabledStack
func (self *ErrorRecoveryState) SizeOfDisabledStack() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiErrorRecoveryState_GetSizeOfDisabledStack(internal.ReinterpretCast[*C.ImGuiErrorRecoveryState](selfArg)))
}

// ImGuiFocusScopeData_SetID sets value of ImGuiFocusScopeData.ID
func (self FocusScopeData) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiFocusScopeData_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiFocusScopeData_GetID returns value of ImGuiFocusScopeData.ID
func (self *FocusScopeData) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiFocusScopeData_GetID(internal.ReinterpretCast[*C.ImGuiFocusScopeData](selfArg))
		return &result
	}())
}

// ImGuiFocusScopeData_SetWindowID sets value of ImGuiFocusScopeData.WindowID
func (self FocusScopeData) SetWindowID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiFocusScopeData_SetWindowID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiFocusScopeData_GetWindowID returns value of ImGuiFocusScopeData.WindowID
func (self *FocusScopeData) WindowID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiFocusScopeData_GetWindowID(internal.ReinterpretCast[*C.ImGuiFocusScopeData](selfArg))
		return &result
	}())
}

// ImGuiGroupData_SetWindowID sets value of ImGuiGroupData.WindowID
func (self GroupData) SetWindowID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetWindowID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiGroupData_GetWindowID returns value of ImGuiGroupData.WindowID
func (self *GroupData) WindowID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiGroupData_GetWindowID(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return &result
	}())
}

// ImGuiGroupData_SetBackupCursorPos sets value of ImGuiGroupData.BackupCursorPos
func (self GroupData) SetBackupCursorPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCursorPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiGroupData_GetBackupCursorPos returns value of ImGuiGroupData.BackupCursorPos
func (self *GroupData) BackupCursorPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiGroupData_GetBackupCursorPos(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiGroupData_SetBackupCursorMaxPos sets value of ImGuiGroupData.BackupCursorMaxPos
func (self GroupData) SetBackupCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCursorMaxPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiGroupData_GetBackupCursorMaxPos returns value of ImGuiGroupData.BackupCursorMaxPos
func (self *GroupData) BackupCursorMaxPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiGroupData_GetBackupCursorMaxPos(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiGroupData_SetBackupCursorPosPrevLine sets value of ImGuiGroupData.BackupCursorPosPrevLine
func (self GroupData) SetBackupCursorPosPrevLine(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCursorPosPrevLine(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiGroupData_GetBackupCursorPosPrevLine returns value of ImGuiGroupData.BackupCursorPosPrevLine
func (self *GroupData) BackupCursorPosPrevLine() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiGroupData_GetBackupCursorPosPrevLine(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiGroupData_SetBackupIndent sets value of ImGuiGroupData.BackupIndent
func (self GroupData) SetBackupIndent(v Vec1) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupIndent(selfArg, internal.ReinterpretCast[C.ImVec1](vArg))
}

// ImGuiGroupData_GetBackupIndent returns value of ImGuiGroupData.BackupIndent
func (self *GroupData) BackupIndent() Vec1 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewVec1FromC(func() *C.ImVec1 {
		result := C.wrap_ImGuiGroupData_GetBackupIndent(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return &result
	}())
}

// ImGuiGroupData_SetBackupGroupOffset sets value of ImGuiGroupData.BackupGroupOffset
func (self GroupData) SetBackupGroupOffset(v Vec1) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupGroupOffset(selfArg, internal.ReinterpretCast[C.ImVec1](vArg))
}

// ImGuiGroupData_GetBackupGroupOffset returns value of ImGuiGroupData.BackupGroupOffset
func (self *GroupData) BackupGroupOffset() Vec1 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewVec1FromC(func() *C.ImVec1 {
		result := C.wrap_ImGuiGroupData_GetBackupGroupOffset(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return &result
	}())
}

// ImGuiGroupData_SetBackupCurrLineSize sets value of ImGuiGroupData.BackupCurrLineSize
func (self GroupData) SetBackupCurrLineSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCurrLineSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiGroupData_GetBackupCurrLineSize returns value of ImGuiGroupData.BackupCurrLineSize
func (self *GroupData) BackupCurrLineSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiGroupData_GetBackupCurrLineSize(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiGroupData_SetBackupCurrLineTextBaseOffset sets value of ImGuiGroupData.BackupCurrLineTextBaseOffset
func (self GroupData) SetBackupCurrLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupCurrLineTextBaseOffset(selfArg, C.float(v))
}

// ImGuiGroupData_GetBackupCurrLineTextBaseOffset returns value of ImGuiGroupData.BackupCurrLineTextBaseOffset
func (self *GroupData) BackupCurrLineTextBaseOffset() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiGroupData_GetBackupCurrLineTextBaseOffset(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg)))
}

// ImGuiGroupData_SetBackupActiveIdIsAlive sets value of ImGuiGroupData.BackupActiveIdIsAlive
func (self GroupData) SetBackupActiveIdIsAlive(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupActiveIdIsAlive(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiGroupData_GetBackupActiveIdIsAlive returns value of ImGuiGroupData.BackupActiveIdIsAlive
func (self *GroupData) BackupActiveIdIsAlive() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiGroupData_GetBackupActiveIdIsAlive(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg))
		return &result
	}())
}

// ImGuiGroupData_SetBackupActiveIdPreviousFrameIsAlive sets value of ImGuiGroupData.BackupActiveIdPreviousFrameIsAlive
func (self GroupData) SetBackupActiveIdPreviousFrameIsAlive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupActiveIdPreviousFrameIsAlive(selfArg, C.bool(v))
}

// ImGuiGroupData_GetBackupActiveIdPreviousFrameIsAlive returns value of ImGuiGroupData.BackupActiveIdPreviousFrameIsAlive
func (self *GroupData) BackupActiveIdPreviousFrameIsAlive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiGroupData_GetBackupActiveIdPreviousFrameIsAlive(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg)) == C.bool(true)
}

// ImGuiGroupData_SetBackupHoveredIdIsAlive sets value of ImGuiGroupData.BackupHoveredIdIsAlive
func (self GroupData) SetBackupHoveredIdIsAlive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupHoveredIdIsAlive(selfArg, C.bool(v))
}

// ImGuiGroupData_GetBackupHoveredIdIsAlive returns value of ImGuiGroupData.BackupHoveredIdIsAlive
func (self *GroupData) BackupHoveredIdIsAlive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiGroupData_GetBackupHoveredIdIsAlive(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg)) == C.bool(true)
}

// ImGuiGroupData_SetBackupIsSameLine sets value of ImGuiGroupData.BackupIsSameLine
func (self GroupData) SetBackupIsSameLine(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetBackupIsSameLine(selfArg, C.bool(v))
}

// ImGuiGroupData_GetBackupIsSameLine returns value of ImGuiGroupData.BackupIsSameLine
func (self *GroupData) BackupIsSameLine() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiGroupData_GetBackupIsSameLine(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg)) == C.bool(true)
}

// ImGuiGroupData_SetEmitItem sets value of ImGuiGroupData.EmitItem
func (self GroupData) SetEmitItem(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiGroupData_SetEmitItem(selfArg, C.bool(v))
}

// ImGuiGroupData_GetEmitItem returns value of ImGuiGroupData.EmitItem
func (self *GroupData) EmitItem() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiGroupData_GetEmitItem(internal.ReinterpretCast[*C.ImGuiGroupData](selfArg)) == C.bool(true)
}

// ImGuiIDStackTool_SetLastActiveFrame sets value of ImGuiIDStackTool.LastActiveFrame
func (self IDStackTool) SetLastActiveFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIDStackTool_SetLastActiveFrame(selfArg, C.int(v))
}

// ImGuiIDStackTool_GetLastActiveFrame returns value of ImGuiIDStackTool.LastActiveFrame
func (self *IDStackTool) LastActiveFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIDStackTool_GetLastActiveFrame(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg)))
}

// ImGuiIDStackTool_SetStackLevel sets value of ImGuiIDStackTool.StackLevel
//
// -1: query stack and resize Results, >= 0: individual stack level
func (self IDStackTool) SetStackLevel(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIDStackTool_SetStackLevel(selfArg, C.int(v))
}

// ImGuiIDStackTool_GetStackLevel returns value of ImGuiIDStackTool.StackLevel
//
// -1: query stack and resize Results, >= 0: individual stack level
func (self *IDStackTool) StackLevel() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIDStackTool_GetStackLevel(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg)))
}

// ImGuiIDStackTool_SetQueryId sets value of ImGuiIDStackTool.QueryId
//
// ID to query details for
func (self IDStackTool) SetQueryId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIDStackTool_SetQueryId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiIDStackTool_GetQueryId returns value of ImGuiIDStackTool.QueryId
//
// ID to query details for
func (self *IDStackTool) QueryId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiIDStackTool_GetQueryId(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg))
		return &result
	}())
}

// ImGuiIDStackTool_SetResults sets value of ImGuiIDStackTool.Results
func (self IDStackTool) SetResults(v vectors.Vector[StackLevelInfo]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiStackLevelInfo)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiStackLevelInfo](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIDStackTool_SetResults(selfArg, *vVecArg)
}

// ImGuiIDStackTool_GetResults returns value of ImGuiIDStackTool.Results
func (self *IDStackTool) Results() vectors.Vector[StackLevelInfo] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiIDStackTool_GetResults(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg)).Size, C.wrap_ImGuiIDStackTool_GetResults(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg)).Capacity, NewStackLevelInfoFromC(C.wrap_ImGuiIDStackTool_GetResults(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg)).Data))
}

// ImGuiIDStackTool_SetCopyToClipboardOnCtrlC sets value of ImGuiIDStackTool.CopyToClipboardOnCtrlC
func (self IDStackTool) SetCopyToClipboardOnCtrlC(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIDStackTool_SetCopyToClipboardOnCtrlC(selfArg, C.bool(v))
}

// ImGuiIDStackTool_GetCopyToClipboardOnCtrlC returns value of ImGuiIDStackTool.CopyToClipboardOnCtrlC
func (self *IDStackTool) CopyToClipboardOnCtrlC() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIDStackTool_GetCopyToClipboardOnCtrlC(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg)) == C.bool(true)
}

// ImGuiIDStackTool_SetCopyToClipboardLastTime sets value of ImGuiIDStackTool.CopyToClipboardLastTime
func (self IDStackTool) SetCopyToClipboardLastTime(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIDStackTool_SetCopyToClipboardLastTime(selfArg, C.float(v))
}

// ImGuiIDStackTool_GetCopyToClipboardLastTime returns value of ImGuiIDStackTool.CopyToClipboardLastTime
func (self *IDStackTool) CopyToClipboardLastTime() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIDStackTool_GetCopyToClipboardLastTime(internal.ReinterpretCast[*C.ImGuiIDStackTool](selfArg)))
}

// ImGuiIO_SetConfigFlags sets value of ImGuiIO.ConfigFlags
//
// = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.
func (self IO) SetConfigFlags(v ConfigFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigFlags(selfArg, C.ImGuiConfigFlags(v))
}

// ImGuiIO_GetConfigFlags returns value of ImGuiIO.ConfigFlags
//
// = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.
func (self *IO) ConfigFlags() ConfigFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ConfigFlags(C.wrap_ImGuiIO_GetConfigFlags(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetBackendFlags sets value of ImGuiIO.BackendFlags
//
// = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
func (self IO) SetBackendFlags(v BackendFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendFlags(selfArg, C.ImGuiBackendFlags(v))
}

// ImGuiIO_GetBackendFlags returns value of ImGuiIO.BackendFlags
//
// = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
func (self *IO) BackendFlags() BackendFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return BackendFlags(C.wrap_ImGuiIO_GetBackendFlags(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetDisplaySize sets value of ImGuiIO.DisplaySize
//
// <unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.
func (self IO) SetDisplaySize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetDisplaySize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiIO_GetDisplaySize returns value of ImGuiIO.DisplaySize
//
// <unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.
func (self *IO) DisplaySize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiIO_GetDisplaySize(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiIO_SetDeltaTime sets value of ImGuiIO.DeltaTime
//
// = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.
func (self IO) SetDeltaTime(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetDeltaTime(selfArg, C.float(v))
}

// ImGuiIO_GetDeltaTime returns value of ImGuiIO.DeltaTime
//
// = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.
func (self *IO) DeltaTime() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetDeltaTime(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetIniSavingRate sets value of ImGuiIO.IniSavingRate
//
// = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
func (self IO) SetIniSavingRate(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetIniSavingRate(selfArg, C.float(v))
}

// ImGuiIO_GetIniSavingRate returns value of ImGuiIO.IniSavingRate
//
// = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
func (self *IO) IniSavingRate() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetIniSavingRate(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetIniFilename sets value of ImGuiIO.IniFilename
//
// = "imgui.ini"    // Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.
func (self IO) SetIniFilename(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetIniFilename(selfArg, vArg)
}

// ImGuiIO_GetIniFilename returns value of ImGuiIO.IniFilename
//
// = "imgui.ini"    // Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.
func (self *IO) IniFilename() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiIO_GetIniFilename(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiIO_SetLogFilename sets value of ImGuiIO.LogFilename
//
// = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
func (self IO) SetLogFilename(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetLogFilename(selfArg, vArg)
}

// ImGuiIO_GetLogFilename returns value of ImGuiIO.LogFilename
//
// = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
func (self *IO) LogFilename() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiIO_GetLogFilename(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiIO_SetUserData sets value of ImGuiIO.UserData
//
// = NULL           // Store your own data.
func (self IO) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetUserData(selfArg, C.uintptr_t(v))
}

// ImGuiIO_GetUserData returns value of ImGuiIO.UserData
//
// = NULL           // Store your own data.
func (self *IO) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiIO_GetUserData(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetFonts sets value of ImGuiIO.Fonts
//
//	// Font system
//
// <auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
func (self IO) SetFonts(v *FontAtlas) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFonts(selfArg, internal.ReinterpretCast[*C.ImFontAtlas](vArg))
}

// ImGuiIO_GetFonts returns value of ImGuiIO.Fonts
//
//	// Font system
//
// <auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
func (self *IO) Fonts() *FontAtlas {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontAtlasFromC(C.wrap_ImGuiIO_GetFonts(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetFontGlobalScale sets value of ImGuiIO.FontGlobalScale
//
// = 1.0f           // Global scale all fonts
func (self IO) SetFontGlobalScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFontGlobalScale(selfArg, C.float(v))
}

// ImGuiIO_GetFontGlobalScale returns value of ImGuiIO.FontGlobalScale
//
// = 1.0f           // Global scale all fonts
func (self *IO) FontGlobalScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetFontGlobalScale(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetFontAllowUserScaling sets value of ImGuiIO.FontAllowUserScaling
//
// = false          // Allow user scaling text of individual window with CTRL+Wheel.
func (self IO) SetFontAllowUserScaling(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFontAllowUserScaling(selfArg, C.bool(v))
}

// ImGuiIO_GetFontAllowUserScaling returns value of ImGuiIO.FontAllowUserScaling
//
// = false          // Allow user scaling text of individual window with CTRL+Wheel.
func (self *IO) FontAllowUserScaling() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetFontAllowUserScaling(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetFontDefault sets value of ImGuiIO.FontDefault
//
// = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
func (self IO) SetFontDefault(v *Font) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFontDefault(selfArg, internal.ReinterpretCast[*C.ImFont](vArg))
}

// ImGuiIO_GetFontDefault returns value of ImGuiIO.FontDefault
//
// = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
func (self *IO) FontDefault() *Font {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewFontFromC(C.wrap_ImGuiIO_GetFontDefault(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetDisplayFramebufferScale sets value of ImGuiIO.DisplayFramebufferScale
//
// = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.
func (self IO) SetDisplayFramebufferScale(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetDisplayFramebufferScale(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiIO_GetDisplayFramebufferScale returns value of ImGuiIO.DisplayFramebufferScale
//
// = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.
func (self *IO) DisplayFramebufferScale() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiIO_GetDisplayFramebufferScale(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiIO_SetConfigNavSwapGamepadButtons sets value of ImGuiIO.ConfigNavSwapGamepadButtons
//
//	// Keyboard/Gamepad Navigation options
//
// = false          // Swap Activate<>Cancel (A<>B) buttons, matching typical "Nintendo/Japanese style" gamepad layout.
func (self IO) SetConfigNavSwapGamepadButtons(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigNavSwapGamepadButtons(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigNavSwapGamepadButtons returns value of ImGuiIO.ConfigNavSwapGamepadButtons
//
//	// Keyboard/Gamepad Navigation options
//
// = false          // Swap Activate<>Cancel (A<>B) buttons, matching typical "Nintendo/Japanese style" gamepad layout.
func (self *IO) ConfigNavSwapGamepadButtons() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigNavSwapGamepadButtons(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigNavMoveSetMousePos sets value of ImGuiIO.ConfigNavMoveSetMousePos
//
// = false          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=true.
func (self IO) SetConfigNavMoveSetMousePos(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigNavMoveSetMousePos(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigNavMoveSetMousePos returns value of ImGuiIO.ConfigNavMoveSetMousePos
//
// = false          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=true.
func (self *IO) ConfigNavMoveSetMousePos() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigNavMoveSetMousePos(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigNavCaptureKeyboard sets value of ImGuiIO.ConfigNavCaptureKeyboard
//
// = true           // Sets io.WantCaptureKeyboard when io.NavActive is set.
func (self IO) SetConfigNavCaptureKeyboard(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigNavCaptureKeyboard(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigNavCaptureKeyboard returns value of ImGuiIO.ConfigNavCaptureKeyboard
//
// = true           // Sets io.WantCaptureKeyboard when io.NavActive is set.
func (self *IO) ConfigNavCaptureKeyboard() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigNavCaptureKeyboard(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigNavEscapeClearFocusItem sets value of ImGuiIO.ConfigNavEscapeClearFocusItem
//
// = true           // Pressing Escape can clear focused item + navigation id/highlight. Set to false if you want to always keep highlight on.
func (self IO) SetConfigNavEscapeClearFocusItem(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigNavEscapeClearFocusItem(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigNavEscapeClearFocusItem returns value of ImGuiIO.ConfigNavEscapeClearFocusItem
//
// = true           // Pressing Escape can clear focused item + navigation id/highlight. Set to false if you want to always keep highlight on.
func (self *IO) ConfigNavEscapeClearFocusItem() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigNavEscapeClearFocusItem(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigNavEscapeClearFocusWindow sets value of ImGuiIO.ConfigNavEscapeClearFocusWindow
//
// = false          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).
func (self IO) SetConfigNavEscapeClearFocusWindow(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigNavEscapeClearFocusWindow(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigNavEscapeClearFocusWindow returns value of ImGuiIO.ConfigNavEscapeClearFocusWindow
//
// = false          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).
func (self *IO) ConfigNavEscapeClearFocusWindow() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigNavEscapeClearFocusWindow(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigNavCursorVisibleAuto sets value of ImGuiIO.ConfigNavCursorVisibleAuto
//
// = true           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.
func (self IO) SetConfigNavCursorVisibleAuto(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigNavCursorVisibleAuto(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigNavCursorVisibleAuto returns value of ImGuiIO.ConfigNavCursorVisibleAuto
//
// = true           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.
func (self *IO) ConfigNavCursorVisibleAuto() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigNavCursorVisibleAuto(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigNavCursorVisibleAlways sets value of ImGuiIO.ConfigNavCursorVisibleAlways
//
// = false          // Navigation cursor is always visible.
func (self IO) SetConfigNavCursorVisibleAlways(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigNavCursorVisibleAlways(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigNavCursorVisibleAlways returns value of ImGuiIO.ConfigNavCursorVisibleAlways
//
// = false          // Navigation cursor is always visible.
func (self *IO) ConfigNavCursorVisibleAlways() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigNavCursorVisibleAlways(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDockingNoSplit sets value of ImGuiIO.ConfigDockingNoSplit
//
//	// Docking options (when ImGuiConfigFlags_DockingEnable is set)
//
// = false          // Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.
func (self IO) SetConfigDockingNoSplit(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingNoSplit(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDockingNoSplit returns value of ImGuiIO.ConfigDockingNoSplit
//
//	// Docking options (when ImGuiConfigFlags_DockingEnable is set)
//
// = false          // Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.
func (self *IO) ConfigDockingNoSplit() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingNoSplit(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDockingWithShift sets value of ImGuiIO.ConfigDockingWithShift
//
// = false          // Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)
func (self IO) SetConfigDockingWithShift(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingWithShift(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDockingWithShift returns value of ImGuiIO.ConfigDockingWithShift
//
// = false          // Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)
func (self *IO) ConfigDockingWithShift() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingWithShift(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDockingAlwaysTabBar sets value of ImGuiIO.ConfigDockingAlwaysTabBar
//
// = false          // [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.
func (self IO) SetConfigDockingAlwaysTabBar(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingAlwaysTabBar(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDockingAlwaysTabBar returns value of ImGuiIO.ConfigDockingAlwaysTabBar
//
// = false          // [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.
func (self *IO) ConfigDockingAlwaysTabBar() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingAlwaysTabBar(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDockingTransparentPayload sets value of ImGuiIO.ConfigDockingTransparentPayload
//
// = false          // [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.
func (self IO) SetConfigDockingTransparentPayload(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDockingTransparentPayload(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDockingTransparentPayload returns value of ImGuiIO.ConfigDockingTransparentPayload
//
// = false          // [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.
func (self *IO) ConfigDockingTransparentPayload() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDockingTransparentPayload(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigViewportsNoAutoMerge sets value of ImGuiIO.ConfigViewportsNoAutoMerge
//
//	// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
//
// = false;         // Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.
func (self IO) SetConfigViewportsNoAutoMerge(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoAutoMerge(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigViewportsNoAutoMerge returns value of ImGuiIO.ConfigViewportsNoAutoMerge
//
//	// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
//
// = false;         // Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.
func (self *IO) ConfigViewportsNoAutoMerge() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoAutoMerge(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigViewportsNoTaskBarIcon sets value of ImGuiIO.ConfigViewportsNoTaskBarIcon
//
// = false          // Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.
func (self IO) SetConfigViewportsNoTaskBarIcon(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoTaskBarIcon(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigViewportsNoTaskBarIcon returns value of ImGuiIO.ConfigViewportsNoTaskBarIcon
//
// = false          // Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.
func (self *IO) ConfigViewportsNoTaskBarIcon() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoTaskBarIcon(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigViewportsNoDecoration sets value of ImGuiIO.ConfigViewportsNoDecoration
//
// = true           // Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).
func (self IO) SetConfigViewportsNoDecoration(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoDecoration(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigViewportsNoDecoration returns value of ImGuiIO.ConfigViewportsNoDecoration
//
// = true           // Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).
func (self *IO) ConfigViewportsNoDecoration() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoDecoration(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigViewportsNoDefaultParent sets value of ImGuiIO.ConfigViewportsNoDefaultParent
//
// = false          // Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = <main_viewport>, expecting the platform backend to setup a parent/child relationship between the OS windows (some backend may ignore this). Set to true if you want the default to be 0, then all viewports will be top-level OS windows.
func (self IO) SetConfigViewportsNoDefaultParent(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigViewportsNoDefaultParent(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigViewportsNoDefaultParent returns value of ImGuiIO.ConfigViewportsNoDefaultParent
//
// = false          // Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = <main_viewport>, expecting the platform backend to setup a parent/child relationship between the OS windows (some backend may ignore this). Set to true if you want the default to be 0, then all viewports will be top-level OS windows.
func (self *IO) ConfigViewportsNoDefaultParent() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigViewportsNoDefaultParent(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetMouseDrawCursor sets value of ImGuiIO.MouseDrawCursor
//
//	// Miscellaneous options
//	// (you can visualize and interact with all options in 'Demo->Configuration')
//
// = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.
func (self IO) SetMouseDrawCursor(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDrawCursor(selfArg, C.bool(v))
}

// ImGuiIO_GetMouseDrawCursor returns value of ImGuiIO.MouseDrawCursor
//
//	// Miscellaneous options
//	// (you can visualize and interact with all options in 'Demo->Configuration')
//
// = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.
func (self *IO) MouseDrawCursor() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetMouseDrawCursor(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigMacOSXBehaviors sets value of ImGuiIO.ConfigMacOSXBehaviors
//
// = defined(__APPLE__) // Swap Cmd<>Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.
func (self IO) SetConfigMacOSXBehaviors(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigMacOSXBehaviors(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigMacOSXBehaviors returns value of ImGuiIO.ConfigMacOSXBehaviors
//
// = defined(__APPLE__) // Swap Cmd<>Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.
func (self *IO) ConfigMacOSXBehaviors() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigMacOSXBehaviors(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigInputTrickleEventQueue sets value of ImGuiIO.ConfigInputTrickleEventQueue
//
// = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.
func (self IO) SetConfigInputTrickleEventQueue(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigInputTrickleEventQueue(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigInputTrickleEventQueue returns value of ImGuiIO.ConfigInputTrickleEventQueue
//
// = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.
func (self *IO) ConfigInputTrickleEventQueue() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigInputTrickleEventQueue(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigInputTextCursorBlink sets value of ImGuiIO.ConfigInputTextCursorBlink
//
// = true           // Enable blinking cursor (optional as some users consider it to be distracting).
func (self IO) SetConfigInputTextCursorBlink(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigInputTextCursorBlink(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigInputTextCursorBlink returns value of ImGuiIO.ConfigInputTextCursorBlink
//
// = true           // Enable blinking cursor (optional as some users consider it to be distracting).
func (self *IO) ConfigInputTextCursorBlink() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigInputTextCursorBlink(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigInputTextEnterKeepActive sets value of ImGuiIO.ConfigInputTextEnterKeepActive
//
// = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).
func (self IO) SetConfigInputTextEnterKeepActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigInputTextEnterKeepActive(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigInputTextEnterKeepActive returns value of ImGuiIO.ConfigInputTextEnterKeepActive
//
// = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).
func (self *IO) ConfigInputTextEnterKeepActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigInputTextEnterKeepActive(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDragClickToInputText sets value of ImGuiIO.ConfigDragClickToInputText
//
// = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
func (self IO) SetConfigDragClickToInputText(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDragClickToInputText(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDragClickToInputText returns value of ImGuiIO.ConfigDragClickToInputText
//
// = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
func (self *IO) ConfigDragClickToInputText() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDragClickToInputText(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigWindowsResizeFromEdges sets value of ImGuiIO.ConfigWindowsResizeFromEdges
//
// = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
func (self IO) SetConfigWindowsResizeFromEdges(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigWindowsResizeFromEdges(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigWindowsResizeFromEdges returns value of ImGuiIO.ConfigWindowsResizeFromEdges
//
// = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
func (self *IO) ConfigWindowsResizeFromEdges() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigWindowsResizeFromEdges(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigWindowsMoveFromTitleBarOnly sets value of ImGuiIO.ConfigWindowsMoveFromTitleBarOnly
//
// = false      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.
func (self IO) SetConfigWindowsMoveFromTitleBarOnly(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigWindowsMoveFromTitleBarOnly(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigWindowsMoveFromTitleBarOnly returns value of ImGuiIO.ConfigWindowsMoveFromTitleBarOnly
//
// = false      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.
func (self *IO) ConfigWindowsMoveFromTitleBarOnly() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigWindowsMoveFromTitleBarOnly(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigScrollbarScrollByPage sets value of ImGuiIO.ConfigScrollbarScrollByPage
//
// = true           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.
func (self IO) SetConfigScrollbarScrollByPage(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigScrollbarScrollByPage(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigScrollbarScrollByPage returns value of ImGuiIO.ConfigScrollbarScrollByPage
//
// = true           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.
func (self *IO) ConfigScrollbarScrollByPage() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigScrollbarScrollByPage(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigMemoryCompactTimer sets value of ImGuiIO.ConfigMemoryCompactTimer
//
// = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
func (self IO) SetConfigMemoryCompactTimer(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigMemoryCompactTimer(selfArg, C.float(v))
}

// ImGuiIO_GetConfigMemoryCompactTimer returns value of ImGuiIO.ConfigMemoryCompactTimer
//
// = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
func (self *IO) ConfigMemoryCompactTimer() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetConfigMemoryCompactTimer(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMouseDoubleClickTime sets value of ImGuiIO.MouseDoubleClickTime
//
//	// Inputs Behaviors
//	// (other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)
//
// = 0.30f          // Time for a double-click, in seconds.
func (self IO) SetMouseDoubleClickTime(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDoubleClickTime(selfArg, C.float(v))
}

// ImGuiIO_GetMouseDoubleClickTime returns value of ImGuiIO.MouseDoubleClickTime
//
//	// Inputs Behaviors
//	// (other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)
//
// = 0.30f          // Time for a double-click, in seconds.
func (self *IO) MouseDoubleClickTime() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseDoubleClickTime(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMouseDoubleClickMaxDist sets value of ImGuiIO.MouseDoubleClickMaxDist
//
// = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
func (self IO) SetMouseDoubleClickMaxDist(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDoubleClickMaxDist(selfArg, C.float(v))
}

// ImGuiIO_GetMouseDoubleClickMaxDist returns value of ImGuiIO.MouseDoubleClickMaxDist
//
// = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
func (self *IO) MouseDoubleClickMaxDist() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseDoubleClickMaxDist(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMouseDragThreshold sets value of ImGuiIO.MouseDragThreshold
//
// = 6.0f           // Distance threshold before considering we are dragging.
func (self IO) SetMouseDragThreshold(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDragThreshold(selfArg, C.float(v))
}

// ImGuiIO_GetMouseDragThreshold returns value of ImGuiIO.MouseDragThreshold
//
// = 6.0f           // Distance threshold before considering we are dragging.
func (self *IO) MouseDragThreshold() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseDragThreshold(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetKeyRepeatDelay sets value of ImGuiIO.KeyRepeatDelay
//
// = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
func (self IO) SetKeyRepeatDelay(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyRepeatDelay(selfArg, C.float(v))
}

// ImGuiIO_GetKeyRepeatDelay returns value of ImGuiIO.KeyRepeatDelay
//
// = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
func (self *IO) KeyRepeatDelay() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetKeyRepeatDelay(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetKeyRepeatRate sets value of ImGuiIO.KeyRepeatRate
//
// = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
func (self IO) SetKeyRepeatRate(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyRepeatRate(selfArg, C.float(v))
}

// ImGuiIO_GetKeyRepeatRate returns value of ImGuiIO.KeyRepeatRate
//
// = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.
func (self *IO) KeyRepeatRate() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetKeyRepeatRate(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetConfigErrorRecovery sets value of ImGuiIO.ConfigErrorRecovery
//
//	// Options to configure Error Handling and how we handle recoverable errors [EXPERIMENTAL]
//	// - Error recovery is provided as a way to facilitate:
//	//    - Recovery after a programming error (native code or scripting language - the later tends to facilitate iterating on code while running).
//	//    - Recovery after running an exception handler or any error processing which may skip code after an error has been detected.
//	// - Error recovery is not perfect nor guaranteed! It is a feature to ease development.
//	//   You not are not supposed to rely on it in the course of a normal application run.
//	// - Functions that support error recovery are using IM_ASSERT_USER_ERROR() instead of IM_ASSERT().
//	// - By design, we do NOT allow error recovery to be 100% silent. One of the three options needs to be checked!
//	// - Always ensure that on programmers seats you have at minimum Asserts or Tooltips enabled when making direct imgui API calls!
//	//   Otherwise it would severely hinder your ability to catch and correct mistakes!
//	// Read https://github.com/ocornut/imgui/wiki/Error-Handling for details.
//	// - Programmer seats: keep asserts (default), or disable asserts and keep error tooltips (new and nice!)
//	// - Non-programmer seats: maybe disable asserts, but make sure errors are resurfaced (tooltips, visible log entries, use callback etc.)
//	// - Recovery after error/exception: record stack sizes with ErrorRecoveryStoreState(), disable assert, set log callback (to e.g. trigger high-level breakpoint), recover with ErrorRecoveryTryToRecoverState(), restore settings.
//
// = true       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.
func (self IO) SetConfigErrorRecovery(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigErrorRecovery(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigErrorRecovery returns value of ImGuiIO.ConfigErrorRecovery
//
//	// Options to configure Error Handling and how we handle recoverable errors [EXPERIMENTAL]
//	// - Error recovery is provided as a way to facilitate:
//	//    - Recovery after a programming error (native code or scripting language - the later tends to facilitate iterating on code while running).
//	//    - Recovery after running an exception handler or any error processing which may skip code after an error has been detected.
//	// - Error recovery is not perfect nor guaranteed! It is a feature to ease development.
//	//   You not are not supposed to rely on it in the course of a normal application run.
//	// - Functions that support error recovery are using IM_ASSERT_USER_ERROR() instead of IM_ASSERT().
//	// - By design, we do NOT allow error recovery to be 100% silent. One of the three options needs to be checked!
//	// - Always ensure that on programmers seats you have at minimum Asserts or Tooltips enabled when making direct imgui API calls!
//	//   Otherwise it would severely hinder your ability to catch and correct mistakes!
//	// Read https://github.com/ocornut/imgui/wiki/Error-Handling for details.
//	// - Programmer seats: keep asserts (default), or disable asserts and keep error tooltips (new and nice!)
//	// - Non-programmer seats: maybe disable asserts, but make sure errors are resurfaced (tooltips, visible log entries, use callback etc.)
//	// - Recovery after error/exception: record stack sizes with ErrorRecoveryStoreState(), disable assert, set log callback (to e.g. trigger high-level breakpoint), recover with ErrorRecoveryTryToRecoverState(), restore settings.
//
// = true       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.
func (self *IO) ConfigErrorRecovery() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigErrorRecovery(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigErrorRecoveryEnableAssert sets value of ImGuiIO.ConfigErrorRecoveryEnableAssert
//
// = true       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()
func (self IO) SetConfigErrorRecoveryEnableAssert(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigErrorRecoveryEnableAssert(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigErrorRecoveryEnableAssert returns value of ImGuiIO.ConfigErrorRecoveryEnableAssert
//
// = true       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()
func (self *IO) ConfigErrorRecoveryEnableAssert() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigErrorRecoveryEnableAssert(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigErrorRecoveryEnableDebugLog sets value of ImGuiIO.ConfigErrorRecoveryEnableDebugLog
//
// = true       // Enable debug log output on recoverable errors.
func (self IO) SetConfigErrorRecoveryEnableDebugLog(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigErrorRecoveryEnableDebugLog(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigErrorRecoveryEnableDebugLog returns value of ImGuiIO.ConfigErrorRecoveryEnableDebugLog
//
// = true       // Enable debug log output on recoverable errors.
func (self *IO) ConfigErrorRecoveryEnableDebugLog() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigErrorRecoveryEnableDebugLog(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigErrorRecoveryEnableTooltip sets value of ImGuiIO.ConfigErrorRecoveryEnableTooltip
//
// = true       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.
func (self IO) SetConfigErrorRecoveryEnableTooltip(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigErrorRecoveryEnableTooltip(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigErrorRecoveryEnableTooltip returns value of ImGuiIO.ConfigErrorRecoveryEnableTooltip
//
// = true       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.
func (self *IO) ConfigErrorRecoveryEnableTooltip() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigErrorRecoveryEnableTooltip(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDebugIsDebuggerPresent sets value of ImGuiIO.ConfigDebugIsDebuggerPresent
//
//	// Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.
//	// - The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.
//	// - Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.
//	//   e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).
//
// = false          // Enable various tools calling IM_DEBUG_BREAK().
func (self IO) SetConfigDebugIsDebuggerPresent(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugIsDebuggerPresent(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDebugIsDebuggerPresent returns value of ImGuiIO.ConfigDebugIsDebuggerPresent
//
//	// Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.
//	// - The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.
//	// - Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.
//	//   e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).
//
// = false          // Enable various tools calling IM_DEBUG_BREAK().
func (self *IO) ConfigDebugIsDebuggerPresent() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugIsDebuggerPresent(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDebugHighlightIdConflicts sets value of ImGuiIO.ConfigDebugHighlightIdConflicts
//
//	// Tools to detect code submitting items with conflicting/duplicate IDs
//	// - Code should use PushID()/PopID() in loops, or append "##xx" to same-label identifiers.
//	// - Empty label e.g. Button("") == same ID as parent widget/node. Use Button("##xx") instead!
//	// - See FAQ https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system
//
// = true           // Highlight and show an error message when multiple items have conflicting identifiers.
func (self IO) SetConfigDebugHighlightIdConflicts(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugHighlightIdConflicts(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDebugHighlightIdConflicts returns value of ImGuiIO.ConfigDebugHighlightIdConflicts
//
//	// Tools to detect code submitting items with conflicting/duplicate IDs
//	// - Code should use PushID()/PopID() in loops, or append "##xx" to same-label identifiers.
//	// - Empty label e.g. Button("") == same ID as parent widget/node. Use Button("##xx") instead!
//	// - See FAQ https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system
//
// = true           // Highlight and show an error message when multiple items have conflicting identifiers.
func (self *IO) ConfigDebugHighlightIdConflicts() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugHighlightIdConflicts(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDebugBeginReturnValueOnce sets value of ImGuiIO.ConfigDebugBeginReturnValueOnce
//
//	// Tools to test correct Begin/End and BeginChild/EndChild behaviors.
//	// - Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()
//	// - This is inconsistent with other BeginXXX functions and create confusion for many users.
//	// - We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.
//
// = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.
func (self IO) SetConfigDebugBeginReturnValueOnce(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugBeginReturnValueOnce(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDebugBeginReturnValueOnce returns value of ImGuiIO.ConfigDebugBeginReturnValueOnce
//
//	// Tools to test correct Begin/End and BeginChild/EndChild behaviors.
//	// - Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()
//	// - This is inconsistent with other BeginXXX functions and create confusion for many users.
//	// - We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.
//
// = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.
func (self *IO) ConfigDebugBeginReturnValueOnce() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugBeginReturnValueOnce(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDebugBeginReturnValueLoop sets value of ImGuiIO.ConfigDebugBeginReturnValueLoop
//
// = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.
func (self IO) SetConfigDebugBeginReturnValueLoop(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugBeginReturnValueLoop(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDebugBeginReturnValueLoop returns value of ImGuiIO.ConfigDebugBeginReturnValueLoop
//
// = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.
func (self *IO) ConfigDebugBeginReturnValueLoop() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugBeginReturnValueLoop(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDebugIgnoreFocusLoss sets value of ImGuiIO.ConfigDebugIgnoreFocusLoss
//
//	// Option to deactivate io.AddFocusEvent(false) handling.
//	// - May facilitate interactions with a debugger when focus loss leads to clearing inputs data.
//	// - Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.
//
// = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.
func (self IO) SetConfigDebugIgnoreFocusLoss(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugIgnoreFocusLoss(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDebugIgnoreFocusLoss returns value of ImGuiIO.ConfigDebugIgnoreFocusLoss
//
//	// Option to deactivate io.AddFocusEvent(false) handling.
//	// - May facilitate interactions with a debugger when focus loss leads to clearing inputs data.
//	// - Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.
//
// = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.
func (self *IO) ConfigDebugIgnoreFocusLoss() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugIgnoreFocusLoss(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetConfigDebugIniSettings sets value of ImGuiIO.ConfigDebugIniSettings
//
//	// Option to audit .ini data
//
// = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)
func (self IO) SetConfigDebugIniSettings(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetConfigDebugIniSettings(selfArg, C.bool(v))
}

// ImGuiIO_GetConfigDebugIniSettings returns value of ImGuiIO.ConfigDebugIniSettings
//
//	// Option to audit .ini data
//
// = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)
func (self *IO) ConfigDebugIniSettings() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetConfigDebugIniSettings(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetBackendPlatformName sets value of ImGuiIO.BackendPlatformName
//
//	// Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.
//
// = NULL
func (self IO) SetBackendPlatformName(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendPlatformName(selfArg, vArg)
}

// ImGuiIO_GetBackendPlatformName returns value of ImGuiIO.BackendPlatformName
//
//	// Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.
//
// = NULL
func (self *IO) BackendPlatformName() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiIO_GetBackendPlatformName(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiIO_SetBackendRendererName sets value of ImGuiIO.BackendRendererName
//
// = NULL
func (self IO) SetBackendRendererName(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendRendererName(selfArg, vArg)
}

// ImGuiIO_GetBackendRendererName returns value of ImGuiIO.BackendRendererName
//
// = NULL
func (self *IO) BackendRendererName() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiIO_GetBackendRendererName(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiIO_SetBackendPlatformUserData sets value of ImGuiIO.BackendPlatformUserData
//
// = NULL           // User data for platform backend
func (self IO) SetBackendPlatformUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendPlatformUserData(selfArg, C.uintptr_t(v))
}

// ImGuiIO_GetBackendPlatformUserData returns value of ImGuiIO.BackendPlatformUserData
//
// = NULL           // User data for platform backend
func (self *IO) BackendPlatformUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiIO_GetBackendPlatformUserData(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetBackendRendererUserData sets value of ImGuiIO.BackendRendererUserData
//
// = NULL           // User data for renderer backend
func (self IO) SetBackendRendererUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendRendererUserData(selfArg, C.uintptr_t(v))
}

// ImGuiIO_GetBackendRendererUserData returns value of ImGuiIO.BackendRendererUserData
//
// = NULL           // User data for renderer backend
func (self *IO) BackendRendererUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiIO_GetBackendRendererUserData(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetBackendLanguageUserData sets value of ImGuiIO.BackendLanguageUserData
//
// = NULL           // User data for non C++ programming language backend
func (self IO) SetBackendLanguageUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendLanguageUserData(selfArg, C.uintptr_t(v))
}

// ImGuiIO_GetBackendLanguageUserData returns value of ImGuiIO.BackendLanguageUserData
//
// = NULL           // User data for non C++ programming language backend
func (self *IO) BackendLanguageUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiIO_GetBackendLanguageUserData(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetWantCaptureMouse sets value of ImGuiIO.WantCaptureMouse
//
// Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
func (self IO) SetWantCaptureMouse(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantCaptureMouse(selfArg, C.bool(v))
}

// ImGuiIO_GetWantCaptureMouse returns value of ImGuiIO.WantCaptureMouse
//
// Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
func (self *IO) WantCaptureMouse() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantCaptureMouse(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetWantCaptureKeyboard sets value of ImGuiIO.WantCaptureKeyboard
//
// Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
func (self IO) SetWantCaptureKeyboard(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantCaptureKeyboard(selfArg, C.bool(v))
}

// ImGuiIO_GetWantCaptureKeyboard returns value of ImGuiIO.WantCaptureKeyboard
//
// Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
func (self *IO) WantCaptureKeyboard() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantCaptureKeyboard(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetWantTextInput sets value of ImGuiIO.WantTextInput
//
// Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
func (self IO) SetWantTextInput(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantTextInput(selfArg, C.bool(v))
}

// ImGuiIO_GetWantTextInput returns value of ImGuiIO.WantTextInput
//
// Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
func (self *IO) WantTextInput() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantTextInput(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetWantSetMousePos sets value of ImGuiIO.WantSetMousePos
//
// MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.
func (self IO) SetWantSetMousePos(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantSetMousePos(selfArg, C.bool(v))
}

// ImGuiIO_GetWantSetMousePos returns value of ImGuiIO.WantSetMousePos
//
// MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.
func (self *IO) WantSetMousePos() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantSetMousePos(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetWantSaveIniSettings sets value of ImGuiIO.WantSaveIniSettings
//
// When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
func (self IO) SetWantSaveIniSettings(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantSaveIniSettings(selfArg, C.bool(v))
}

// ImGuiIO_GetWantSaveIniSettings returns value of ImGuiIO.WantSaveIniSettings
//
// When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
func (self *IO) WantSaveIniSettings() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantSaveIniSettings(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetNavActive sets value of ImGuiIO.NavActive
//
// Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
func (self IO) SetNavActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetNavActive(selfArg, C.bool(v))
}

// ImGuiIO_GetNavActive returns value of ImGuiIO.NavActive
//
// Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
func (self *IO) NavActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetNavActive(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetNavVisible sets value of ImGuiIO.NavVisible
//
// Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).
func (self IO) SetNavVisible(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetNavVisible(selfArg, C.bool(v))
}

// ImGuiIO_GetNavVisible returns value of ImGuiIO.NavVisible
//
// Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).
func (self *IO) NavVisible() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetNavVisible(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetFramerate sets value of ImGuiIO.Framerate
//
// Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.
func (self IO) SetFramerate(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetFramerate(selfArg, C.float(v))
}

// ImGuiIO_GetFramerate returns value of ImGuiIO.Framerate
//
// Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.
func (self *IO) Framerate() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetFramerate(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMetricsRenderVertices sets value of ImGuiIO.MetricsRenderVertices
//
// Vertices output during last call to Render()
func (self IO) SetMetricsRenderVertices(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsRenderVertices(selfArg, C.int(v))
}

// ImGuiIO_GetMetricsRenderVertices returns value of ImGuiIO.MetricsRenderVertices
//
// Vertices output during last call to Render()
func (self *IO) MetricsRenderVertices() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsRenderVertices(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMetricsRenderIndices sets value of ImGuiIO.MetricsRenderIndices
//
// Indices output during last call to Render() = number of triangles * 3
func (self IO) SetMetricsRenderIndices(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsRenderIndices(selfArg, C.int(v))
}

// ImGuiIO_GetMetricsRenderIndices returns value of ImGuiIO.MetricsRenderIndices
//
// Indices output during last call to Render() = number of triangles * 3
func (self *IO) MetricsRenderIndices() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsRenderIndices(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMetricsRenderWindows sets value of ImGuiIO.MetricsRenderWindows
//
// Number of visible windows
func (self IO) SetMetricsRenderWindows(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsRenderWindows(selfArg, C.int(v))
}

// ImGuiIO_GetMetricsRenderWindows returns value of ImGuiIO.MetricsRenderWindows
//
// Number of visible windows
func (self *IO) MetricsRenderWindows() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsRenderWindows(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMetricsActiveWindows sets value of ImGuiIO.MetricsActiveWindows
//
// Number of active windows
func (self IO) SetMetricsActiveWindows(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMetricsActiveWindows(selfArg, C.int(v))
}

// ImGuiIO_GetMetricsActiveWindows returns value of ImGuiIO.MetricsActiveWindows
//
// Number of active windows
func (self *IO) MetricsActiveWindows() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiIO_GetMetricsActiveWindows(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMouseDelta sets value of ImGuiIO.MouseDelta
//
// Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
func (self IO) SetMouseDelta(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDelta(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiIO_GetMouseDelta returns value of ImGuiIO.MouseDelta
//
// Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
func (self *IO) MouseDelta() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiIO_GetMouseDelta(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiIO_SetCtx sets value of ImGuiIO.Ctx
//
// Parent UI context (needs to be set explicitly by parent).
func (self IO) SetCtx(v *Context) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetCtx(selfArg, internal.ReinterpretCast[*C.ImGuiContext](vArg))
}

// ImGuiIO_GetCtx returns value of ImGuiIO.Ctx
//
// Parent UI context (needs to be set explicitly by parent).
func (self *IO) Ctx() *Context {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewContextFromC(C.wrap_ImGuiIO_GetCtx(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMousePos sets value of ImGuiIO.MousePos
//
//	// Main Input State
//	// (this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)
//	// (reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)
//
// Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)
func (self IO) SetMousePos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMousePos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiIO_GetMousePos returns value of ImGuiIO.MousePos
//
//	// Main Input State
//	// (this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)
//	// (reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)
//
// Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)
func (self *IO) MousePos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiIO_GetMousePos(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiIO_SetMouseDown sets value of ImGuiIO.MouseDown[5]
//
// Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
func (self IO) SetMouseDown(v *[5]bool) {
	vArg := make([]C.bool, len(v))
	for i, vV := range v {
		vArg[i] = C.bool(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDown(selfArg, (*C.bool)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = vV == C.bool(true)
	}
}

// ImGuiIO_GetMouseDown returns value of ImGuiIO.MouseDown[5]
//
// Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
func (self *IO) MouseDown() [5]bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]bool {
		result := [5]bool{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDown(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = C.cimgui_bool_GetAtIdx(resultMirr, C.int(i)) == C.bool(true)
		}

		return result
	}()
}

// ImGuiIO_SetMouseWheel sets value of ImGuiIO.MouseWheel
//
// Mouse wheel Vertical: 1 unit scrolls about 5 lines text. >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.
func (self IO) SetMouseWheel(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseWheel(selfArg, C.float(v))
}

// ImGuiIO_GetMouseWheel returns value of ImGuiIO.MouseWheel
//
// Mouse wheel Vertical: 1 unit scrolls about 5 lines text. >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.
func (self *IO) MouseWheel() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseWheel(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMouseWheelH sets value of ImGuiIO.MouseWheelH
//
// Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.
func (self IO) SetMouseWheelH(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseWheelH(selfArg, C.float(v))
}

// ImGuiIO_GetMouseWheelH returns value of ImGuiIO.MouseWheelH
//
// Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.
func (self *IO) MouseWheelH() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetMouseWheelH(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMouseSource sets value of ImGuiIO.MouseSource
//
// Mouse actual input peripheral (Mouse/TouchScreen/Pen).
func (self IO) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

// ImGuiIO_GetMouseSource returns value of ImGuiIO.MouseSource
//
// Mouse actual input peripheral (Mouse/TouchScreen/Pen).
func (self *IO) MouseSource() MouseSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiIO_GetMouseSource(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetMouseHoveredViewport sets value of ImGuiIO.MouseHoveredViewport
//
// (Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).
func (self IO) SetMouseHoveredViewport(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseHoveredViewport(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiIO_GetMouseHoveredViewport returns value of ImGuiIO.MouseHoveredViewport
//
// (Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).
func (self *IO) MouseHoveredViewport() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiIO_GetMouseHoveredViewport(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		return &result
	}())
}

// ImGuiIO_SetKeyCtrl sets value of ImGuiIO.KeyCtrl
//
// Keyboard modifier down: Control
func (self IO) SetKeyCtrl(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyCtrl(selfArg, C.bool(v))
}

// ImGuiIO_GetKeyCtrl returns value of ImGuiIO.KeyCtrl
//
// Keyboard modifier down: Control
func (self *IO) KeyCtrl() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeyCtrl(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetKeyShift sets value of ImGuiIO.KeyShift
//
// Keyboard modifier down: Shift
func (self IO) SetKeyShift(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyShift(selfArg, C.bool(v))
}

// ImGuiIO_GetKeyShift returns value of ImGuiIO.KeyShift
//
// Keyboard modifier down: Shift
func (self *IO) KeyShift() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeyShift(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetKeyAlt sets value of ImGuiIO.KeyAlt
//
// Keyboard modifier down: Alt
func (self IO) SetKeyAlt(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyAlt(selfArg, C.bool(v))
}

// ImGuiIO_GetKeyAlt returns value of ImGuiIO.KeyAlt
//
// Keyboard modifier down: Alt
func (self *IO) KeyAlt() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeyAlt(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetKeySuper sets value of ImGuiIO.KeySuper
//
// Keyboard modifier down: Cmd/Super/Windows
func (self IO) SetKeySuper(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeySuper(selfArg, C.bool(v))
}

// ImGuiIO_GetKeySuper returns value of ImGuiIO.KeySuper
//
// Keyboard modifier down: Cmd/Super/Windows
func (self *IO) KeySuper() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetKeySuper(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetKeyMods sets value of ImGuiIO.KeyMods
//
//	// Other state maintained from data above + IO function calls
//
// Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()
func (self IO) SetKeyMods(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeyMods(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiIO_GetKeyMods returns value of ImGuiIO.KeyMods
//
//	// Other state maintained from data above + IO function calls
//
// Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()
func (self *IO) KeyMods() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiIO_GetKeyMods(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		return &result
	}())
}

// ImGuiIO_SetKeysData sets value of ImGuiIO.KeysData[ImGuiKey_KeysData_SIZE]
//
// Key state for all known keys. Use IsKeyXXX() functions to access this.
func (self IO) SetKeysData(v *[154]KeyData) {
	vArg := make([]C.ImGuiKeyData, len(v))
	for i, vV := range v {
		vVArg, _ := vV.C()
		vArg[i] = internal.ReinterpretCast[C.ImGuiKeyData](vVArg)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetKeysData(selfArg, (*C.ImGuiKeyData)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = *NewKeyDataFromC(func() *C.ImGuiKeyData { result := vV; return &result }())
	}
}

// ImGuiIO_GetKeysData returns value of ImGuiIO.KeysData[ImGuiKey_KeysData_SIZE]
//
// Key state for all known keys. Use IsKeyXXX() functions to access this.
func (self *IO) KeysData() [154]KeyData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [154]KeyData {
		result := [154]KeyData{}
		resultMirr := C.wrap_ImGuiIO_GetKeysData(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = *NewKeyDataFromC(func() *C.ImGuiKeyData { result := C.cimgui_ImGuiKeyData_GetAtIdx(resultMirr, C.int(i)); return &result }())
		}

		return result
	}()
}

// ImGuiIO_SetWantCaptureMouseUnlessPopupClose sets value of ImGuiIO.WantCaptureMouseUnlessPopupClose
//
// Alternative to WantCaptureMouse: (WantCaptureMouse == true && WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.
func (self IO) SetWantCaptureMouseUnlessPopupClose(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetWantCaptureMouseUnlessPopupClose(selfArg, C.bool(v))
}

// ImGuiIO_GetWantCaptureMouseUnlessPopupClose returns value of ImGuiIO.WantCaptureMouseUnlessPopupClose
//
// Alternative to WantCaptureMouse: (WantCaptureMouse == true && WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.
func (self *IO) WantCaptureMouseUnlessPopupClose() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetWantCaptureMouseUnlessPopupClose(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetMousePosPrev sets value of ImGuiIO.MousePosPrev
//
// Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
func (self IO) SetMousePosPrev(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMousePosPrev(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiIO_GetMousePosPrev returns value of ImGuiIO.MousePosPrev
//
// Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
func (self *IO) MousePosPrev() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiIO_GetMousePosPrev(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiIO_SetMouseClickedPos sets value of ImGuiIO.MouseClickedPos[5]
//
// Position at time of clicking
func (self IO) SetMouseClickedPos(v *[5]Vec2) {
	vArg := make([]C.ImVec2, len(v))
	for i, vV := range v {
		vArg[i] = internal.ReinterpretCast[C.ImVec2](vV.ToC())
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseClickedPos(selfArg, (*C.ImVec2)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() Vec2 { out := vV; return *(&Vec2{}).FromC(unsafe.Pointer(&out)) }()
	}
}

// ImGuiIO_GetMouseClickedPos returns value of ImGuiIO.MouseClickedPos[5]
//
// Position at time of clicking
func (self *IO) MouseClickedPos() [5]Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]Vec2 {
		result := [5]Vec2{}
		resultMirr := C.wrap_ImGuiIO_GetMouseClickedPos(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = func() Vec2 {
				out := C.cimgui_ImVec2_GetAtIdx(resultMirr, C.int(i))
				return *(&Vec2{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}

// ImGuiIO_SetMouseClickedTime sets value of ImGuiIO.MouseClickedTime[5]
//
// Time of last click (used to figure out double-click)
func (self IO) SetMouseClickedTime(v *[5]float64) {
	vArg := make([]C.double, len(v))
	for i, vV := range v {
		vArg[i] = C.double(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseClickedTime(selfArg, (*C.double)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = float64(vV)
	}
}

// ImGuiIO_GetMouseClickedTime returns value of ImGuiIO.MouseClickedTime[5]
//
// Time of last click (used to figure out double-click)
func (self *IO) MouseClickedTime() [5]float64 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]float64 {
		result := [5]float64{}
		resultMirr := C.wrap_ImGuiIO_GetMouseClickedTime(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = float64(C.cimgui_double_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiIO_SetMouseClicked sets value of ImGuiIO.MouseClicked[5]
//
// Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)
func (self IO) SetMouseClicked(v *[5]bool) {
	vArg := make([]C.bool, len(v))
	for i, vV := range v {
		vArg[i] = C.bool(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseClicked(selfArg, (*C.bool)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = vV == C.bool(true)
	}
}

// ImGuiIO_GetMouseClicked returns value of ImGuiIO.MouseClicked[5]
//
// Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)
func (self *IO) MouseClicked() [5]bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]bool {
		result := [5]bool{}
		resultMirr := C.wrap_ImGuiIO_GetMouseClicked(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = C.cimgui_bool_GetAtIdx(resultMirr, C.int(i)) == C.bool(true)
		}

		return result
	}()
}

// ImGuiIO_SetMouseDoubleClicked sets value of ImGuiIO.MouseDoubleClicked[5]
//
// Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)
func (self IO) SetMouseDoubleClicked(v *[5]bool) {
	vArg := make([]C.bool, len(v))
	for i, vV := range v {
		vArg[i] = C.bool(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDoubleClicked(selfArg, (*C.bool)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = vV == C.bool(true)
	}
}

// ImGuiIO_GetMouseDoubleClicked returns value of ImGuiIO.MouseDoubleClicked[5]
//
// Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)
func (self *IO) MouseDoubleClicked() [5]bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]bool {
		result := [5]bool{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDoubleClicked(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = C.cimgui_bool_GetAtIdx(resultMirr, C.int(i)) == C.bool(true)
		}

		return result
	}()
}

// ImGuiIO_SetMouseClickedCount sets value of ImGuiIO.MouseClickedCount[5]
//
// == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down
func (self IO) SetMouseClickedCount(v *[5]uint16) {
	vArg := make([]C.ImU16, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU16(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseClickedCount(selfArg, (*C.ImU16)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = uint16(vV)
	}
}

// ImGuiIO_GetMouseClickedCount returns value of ImGuiIO.MouseClickedCount[5]
//
// == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down
func (self *IO) MouseClickedCount() [5]uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]uint16 {
		result := [5]uint16{}
		resultMirr := C.wrap_ImGuiIO_GetMouseClickedCount(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = uint16(C.cimgui_ImU16_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiIO_SetMouseClickedLastCount sets value of ImGuiIO.MouseClickedLastCount[5]
//
// Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.
func (self IO) SetMouseClickedLastCount(v *[5]uint16) {
	vArg := make([]C.ImU16, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU16(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseClickedLastCount(selfArg, (*C.ImU16)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = uint16(vV)
	}
}

// ImGuiIO_GetMouseClickedLastCount returns value of ImGuiIO.MouseClickedLastCount[5]
//
// Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.
func (self *IO) MouseClickedLastCount() [5]uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]uint16 {
		result := [5]uint16{}
		resultMirr := C.wrap_ImGuiIO_GetMouseClickedLastCount(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = uint16(C.cimgui_ImU16_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiIO_SetMouseReleased sets value of ImGuiIO.MouseReleased[5]
//
// Mouse button went from Down to !Down
func (self IO) SetMouseReleased(v *[5]bool) {
	vArg := make([]C.bool, len(v))
	for i, vV := range v {
		vArg[i] = C.bool(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseReleased(selfArg, (*C.bool)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = vV == C.bool(true)
	}
}

// ImGuiIO_GetMouseReleased returns value of ImGuiIO.MouseReleased[5]
//
// Mouse button went from Down to !Down
func (self *IO) MouseReleased() [5]bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]bool {
		result := [5]bool{}
		resultMirr := C.wrap_ImGuiIO_GetMouseReleased(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = C.cimgui_bool_GetAtIdx(resultMirr, C.int(i)) == C.bool(true)
		}

		return result
	}()
}

// ImGuiIO_SetMouseDownOwned sets value of ImGuiIO.MouseDownOwned[5]
//
// Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.
func (self IO) SetMouseDownOwned(v *[5]bool) {
	vArg := make([]C.bool, len(v))
	for i, vV := range v {
		vArg[i] = C.bool(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDownOwned(selfArg, (*C.bool)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = vV == C.bool(true)
	}
}

// ImGuiIO_GetMouseDownOwned returns value of ImGuiIO.MouseDownOwned[5]
//
// Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.
func (self *IO) MouseDownOwned() [5]bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]bool {
		result := [5]bool{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDownOwned(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = C.cimgui_bool_GetAtIdx(resultMirr, C.int(i)) == C.bool(true)
		}

		return result
	}()
}

// ImGuiIO_SetMouseDownOwnedUnlessPopupClose sets value of ImGuiIO.MouseDownOwnedUnlessPopupClose[5]
//
// Track if button was clicked inside a dear imgui window.
func (self IO) SetMouseDownOwnedUnlessPopupClose(v *[5]bool) {
	vArg := make([]C.bool, len(v))
	for i, vV := range v {
		vArg[i] = C.bool(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDownOwnedUnlessPopupClose(selfArg, (*C.bool)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = vV == C.bool(true)
	}
}

// ImGuiIO_GetMouseDownOwnedUnlessPopupClose returns value of ImGuiIO.MouseDownOwnedUnlessPopupClose[5]
//
// Track if button was clicked inside a dear imgui window.
func (self *IO) MouseDownOwnedUnlessPopupClose() [5]bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]bool {
		result := [5]bool{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDownOwnedUnlessPopupClose(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = C.cimgui_bool_GetAtIdx(resultMirr, C.int(i)) == C.bool(true)
		}

		return result
	}()
}

// ImGuiIO_SetMouseWheelRequestAxisSwap sets value of ImGuiIO.MouseWheelRequestAxisSwap
//
// On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.
func (self IO) SetMouseWheelRequestAxisSwap(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseWheelRequestAxisSwap(selfArg, C.bool(v))
}

// ImGuiIO_GetMouseWheelRequestAxisSwap returns value of ImGuiIO.MouseWheelRequestAxisSwap
//
// On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.
func (self *IO) MouseWheelRequestAxisSwap() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetMouseWheelRequestAxisSwap(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetMouseCtrlLeftAsRightClick sets value of ImGuiIO.MouseCtrlLeftAsRightClick
//
// (OSX) Set to true when the current click was a ctrl-click that spawned a simulated right click
func (self IO) SetMouseCtrlLeftAsRightClick(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseCtrlLeftAsRightClick(selfArg, C.bool(v))
}

// ImGuiIO_GetMouseCtrlLeftAsRightClick returns value of ImGuiIO.MouseCtrlLeftAsRightClick
//
// (OSX) Set to true when the current click was a ctrl-click that spawned a simulated right click
func (self *IO) MouseCtrlLeftAsRightClick() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetMouseCtrlLeftAsRightClick(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetMouseDownDuration sets value of ImGuiIO.MouseDownDuration[5]
//
// Duration the mouse button has been down (0.0f == just clicked)
func (self IO) SetMouseDownDuration(v *[5]float32) {
	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDownDuration(selfArg, (*C.float)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = float32(vV)
	}
}

// ImGuiIO_GetMouseDownDuration returns value of ImGuiIO.MouseDownDuration[5]
//
// Duration the mouse button has been down (0.0f == just clicked)
func (self *IO) MouseDownDuration() [5]float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]float32 {
		result := [5]float32{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDownDuration(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = float32(C.cimgui_float_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiIO_SetMouseDownDurationPrev sets value of ImGuiIO.MouseDownDurationPrev[5]
//
// Previous time the mouse button has been down
func (self IO) SetMouseDownDurationPrev(v *[5]float32) {
	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDownDurationPrev(selfArg, (*C.float)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = float32(vV)
	}
}

// ImGuiIO_GetMouseDownDurationPrev returns value of ImGuiIO.MouseDownDurationPrev[5]
//
// Previous time the mouse button has been down
func (self *IO) MouseDownDurationPrev() [5]float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]float32 {
		result := [5]float32{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDownDurationPrev(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = float32(C.cimgui_float_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiIO_SetMouseDragMaxDistanceAbs sets value of ImGuiIO.MouseDragMaxDistanceAbs[5]
//
// Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
func (self IO) SetMouseDragMaxDistanceAbs(v *[5]Vec2) {
	vArg := make([]C.ImVec2, len(v))
	for i, vV := range v {
		vArg[i] = internal.ReinterpretCast[C.ImVec2](vV.ToC())
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDragMaxDistanceAbs(selfArg, (*C.ImVec2)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() Vec2 { out := vV; return *(&Vec2{}).FromC(unsafe.Pointer(&out)) }()
	}
}

// ImGuiIO_GetMouseDragMaxDistanceAbs returns value of ImGuiIO.MouseDragMaxDistanceAbs[5]
//
// Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
func (self *IO) MouseDragMaxDistanceAbs() [5]Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]Vec2 {
		result := [5]Vec2{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDragMaxDistanceAbs(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = func() Vec2 {
				out := C.cimgui_ImVec2_GetAtIdx(resultMirr, C.int(i))
				return *(&Vec2{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}

// ImGuiIO_SetMouseDragMaxDistanceSqr sets value of ImGuiIO.MouseDragMaxDistanceSqr[5]
//
// Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)
func (self IO) SetMouseDragMaxDistanceSqr(v *[5]float32) {
	vArg := make([]C.float, len(v))
	for i, vV := range v {
		vArg[i] = C.float(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetMouseDragMaxDistanceSqr(selfArg, (*C.float)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = float32(vV)
	}
}

// ImGuiIO_GetMouseDragMaxDistanceSqr returns value of ImGuiIO.MouseDragMaxDistanceSqr[5]
//
// Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)
func (self *IO) MouseDragMaxDistanceSqr() [5]float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [5]float32 {
		result := [5]float32{}
		resultMirr := C.wrap_ImGuiIO_GetMouseDragMaxDistanceSqr(internal.ReinterpretCast[*C.ImGuiIO](selfArg))
		for i := range result {
			result[i] = float32(C.cimgui_float_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiIO_SetPenPressure sets value of ImGuiIO.PenPressure
//
// Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
func (self IO) SetPenPressure(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetPenPressure(selfArg, C.float(v))
}

// ImGuiIO_GetPenPressure returns value of ImGuiIO.PenPressure
//
// Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
func (self *IO) PenPressure() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiIO_GetPenPressure(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetAppFocusLost sets value of ImGuiIO.AppFocusLost
//
// Only modify via AddFocusEvent()
func (self IO) SetAppFocusLost(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetAppFocusLost(selfArg, C.bool(v))
}

// ImGuiIO_GetAppFocusLost returns value of ImGuiIO.AppFocusLost
//
// Only modify via AddFocusEvent()
func (self *IO) AppFocusLost() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetAppFocusLost(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetBackendUsingLegacyKeyArrays sets value of ImGuiIO.BackendUsingLegacyKeyArrays
//
// -1: unknown, 0: using AddKeyEvent(), 1: using legacy io.KeysDown[]
func (self IO) SetBackendUsingLegacyKeyArrays(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendUsingLegacyKeyArrays(selfArg, C.ImS8(v))
}

// ImGuiIO_GetBackendUsingLegacyKeyArrays returns value of ImGuiIO.BackendUsingLegacyKeyArrays
//
// -1: unknown, 0: using AddKeyEvent(), 1: using legacy io.KeysDown[]
func (self *IO) BackendUsingLegacyKeyArrays() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiIO_GetBackendUsingLegacyKeyArrays(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetBackendUsingLegacyNavInputArray sets value of ImGuiIO.BackendUsingLegacyNavInputArray
//
// 0: using AddKeyAnalogEvent(), 1: writing to legacy io.NavInputs[] directly
func (self IO) SetBackendUsingLegacyNavInputArray(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetBackendUsingLegacyNavInputArray(selfArg, C.bool(v))
}

// ImGuiIO_GetBackendUsingLegacyNavInputArray returns value of ImGuiIO.BackendUsingLegacyNavInputArray
//
// 0: using AddKeyAnalogEvent(), 1: writing to legacy io.NavInputs[] directly
func (self *IO) BackendUsingLegacyNavInputArray() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiIO_GetBackendUsingLegacyNavInputArray(internal.ReinterpretCast[*C.ImGuiIO](selfArg)) == C.bool(true)
}

// ImGuiIO_SetInputQueueSurrogate sets value of ImGuiIO.InputQueueSurrogate
//
// For AddInputCharacterUTF16()
func (self IO) SetInputQueueSurrogate(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetInputQueueSurrogate(selfArg, C.ImWchar16(v))
}

// ImGuiIO_GetInputQueueSurrogate returns value of ImGuiIO.InputQueueSurrogate
//
// For AddInputCharacterUTF16()
func (self *IO) InputQueueSurrogate() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiIO_GetInputQueueSurrogate(internal.ReinterpretCast[*C.ImGuiIO](selfArg)))
}

// ImGuiIO_SetInputQueueCharacters sets value of ImGuiIO.InputQueueCharacters
//
// Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
func (self IO) SetInputQueueCharacters(v vectors.Vector[(Wchar)]) {
	vData := v.Data

	vVecArg := new(C.ImVector_ImWchar)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = (*C.ImWchar)(vData)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiIO_SetInputQueueCharacters(selfArg, *vVecArg)
}

// ImGuiIO_GetInputQueueCharacters returns value of ImGuiIO.InputQueueCharacters
//
// Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
func (self *IO) InputQueueCharacters() vectors.Vector[(Wchar)] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiIO_GetInputQueueCharacters(internal.ReinterpretCast[*C.ImGuiIO](selfArg)).Size, C.wrap_ImGuiIO_GetInputQueueCharacters(internal.ReinterpretCast[*C.ImGuiIO](selfArg)).Capacity, (*Wchar)(C.wrap_ImGuiIO_GetInputQueueCharacters(internal.ReinterpretCast[*C.ImGuiIO](selfArg)).Data))
}

// ImGuiInputEvent_SetType sets value of ImGuiInputEvent.Type
func (self InputEvent) SetType(v InputEventType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetType(selfArg, C.ImGuiInputEventType(v))
}

// ImGuiInputEvent_GetType returns value of ImGuiInputEvent.Type
func (self *InputEvent) Type() InputEventType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputEventType(C.wrap_ImGuiInputEvent_GetType(internal.ReinterpretCast[*C.ImGuiInputEvent](selfArg)))
}

// ImGuiInputEvent_SetSource sets value of ImGuiInputEvent.Source
func (self InputEvent) SetSource(v InputSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetSource(selfArg, C.ImGuiInputSource(v))
}

// ImGuiInputEvent_GetSource returns value of ImGuiInputEvent.Source
func (self *InputEvent) Source() InputSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputSource(C.wrap_ImGuiInputEvent_GetSource(internal.ReinterpretCast[*C.ImGuiInputEvent](selfArg)))
}

// ImGuiInputEvent_SetEventId sets value of ImGuiInputEvent.EventId
//
// Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).
func (self InputEvent) SetEventId(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetEventId(selfArg, C.ImU32(v))
}

// ImGuiInputEvent_GetEventId returns value of ImGuiInputEvent.EventId
//
// Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).
func (self *InputEvent) EventId() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiInputEvent_GetEventId(internal.ReinterpretCast[*C.ImGuiInputEvent](selfArg)))
}

// ImGuiInputEvent_SetAddedByTestEngine sets value of ImGuiInputEvent.AddedByTestEngine
func (self InputEvent) SetAddedByTestEngine(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEvent_SetAddedByTestEngine(selfArg, C.bool(v))
}

// ImGuiInputEvent_GetAddedByTestEngine returns value of ImGuiInputEvent.AddedByTestEngine
func (self *InputEvent) AddedByTestEngine() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEvent_GetAddedByTestEngine(internal.ReinterpretCast[*C.ImGuiInputEvent](selfArg)) == C.bool(true)
}

// ImGuiInputEventAppFocused_SetFocused sets value of ImGuiInputEventAppFocused.Focused
func (self InputEventAppFocused) SetFocused(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventAppFocused_SetFocused(selfArg, C.bool(v))
}

// ImGuiInputEventAppFocused_GetFocused returns value of ImGuiInputEventAppFocused.Focused
func (self *InputEventAppFocused) Focused() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEventAppFocused_GetFocused(internal.ReinterpretCast[*C.ImGuiInputEventAppFocused](selfArg)) == C.bool(true)
}

// ImGuiInputEventKey_SetKey sets value of ImGuiInputEventKey.Key
func (self InputEventKey) SetKey(v Key) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventKey_SetKey(selfArg, C.ImGuiKey(v))
}

// ImGuiInputEventKey_GetKey returns value of ImGuiInputEventKey.Key
func (self *InputEventKey) Key() Key {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Key(C.wrap_ImGuiInputEventKey_GetKey(internal.ReinterpretCast[*C.ImGuiInputEventKey](selfArg)))
}

// ImGuiInputEventKey_SetDown sets value of ImGuiInputEventKey.Down
func (self InputEventKey) SetDown(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventKey_SetDown(selfArg, C.bool(v))
}

// ImGuiInputEventKey_GetDown returns value of ImGuiInputEventKey.Down
func (self *InputEventKey) Down() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEventKey_GetDown(internal.ReinterpretCast[*C.ImGuiInputEventKey](selfArg)) == C.bool(true)
}

// ImGuiInputEventKey_SetAnalogValue sets value of ImGuiInputEventKey.AnalogValue
func (self InputEventKey) SetAnalogValue(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventKey_SetAnalogValue(selfArg, C.float(v))
}

// ImGuiInputEventKey_GetAnalogValue returns value of ImGuiInputEventKey.AnalogValue
func (self *InputEventKey) AnalogValue() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventKey_GetAnalogValue(internal.ReinterpretCast[*C.ImGuiInputEventKey](selfArg)))
}

// ImGuiInputEventMouseButton_SetButton sets value of ImGuiInputEventMouseButton.Button
func (self InputEventMouseButton) SetButton(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseButton_SetButton(selfArg, C.int(v))
}

// ImGuiInputEventMouseButton_GetButton returns value of ImGuiInputEventMouseButton.Button
func (self *InputEventMouseButton) Button() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputEventMouseButton_GetButton(internal.ReinterpretCast[*C.ImGuiInputEventMouseButton](selfArg)))
}

// ImGuiInputEventMouseButton_SetDown sets value of ImGuiInputEventMouseButton.Down
func (self InputEventMouseButton) SetDown(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseButton_SetDown(selfArg, C.bool(v))
}

// ImGuiInputEventMouseButton_GetDown returns value of ImGuiInputEventMouseButton.Down
func (self *InputEventMouseButton) Down() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputEventMouseButton_GetDown(internal.ReinterpretCast[*C.ImGuiInputEventMouseButton](selfArg)) == C.bool(true)
}

// ImGuiInputEventMouseButton_SetMouseSource sets value of ImGuiInputEventMouseButton.MouseSource
func (self InputEventMouseButton) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseButton_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

// ImGuiInputEventMouseButton_GetMouseSource returns value of ImGuiInputEventMouseButton.MouseSource
func (self *InputEventMouseButton) MouseSource() MouseSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiInputEventMouseButton_GetMouseSource(internal.ReinterpretCast[*C.ImGuiInputEventMouseButton](selfArg)))
}

// ImGuiInputEventMousePos_SetPosX sets value of ImGuiInputEventMousePos.PosX
func (self InputEventMousePos) SetPosX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMousePos_SetPosX(selfArg, C.float(v))
}

// ImGuiInputEventMousePos_GetPosX returns value of ImGuiInputEventMousePos.PosX
func (self *InputEventMousePos) PosX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMousePos_GetPosX(internal.ReinterpretCast[*C.ImGuiInputEventMousePos](selfArg)))
}

// ImGuiInputEventMousePos_SetPosY sets value of ImGuiInputEventMousePos.PosY
func (self InputEventMousePos) SetPosY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMousePos_SetPosY(selfArg, C.float(v))
}

// ImGuiInputEventMousePos_GetPosY returns value of ImGuiInputEventMousePos.PosY
func (self *InputEventMousePos) PosY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMousePos_GetPosY(internal.ReinterpretCast[*C.ImGuiInputEventMousePos](selfArg)))
}

// ImGuiInputEventMousePos_SetMouseSource sets value of ImGuiInputEventMousePos.MouseSource
func (self InputEventMousePos) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMousePos_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

// ImGuiInputEventMousePos_GetMouseSource returns value of ImGuiInputEventMousePos.MouseSource
func (self *InputEventMousePos) MouseSource() MouseSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiInputEventMousePos_GetMouseSource(internal.ReinterpretCast[*C.ImGuiInputEventMousePos](selfArg)))
}

// ImGuiInputEventMouseViewport_SetHoveredViewportID sets value of ImGuiInputEventMouseViewport.HoveredViewportID
func (self InputEventMouseViewport) SetHoveredViewportID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseViewport_SetHoveredViewportID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiInputEventMouseViewport_GetHoveredViewportID returns value of ImGuiInputEventMouseViewport.HoveredViewportID
func (self *InputEventMouseViewport) HoveredViewportID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiInputEventMouseViewport_GetHoveredViewportID(internal.ReinterpretCast[*C.ImGuiInputEventMouseViewport](selfArg))
		return &result
	}())
}

// ImGuiInputEventMouseWheel_SetWheelX sets value of ImGuiInputEventMouseWheel.WheelX
func (self InputEventMouseWheel) SetWheelX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseWheel_SetWheelX(selfArg, C.float(v))
}

// ImGuiInputEventMouseWheel_GetWheelX returns value of ImGuiInputEventMouseWheel.WheelX
func (self *InputEventMouseWheel) WheelX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMouseWheel_GetWheelX(internal.ReinterpretCast[*C.ImGuiInputEventMouseWheel](selfArg)))
}

// ImGuiInputEventMouseWheel_SetWheelY sets value of ImGuiInputEventMouseWheel.WheelY
func (self InputEventMouseWheel) SetWheelY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseWheel_SetWheelY(selfArg, C.float(v))
}

// ImGuiInputEventMouseWheel_GetWheelY returns value of ImGuiInputEventMouseWheel.WheelY
func (self *InputEventMouseWheel) WheelY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputEventMouseWheel_GetWheelY(internal.ReinterpretCast[*C.ImGuiInputEventMouseWheel](selfArg)))
}

// ImGuiInputEventMouseWheel_SetMouseSource sets value of ImGuiInputEventMouseWheel.MouseSource
func (self InputEventMouseWheel) SetMouseSource(v MouseSource) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventMouseWheel_SetMouseSource(selfArg, C.ImGuiMouseSource(v))
}

// ImGuiInputEventMouseWheel_GetMouseSource returns value of ImGuiInputEventMouseWheel.MouseSource
func (self *InputEventMouseWheel) MouseSource() MouseSource {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return MouseSource(C.wrap_ImGuiInputEventMouseWheel_GetMouseSource(internal.ReinterpretCast[*C.ImGuiInputEventMouseWheel](selfArg)))
}

// ImGuiInputEventText_SetChar sets value of ImGuiInputEventText.Char
func (self InputEventText) SetChar(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputEventText_SetChar(selfArg, C.uint(v))
}

// ImGuiInputEventText_GetChar returns value of ImGuiInputEventText.Char
func (self *InputEventText) Char() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiInputEventText_GetChar(internal.ReinterpretCast[*C.ImGuiInputEventText](selfArg)))
}

// ImGuiInputTextCallbackData_SetCtx sets value of ImGuiInputTextCallbackData.Ctx
//
// Parent UI context
func (self InputTextCallbackData) SetCtx(v *Context) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetCtx(selfArg, internal.ReinterpretCast[*C.ImGuiContext](vArg))
}

// ImGuiInputTextCallbackData_GetCtx returns value of ImGuiInputTextCallbackData.Ctx
//
// Parent UI context
func (self *InputTextCallbackData) Ctx() *Context {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewContextFromC(C.wrap_ImGuiInputTextCallbackData_GetCtx(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetEventFlag sets value of ImGuiInputTextCallbackData.EventFlag
//
// One ImGuiInputTextFlags_Callback*    // Read-only
func (self InputTextCallbackData) SetEventFlag(v InputTextFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetEventFlag(selfArg, C.ImGuiInputTextFlags(v))
}

// ImGuiInputTextCallbackData_GetEventFlag returns value of ImGuiInputTextCallbackData.EventFlag
//
// One ImGuiInputTextFlags_Callback*    // Read-only
func (self *InputTextCallbackData) EventFlag() InputTextFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputTextFlags(C.wrap_ImGuiInputTextCallbackData_GetEventFlag(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetFlags sets value of ImGuiInputTextCallbackData.Flags
//
// What user passed to InputText()      // Read-only
func (self InputTextCallbackData) SetFlags(v InputTextFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetFlags(selfArg, C.ImGuiInputTextFlags(v))
}

// ImGuiInputTextCallbackData_GetFlags returns value of ImGuiInputTextCallbackData.Flags
//
// What user passed to InputText()      // Read-only
func (self *InputTextCallbackData) Flags() InputTextFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputTextFlags(C.wrap_ImGuiInputTextCallbackData_GetFlags(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetUserData sets value of ImGuiInputTextCallbackData.UserData
//
// What user passed to InputText()      // Read-only
func (self InputTextCallbackData) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetUserData(selfArg, C.uintptr_t(v))
}

// ImGuiInputTextCallbackData_GetUserData returns value of ImGuiInputTextCallbackData.UserData
//
// What user passed to InputText()      // Read-only
func (self *InputTextCallbackData) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiInputTextCallbackData_GetUserData(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetEventChar sets value of ImGuiInputTextCallbackData.EventChar
//
//	// Arguments for the different callback events
//	// - During Resize callback, Buf will be same as your input buffer.
//	// - However, during Completion/History/Always callback, Buf always points to our own internal data (it is not the same as your buffer)! Changes to it will be reflected into your own buffer shortly after the callback.
//	// - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
//	// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
//
// Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
func (self InputTextCallbackData) SetEventChar(v Wchar) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetEventChar(selfArg, C.ImWchar(v))
}

// ImGuiInputTextCallbackData_GetEventChar returns value of ImGuiInputTextCallbackData.EventChar
//
//	// Arguments for the different callback events
//	// - During Resize callback, Buf will be same as your input buffer.
//	// - However, during Completion/History/Always callback, Buf always points to our own internal data (it is not the same as your buffer)! Changes to it will be reflected into your own buffer shortly after the callback.
//	// - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
//	// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
//
// Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
func (self *InputTextCallbackData) EventChar() Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImGuiInputTextCallbackData_GetEventChar(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetEventKey sets value of ImGuiInputTextCallbackData.EventKey
//
// Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
func (self InputTextCallbackData) SetEventKey(v Key) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetEventKey(selfArg, C.ImGuiKey(v))
}

// ImGuiInputTextCallbackData_GetEventKey returns value of ImGuiInputTextCallbackData.EventKey
//
// Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
func (self *InputTextCallbackData) EventKey() Key {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Key(C.wrap_ImGuiInputTextCallbackData_GetEventKey(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetBuf sets value of ImGuiInputTextCallbackData.Buf
//
// Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
func (self InputTextCallbackData) SetBuf(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBuf(selfArg, vArg)
}

// ImGuiInputTextCallbackData_GetBuf returns value of ImGuiInputTextCallbackData.Buf
//
// Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
func (self *InputTextCallbackData) Buf() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiInputTextCallbackData_GetBuf(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiInputTextCallbackData_SetBufTextLen sets value of ImGuiInputTextCallbackData.BufTextLen
//
// Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
func (self InputTextCallbackData) SetBufTextLen(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBufTextLen(selfArg, C.int(v))
}

// ImGuiInputTextCallbackData_GetBufTextLen returns value of ImGuiInputTextCallbackData.BufTextLen
//
// Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
func (self *InputTextCallbackData) BufTextLen() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetBufTextLen(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetBufSize sets value of ImGuiInputTextCallbackData.BufSize
//
// Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
func (self InputTextCallbackData) SetBufSize(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBufSize(selfArg, C.int(v))
}

// ImGuiInputTextCallbackData_GetBufSize returns value of ImGuiInputTextCallbackData.BufSize
//
// Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
func (self *InputTextCallbackData) BufSize() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetBufSize(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetBufDirty sets value of ImGuiInputTextCallbackData.BufDirty
//
// Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
func (self InputTextCallbackData) SetBufDirty(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetBufDirty(selfArg, C.bool(v))
}

// ImGuiInputTextCallbackData_GetBufDirty returns value of ImGuiInputTextCallbackData.BufDirty
//
// Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
func (self *InputTextCallbackData) BufDirty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextCallbackData_GetBufDirty(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)) == C.bool(true)
}

// ImGuiInputTextCallbackData_SetCursorPos sets value of ImGuiInputTextCallbackData.CursorPos
//
//	// Read-write   // [Completion,History,Always]
func (self InputTextCallbackData) SetCursorPos(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetCursorPos(selfArg, C.int(v))
}

// ImGuiInputTextCallbackData_GetCursorPos returns value of ImGuiInputTextCallbackData.CursorPos
//
//	// Read-write   // [Completion,History,Always]
func (self *InputTextCallbackData) CursorPos() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetCursorPos(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetSelectionStart sets value of ImGuiInputTextCallbackData.SelectionStart
//
//	// Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
func (self InputTextCallbackData) SetSelectionStart(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetSelectionStart(selfArg, C.int(v))
}

// ImGuiInputTextCallbackData_GetSelectionStart returns value of ImGuiInputTextCallbackData.SelectionStart
//
//	// Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
func (self *InputTextCallbackData) SelectionStart() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetSelectionStart(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextCallbackData_SetSelectionEnd sets value of ImGuiInputTextCallbackData.SelectionEnd
//
//	// Read-write   // [Completion,History,Always]
func (self InputTextCallbackData) SetSelectionEnd(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextCallbackData_SetSelectionEnd(selfArg, C.int(v))
}

// ImGuiInputTextCallbackData_GetSelectionEnd returns value of ImGuiInputTextCallbackData.SelectionEnd
//
//	// Read-write   // [Completion,History,Always]
func (self *InputTextCallbackData) SelectionEnd() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextCallbackData_GetSelectionEnd(internal.ReinterpretCast[*C.ImGuiInputTextCallbackData](selfArg)))
}

// ImGuiInputTextDeactivatedState_SetID sets value of ImGuiInputTextDeactivatedState.ID
//
// widget id owning the text state (which just got deactivated)
func (self InputTextDeactivatedState) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextDeactivatedState_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiInputTextDeactivatedState_GetID returns value of ImGuiInputTextDeactivatedState.ID
//
// widget id owning the text state (which just got deactivated)
func (self *InputTextDeactivatedState) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiInputTextDeactivatedState_GetID(internal.ReinterpretCast[*C.ImGuiInputTextDeactivatedState](selfArg))
		return &result
	}())
}

// ImGuiInputTextDeactivatedState_SetTextA sets value of ImGuiInputTextDeactivatedState.TextA
//
// text buffer
func (self InputTextDeactivatedState) SetTextA(v vectors.Vector[int8]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.char, int8](vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextDeactivatedState_SetTextA(selfArg, *vVecArg)
}

// ImGuiInputTextDeactivatedState_GetTextA returns value of ImGuiInputTextDeactivatedState.TextA
//
// text buffer
func (self *InputTextDeactivatedState) TextA() vectors.Vector[int8] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiInputTextDeactivatedState_GetTextA(internal.ReinterpretCast[*C.ImGuiInputTextDeactivatedState](selfArg)).Size, C.wrap_ImGuiInputTextDeactivatedState_GetTextA(internal.ReinterpretCast[*C.ImGuiInputTextDeactivatedState](selfArg)).Capacity, (*int8)(C.wrap_ImGuiInputTextDeactivatedState_GetTextA(internal.ReinterpretCast[*C.ImGuiInputTextDeactivatedState](selfArg)).Data))
}

// ImGuiInputTextState_SetCtx sets value of ImGuiInputTextState.Ctx
//
// parent UI context (needs to be set explicitly by parent).
func (self InputTextState) SetCtx(v *Context) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCtx(selfArg, internal.ReinterpretCast[*C.ImGuiContext](vArg))
}

// ImGuiInputTextState_GetCtx returns value of ImGuiInputTextState.Ctx
//
// parent UI context (needs to be set explicitly by parent).
func (self *InputTextState) Ctx() *Context {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewContextFromC(C.wrap_ImGuiInputTextState_GetCtx(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

// ImGuiInputTextState_SetID sets value of ImGuiInputTextState.ID
//
// widget id owning the text state
func (self InputTextState) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiInputTextState_GetID returns value of ImGuiInputTextState.ID
//
// widget id owning the text state
func (self *InputTextState) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiInputTextState_GetID(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))
		return &result
	}())
}

// ImGuiInputTextState_SetCurLenA sets value of ImGuiInputTextState.CurLenA
//
// UTF-8 length of the string in TextA (in bytes)
func (self InputTextState) SetCurLenA(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCurLenA(selfArg, C.int(v))
}

// ImGuiInputTextState_GetCurLenA returns value of ImGuiInputTextState.CurLenA
//
// UTF-8 length of the string in TextA (in bytes)
func (self *InputTextState) CurLenA() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextState_GetCurLenA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

// ImGuiInputTextState_SetTextA sets value of ImGuiInputTextState.TextA
//
// main UTF8 buffer.
func (self InputTextState) SetTextA(v vectors.Vector[int8]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.char, int8](vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetTextA(selfArg, *vVecArg)
}

// ImGuiInputTextState_GetTextA returns value of ImGuiInputTextState.TextA
//
// main UTF8 buffer.
func (self *InputTextState) TextA() vectors.Vector[int8] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiInputTextState_GetTextA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Size, C.wrap_ImGuiInputTextState_GetTextA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Capacity, (*int8)(C.wrap_ImGuiInputTextState_GetTextA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Data))
}

// ImGuiInputTextState_SetInitialTextA sets value of ImGuiInputTextState.InitialTextA
//
// value to revert to when pressing Escape = backup of end-user buffer at the time of focus (in UTF-8, unaltered)
func (self InputTextState) SetInitialTextA(v vectors.Vector[int8]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.char, int8](vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetInitialTextA(selfArg, *vVecArg)
}

// ImGuiInputTextState_GetInitialTextA returns value of ImGuiInputTextState.InitialTextA
//
// value to revert to when pressing Escape = backup of end-user buffer at the time of focus (in UTF-8, unaltered)
func (self *InputTextState) InitialTextA() vectors.Vector[int8] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiInputTextState_GetInitialTextA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Size, C.wrap_ImGuiInputTextState_GetInitialTextA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Capacity, (*int8)(C.wrap_ImGuiInputTextState_GetInitialTextA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Data))
}

// ImGuiInputTextState_SetCallbackTextBackup sets value of ImGuiInputTextState.CallbackTextBackup
//
// temporary storage for callback to support automatic reconcile of undo-stack
func (self InputTextState) SetCallbackTextBackup(v vectors.Vector[int8]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.char, int8](vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCallbackTextBackup(selfArg, *vVecArg)
}

// ImGuiInputTextState_GetCallbackTextBackup returns value of ImGuiInputTextState.CallbackTextBackup
//
// temporary storage for callback to support automatic reconcile of undo-stack
func (self *InputTextState) CallbackTextBackup() vectors.Vector[int8] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiInputTextState_GetCallbackTextBackup(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Size, C.wrap_ImGuiInputTextState_GetCallbackTextBackup(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Capacity, (*int8)(C.wrap_ImGuiInputTextState_GetCallbackTextBackup(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)).Data))
}

// ImGuiInputTextState_SetBufCapacityA sets value of ImGuiInputTextState.BufCapacityA
//
// end-user buffer capacity
func (self InputTextState) SetBufCapacityA(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetBufCapacityA(selfArg, C.int(v))
}

// ImGuiInputTextState_GetBufCapacityA returns value of ImGuiInputTextState.BufCapacityA
//
// end-user buffer capacity
func (self *InputTextState) BufCapacityA() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextState_GetBufCapacityA(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

// ImGuiInputTextState_SetScroll sets value of ImGuiInputTextState.Scroll
//
// horizontal offset (managed manually) + vertical scrolling (pulled from child window's own Scroll.y)
func (self InputTextState) SetScroll(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetScroll(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiInputTextState_GetScroll returns value of ImGuiInputTextState.Scroll
//
// horizontal offset (managed manually) + vertical scrolling (pulled from child window's own Scroll.y)
func (self *InputTextState) Scroll() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiInputTextState_GetScroll(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiInputTextState_SetCursorAnim sets value of ImGuiInputTextState.CursorAnim
//
// timer for cursor blink, reset on every user action so the cursor reappears immediately
func (self InputTextState) SetCursorAnim(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCursorAnim(selfArg, C.float(v))
}

// ImGuiInputTextState_GetCursorAnim returns value of ImGuiInputTextState.CursorAnim
//
// timer for cursor blink, reset on every user action so the cursor reappears immediately
func (self *InputTextState) CursorAnim() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiInputTextState_GetCursorAnim(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

// ImGuiInputTextState_SetCursorFollow sets value of ImGuiInputTextState.CursorFollow
//
// set when we want scrolling to follow the current cursor position (not always!)
func (self InputTextState) SetCursorFollow(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetCursorFollow(selfArg, C.bool(v))
}

// ImGuiInputTextState_GetCursorFollow returns value of ImGuiInputTextState.CursorFollow
//
// set when we want scrolling to follow the current cursor position (not always!)
func (self *InputTextState) CursorFollow() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetCursorFollow(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)) == C.bool(true)
}

// ImGuiInputTextState_SetSelectedAllMouseLock sets value of ImGuiInputTextState.SelectedAllMouseLock
//
// after a double-click to select all, we ignore further mouse drags to update selection
func (self InputTextState) SetSelectedAllMouseLock(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetSelectedAllMouseLock(selfArg, C.bool(v))
}

// ImGuiInputTextState_GetSelectedAllMouseLock returns value of ImGuiInputTextState.SelectedAllMouseLock
//
// after a double-click to select all, we ignore further mouse drags to update selection
func (self *InputTextState) SelectedAllMouseLock() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetSelectedAllMouseLock(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)) == C.bool(true)
}

// ImGuiInputTextState_SetEdited sets value of ImGuiInputTextState.Edited
//
// edited this frame
func (self InputTextState) SetEdited(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetEdited(selfArg, C.bool(v))
}

// ImGuiInputTextState_GetEdited returns value of ImGuiInputTextState.Edited
//
// edited this frame
func (self *InputTextState) Edited() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetEdited(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)) == C.bool(true)
}

// ImGuiInputTextState_SetFlags sets value of ImGuiInputTextState.Flags
//
// copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.
func (self InputTextState) SetFlags(v InputTextFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetFlags(selfArg, C.ImGuiInputTextFlags(v))
}

// ImGuiInputTextState_GetFlags returns value of ImGuiInputTextState.Flags
//
// copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.
func (self *InputTextState) Flags() InputTextFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputTextFlags(C.wrap_ImGuiInputTextState_GetFlags(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

// ImGuiInputTextState_SetReloadUserBuf sets value of ImGuiInputTextState.ReloadUserBuf
//
// force a reload of user buf so it may be modified externally. may be automatic in future version.
func (self InputTextState) SetReloadUserBuf(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetReloadUserBuf(selfArg, C.bool(v))
}

// ImGuiInputTextState_GetReloadUserBuf returns value of ImGuiInputTextState.ReloadUserBuf
//
// force a reload of user buf so it may be modified externally. may be automatic in future version.
func (self *InputTextState) ReloadUserBuf() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiInputTextState_GetReloadUserBuf(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)) == C.bool(true)
}

// ImGuiInputTextState_SetReloadSelectionStart sets value of ImGuiInputTextState.ReloadSelectionStart
//
// POSITIONS ARE IN IMWCHAR units *NOT* UTF-8 this is why this is not exposed yet.
func (self InputTextState) SetReloadSelectionStart(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetReloadSelectionStart(selfArg, C.int(v))
}

// ImGuiInputTextState_GetReloadSelectionStart returns value of ImGuiInputTextState.ReloadSelectionStart
//
// POSITIONS ARE IN IMWCHAR units *NOT* UTF-8 this is why this is not exposed yet.
func (self *InputTextState) ReloadSelectionStart() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextState_GetReloadSelectionStart(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

// ImGuiInputTextState_SetReloadSelectionEnd sets value of ImGuiInputTextState.ReloadSelectionEnd
func (self InputTextState) SetReloadSelectionEnd(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiInputTextState_SetReloadSelectionEnd(selfArg, C.int(v))
}

// ImGuiInputTextState_GetReloadSelectionEnd returns value of ImGuiInputTextState.ReloadSelectionEnd
func (self *InputTextState) ReloadSelectionEnd() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiInputTextState_GetReloadSelectionEnd(internal.ReinterpretCast[*C.ImGuiInputTextState](selfArg)))
}

// ImGuiKeyData_SetDown sets value of ImGuiKeyData.Down
//
// True for if key is down
func (self KeyData) SetDown(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetDown(selfArg, C.bool(v))
}

// ImGuiKeyData_GetDown returns value of ImGuiKeyData.Down
//
// True for if key is down
func (self *KeyData) Down() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiKeyData_GetDown(internal.ReinterpretCast[*C.ImGuiKeyData](selfArg)) == C.bool(true)
}

// ImGuiKeyData_SetDownDuration sets value of ImGuiKeyData.DownDuration
//
// Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)
func (self KeyData) SetDownDuration(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetDownDuration(selfArg, C.float(v))
}

// ImGuiKeyData_GetDownDuration returns value of ImGuiKeyData.DownDuration
//
// Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)
func (self *KeyData) DownDuration() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiKeyData_GetDownDuration(internal.ReinterpretCast[*C.ImGuiKeyData](selfArg)))
}

// ImGuiKeyData_SetDownDurationPrev sets value of ImGuiKeyData.DownDurationPrev
//
// Last frame duration the key has been down
func (self KeyData) SetDownDurationPrev(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetDownDurationPrev(selfArg, C.float(v))
}

// ImGuiKeyData_GetDownDurationPrev returns value of ImGuiKeyData.DownDurationPrev
//
// Last frame duration the key has been down
func (self *KeyData) DownDurationPrev() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiKeyData_GetDownDurationPrev(internal.ReinterpretCast[*C.ImGuiKeyData](selfArg)))
}

// ImGuiKeyData_SetAnalogValue sets value of ImGuiKeyData.AnalogValue
//
// 0.0f..1.0f for gamepad values
func (self KeyData) SetAnalogValue(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyData_SetAnalogValue(selfArg, C.float(v))
}

// ImGuiKeyData_GetAnalogValue returns value of ImGuiKeyData.AnalogValue
//
// 0.0f..1.0f for gamepad values
func (self *KeyData) AnalogValue() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiKeyData_GetAnalogValue(internal.ReinterpretCast[*C.ImGuiKeyData](selfArg)))
}

// ImGuiKeyOwnerData_SetOwnerCurr sets value of ImGuiKeyOwnerData.OwnerCurr
func (self KeyOwnerData) SetOwnerCurr(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetOwnerCurr(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiKeyOwnerData_GetOwnerCurr returns value of ImGuiKeyOwnerData.OwnerCurr
func (self *KeyOwnerData) OwnerCurr() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiKeyOwnerData_GetOwnerCurr(internal.ReinterpretCast[*C.ImGuiKeyOwnerData](selfArg))
		return &result
	}())
}

// ImGuiKeyOwnerData_SetOwnerNext sets value of ImGuiKeyOwnerData.OwnerNext
func (self KeyOwnerData) SetOwnerNext(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetOwnerNext(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiKeyOwnerData_GetOwnerNext returns value of ImGuiKeyOwnerData.OwnerNext
func (self *KeyOwnerData) OwnerNext() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiKeyOwnerData_GetOwnerNext(internal.ReinterpretCast[*C.ImGuiKeyOwnerData](selfArg))
		return &result
	}())
}

// ImGuiKeyOwnerData_SetLockThisFrame sets value of ImGuiKeyOwnerData.LockThisFrame
//
// Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
func (self KeyOwnerData) SetLockThisFrame(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetLockThisFrame(selfArg, C.bool(v))
}

// ImGuiKeyOwnerData_GetLockThisFrame returns value of ImGuiKeyOwnerData.LockThisFrame
//
// Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
func (self *KeyOwnerData) LockThisFrame() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiKeyOwnerData_GetLockThisFrame(internal.ReinterpretCast[*C.ImGuiKeyOwnerData](selfArg)) == C.bool(true)
}

// ImGuiKeyOwnerData_SetLockUntilRelease sets value of ImGuiKeyOwnerData.LockUntilRelease
//
// Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.
func (self KeyOwnerData) SetLockUntilRelease(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyOwnerData_SetLockUntilRelease(selfArg, C.bool(v))
}

// ImGuiKeyOwnerData_GetLockUntilRelease returns value of ImGuiKeyOwnerData.LockUntilRelease
//
// Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.
func (self *KeyOwnerData) LockUntilRelease() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiKeyOwnerData_GetLockUntilRelease(internal.ReinterpretCast[*C.ImGuiKeyOwnerData](selfArg)) == C.bool(true)
}

// ImGuiKeyRoutingData_SetNextEntryIndex sets value of ImGuiKeyRoutingData.NextEntryIndex
func (self KeyRoutingData) SetNextEntryIndex(v KeyRoutingIndex) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetNextEntryIndex(selfArg, internal.ReinterpretCast[C.ImGuiKeyRoutingIndex](vArg))
}

// ImGuiKeyRoutingData_GetNextEntryIndex returns value of ImGuiKeyRoutingData.NextEntryIndex
func (self *KeyRoutingData) NextEntryIndex() KeyRoutingIndex {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyRoutingIndexFromC(func() *C.ImGuiKeyRoutingIndex {
		result := C.wrap_ImGuiKeyRoutingData_GetNextEntryIndex(internal.ReinterpretCast[*C.ImGuiKeyRoutingData](selfArg))
		return &result
	}())
}

// ImGuiKeyRoutingData_SetMods sets value of ImGuiKeyRoutingData.Mods
//
// Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits.
func (self KeyRoutingData) SetMods(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetMods(selfArg, C.ImU16(v))
}

// ImGuiKeyRoutingData_GetMods returns value of ImGuiKeyRoutingData.Mods
//
// Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits.
func (self *KeyRoutingData) Mods() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiKeyRoutingData_GetMods(internal.ReinterpretCast[*C.ImGuiKeyRoutingData](selfArg)))
}

// ImGuiKeyRoutingData_SetRoutingCurrScore sets value of ImGuiKeyRoutingData.RoutingCurrScore
//
// [DEBUG] For debug display
func (self KeyRoutingData) SetRoutingCurrScore(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetRoutingCurrScore(selfArg, C.ImU8(v))
}

// ImGuiKeyRoutingData_GetRoutingCurrScore returns value of ImGuiKeyRoutingData.RoutingCurrScore
//
// [DEBUG] For debug display
func (self *KeyRoutingData) RoutingCurrScore() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiKeyRoutingData_GetRoutingCurrScore(internal.ReinterpretCast[*C.ImGuiKeyRoutingData](selfArg)))
}

// ImGuiKeyRoutingData_SetRoutingNextScore sets value of ImGuiKeyRoutingData.RoutingNextScore
//
// Lower is better (0: perfect score)
func (self KeyRoutingData) SetRoutingNextScore(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetRoutingNextScore(selfArg, C.ImU8(v))
}

// ImGuiKeyRoutingData_GetRoutingNextScore returns value of ImGuiKeyRoutingData.RoutingNextScore
//
// Lower is better (0: perfect score)
func (self *KeyRoutingData) RoutingNextScore() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiKeyRoutingData_GetRoutingNextScore(internal.ReinterpretCast[*C.ImGuiKeyRoutingData](selfArg)))
}

// ImGuiKeyRoutingData_SetRoutingCurr sets value of ImGuiKeyRoutingData.RoutingCurr
func (self KeyRoutingData) SetRoutingCurr(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetRoutingCurr(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiKeyRoutingData_GetRoutingCurr returns value of ImGuiKeyRoutingData.RoutingCurr
func (self *KeyRoutingData) RoutingCurr() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiKeyRoutingData_GetRoutingCurr(internal.ReinterpretCast[*C.ImGuiKeyRoutingData](selfArg))
		return &result
	}())
}

// ImGuiKeyRoutingData_SetRoutingNext sets value of ImGuiKeyRoutingData.RoutingNext
func (self KeyRoutingData) SetRoutingNext(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingData_SetRoutingNext(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiKeyRoutingData_GetRoutingNext returns value of ImGuiKeyRoutingData.RoutingNext
func (self *KeyRoutingData) RoutingNext() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiKeyRoutingData_GetRoutingNext(internal.ReinterpretCast[*C.ImGuiKeyRoutingData](selfArg))
		return &result
	}())
}

// ImGuiKeyRoutingTable_SetIndex sets value of ImGuiKeyRoutingTable.Index[ImGuiKey_NamedKey_COUNT]
//
// Index of first entry in Entries[]
func (self KeyRoutingTable) SetIndex(v *[154]KeyRoutingIndex) {
	vArg := make([]C.ImGuiKeyRoutingIndex, len(v))
	for i, vV := range v {
		vVArg, _ := vV.C()
		vArg[i] = internal.ReinterpretCast[C.ImGuiKeyRoutingIndex](vVArg)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingTable_SetIndex(selfArg, (*C.ImGuiKeyRoutingIndex)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = *NewKeyRoutingIndexFromC(func() *C.ImGuiKeyRoutingIndex { result := vV; return &result }())
	}
}

// ImGuiKeyRoutingTable_GetIndex returns value of ImGuiKeyRoutingTable.Index[ImGuiKey_NamedKey_COUNT]
//
// Index of first entry in Entries[]
func (self *KeyRoutingTable) Index() [154]KeyRoutingIndex {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [154]KeyRoutingIndex {
		result := [154]KeyRoutingIndex{}
		resultMirr := C.wrap_ImGuiKeyRoutingTable_GetIndex(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg))
		for i := range result {
			result[i] = *NewKeyRoutingIndexFromC(func() *C.ImGuiKeyRoutingIndex {
				result := C.cimgui_ImGuiKeyRoutingIndex_GetAtIdx(resultMirr, C.int(i))
				return &result
			}())
		}

		return result
	}()
}

// ImGuiKeyRoutingTable_SetEntries sets value of ImGuiKeyRoutingTable.Entries
func (self KeyRoutingTable) SetEntries(v vectors.Vector[KeyRoutingData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiKeyRoutingData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiKeyRoutingData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingTable_SetEntries(selfArg, *vVecArg)
}

// ImGuiKeyRoutingTable_GetEntries returns value of ImGuiKeyRoutingTable.Entries
func (self *KeyRoutingTable) Entries() vectors.Vector[KeyRoutingData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiKeyRoutingTable_GetEntries(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg)).Size, C.wrap_ImGuiKeyRoutingTable_GetEntries(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg)).Capacity, NewKeyRoutingDataFromC(C.wrap_ImGuiKeyRoutingTable_GetEntries(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg)).Data))
}

// ImGuiKeyRoutingTable_SetEntriesNext sets value of ImGuiKeyRoutingTable.EntriesNext
//
// Double-buffer to avoid reallocation (could use a shared buffer)
func (self KeyRoutingTable) SetEntriesNext(v vectors.Vector[KeyRoutingData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiKeyRoutingData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiKeyRoutingData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiKeyRoutingTable_SetEntriesNext(selfArg, *vVecArg)
}

// ImGuiKeyRoutingTable_GetEntriesNext returns value of ImGuiKeyRoutingTable.EntriesNext
//
// Double-buffer to avoid reallocation (could use a shared buffer)
func (self *KeyRoutingTable) EntriesNext() vectors.Vector[KeyRoutingData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiKeyRoutingTable_GetEntriesNext(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg)).Size, C.wrap_ImGuiKeyRoutingTable_GetEntriesNext(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg)).Capacity, NewKeyRoutingDataFromC(C.wrap_ImGuiKeyRoutingTable_GetEntriesNext(internal.ReinterpretCast[*C.ImGuiKeyRoutingTable](selfArg)).Data))
}

// ImGuiLastItemData_SetID sets value of ImGuiLastItemData.ID
func (self LastItemData) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiLastItemData_GetID returns value of ImGuiLastItemData.ID
func (self *LastItemData) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiLastItemData_GetID(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg))
		return &result
	}())
}

// ImGuiLastItemData_SetItemFlags sets value of ImGuiLastItemData.ItemFlags
//
// See ImGuiItemFlags_
func (self LastItemData) SetItemFlags(v ItemFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetItemFlags(selfArg, C.ImGuiItemFlags(v))
}

// ImGuiLastItemData_GetItemFlags returns value of ImGuiLastItemData.ItemFlags
//
// See ImGuiItemFlags_
func (self *LastItemData) ItemFlags() ItemFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiLastItemData_GetItemFlags(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg)))
}

// ImGuiLastItemData_SetStatusFlags sets value of ImGuiLastItemData.StatusFlags
//
// See ImGuiItemStatusFlags_
func (self LastItemData) SetStatusFlags(v ItemStatusFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetStatusFlags(selfArg, C.ImGuiItemStatusFlags(v))
}

// ImGuiLastItemData_GetStatusFlags returns value of ImGuiLastItemData.StatusFlags
//
// See ImGuiItemStatusFlags_
func (self *LastItemData) StatusFlags() ItemStatusFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ItemStatusFlags(C.wrap_ImGuiLastItemData_GetStatusFlags(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg)))
}

// ImGuiLastItemData_SetRect sets value of ImGuiLastItemData.Rect
//
// Full rectangle
func (self LastItemData) SetRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiLastItemData_GetRect returns value of ImGuiLastItemData.Rect
//
// Full rectangle
func (self *LastItemData) Rect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiLastItemData_GetRect(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiLastItemData_SetNavRect sets value of ImGuiLastItemData.NavRect
//
// Navigation scoring rectangle (not displayed)
func (self LastItemData) SetNavRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetNavRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiLastItemData_GetNavRect returns value of ImGuiLastItemData.NavRect
//
// Navigation scoring rectangle (not displayed)
func (self *LastItemData) NavRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiLastItemData_GetNavRect(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiLastItemData_SetDisplayRect sets value of ImGuiLastItemData.DisplayRect
//
//	// Rarely used fields are not explicitly cleared, only valid when the corresponding ImGuiItemStatusFlags ar set.
//
// Display rectangle. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) is set.
func (self LastItemData) SetDisplayRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetDisplayRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiLastItemData_GetDisplayRect returns value of ImGuiLastItemData.DisplayRect
//
//	// Rarely used fields are not explicitly cleared, only valid when the corresponding ImGuiItemStatusFlags ar set.
//
// Display rectangle. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) is set.
func (self *LastItemData) DisplayRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiLastItemData_GetDisplayRect(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiLastItemData_SetClipRect sets value of ImGuiLastItemData.ClipRect
//
// Clip rectangle at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasClipRect) is set..
func (self LastItemData) SetClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiLastItemData_GetClipRect returns value of ImGuiLastItemData.ClipRect
//
// Clip rectangle at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasClipRect) is set..
func (self *LastItemData) ClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiLastItemData_GetClipRect(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiLastItemData_SetShortcut sets value of ImGuiLastItemData.Shortcut
//
// Shortcut at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasShortcut) is set..
func (self LastItemData) SetShortcut(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLastItemData_SetShortcut(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiLastItemData_GetShortcut returns value of ImGuiLastItemData.Shortcut
//
// Shortcut at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasShortcut) is set..
func (self *LastItemData) Shortcut() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiLastItemData_GetShortcut(internal.ReinterpretCast[*C.ImGuiLastItemData](selfArg))
		return &result
	}())
}

// ImGuiListClipper_SetCtx sets value of ImGuiListClipper.Ctx
//
// Parent UI context
func (self ListClipper) SetCtx(v *Context) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetCtx(selfArg, internal.ReinterpretCast[*C.ImGuiContext](vArg))
}

// ImGuiListClipper_GetCtx returns value of ImGuiListClipper.Ctx
//
// Parent UI context
func (self *ListClipper) Ctx() *Context {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewContextFromC(C.wrap_ImGuiListClipper_GetCtx(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipper_SetDisplayStart sets value of ImGuiListClipper.DisplayStart
//
// First item to display, updated by each call to Step()
func (self ListClipper) SetDisplayStart(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetDisplayStart(selfArg, C.int(v))
}

// ImGuiListClipper_GetDisplayStart returns value of ImGuiListClipper.DisplayStart
//
// First item to display, updated by each call to Step()
func (self *ListClipper) DisplayStart() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipper_GetDisplayStart(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipper_SetDisplayEnd sets value of ImGuiListClipper.DisplayEnd
//
// End of items to display (exclusive)
func (self ListClipper) SetDisplayEnd(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetDisplayEnd(selfArg, C.int(v))
}

// ImGuiListClipper_GetDisplayEnd returns value of ImGuiListClipper.DisplayEnd
//
// End of items to display (exclusive)
func (self *ListClipper) DisplayEnd() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipper_GetDisplayEnd(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipper_SetItemsCount sets value of ImGuiListClipper.ItemsCount
//
// [Internal] Number of items
func (self ListClipper) SetItemsCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetItemsCount(selfArg, C.int(v))
}

// ImGuiListClipper_GetItemsCount returns value of ImGuiListClipper.ItemsCount
//
// [Internal] Number of items
func (self *ListClipper) ItemsCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipper_GetItemsCount(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipper_SetItemsHeight sets value of ImGuiListClipper.ItemsHeight
//
// [Internal] Height of item after a first step and item submission can calculate it
func (self ListClipper) SetItemsHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetItemsHeight(selfArg, C.float(v))
}

// ImGuiListClipper_GetItemsHeight returns value of ImGuiListClipper.ItemsHeight
//
// [Internal] Height of item after a first step and item submission can calculate it
func (self *ListClipper) ItemsHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiListClipper_GetItemsHeight(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipper_SetStartPosY sets value of ImGuiListClipper.StartPosY
//
// [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
func (self ListClipper) SetStartPosY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetStartPosY(selfArg, C.float(v))
}

// ImGuiListClipper_GetStartPosY returns value of ImGuiListClipper.StartPosY
//
// [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
func (self *ListClipper) StartPosY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiListClipper_GetStartPosY(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipper_SetStartSeekOffsetY sets value of ImGuiListClipper.StartSeekOffsetY
//
// [Internal] Account for frozen rows in a table and initial loss of precision in very large windows.
func (self ListClipper) SetStartSeekOffsetY(v float64) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetStartSeekOffsetY(selfArg, C.double(v))
}

// ImGuiListClipper_GetStartSeekOffsetY returns value of ImGuiListClipper.StartSeekOffsetY
//
// [Internal] Account for frozen rows in a table and initial loss of precision in very large windows.
func (self *ListClipper) StartSeekOffsetY() float64 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float64(C.wrap_ImGuiListClipper_GetStartSeekOffsetY(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipper_SetTempData sets value of ImGuiListClipper.TempData
//
// [Internal] Internal data
func (self ListClipper) SetTempData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipper_SetTempData(selfArg, C.uintptr_t(v))
}

// ImGuiListClipper_GetTempData returns value of ImGuiListClipper.TempData
//
// [Internal] Internal data
func (self *ListClipper) TempData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiListClipper_GetTempData(internal.ReinterpretCast[*C.ImGuiListClipper](selfArg)))
}

// ImGuiListClipperData_SetListClipper sets value of ImGuiListClipperData.ListClipper
func (self ListClipperData) SetListClipper(v *ListClipper) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetListClipper(selfArg, internal.ReinterpretCast[*C.ImGuiListClipper](vArg))
}

// ImGuiListClipperData_GetListClipper returns value of ImGuiListClipperData.ListClipper
func (self *ListClipperData) ListClipper() *ListClipper {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewListClipperFromC(C.wrap_ImGuiListClipperData_GetListClipper(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg)))
}

// ImGuiListClipperData_SetLossynessOffset sets value of ImGuiListClipperData.LossynessOffset
func (self ListClipperData) SetLossynessOffset(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetLossynessOffset(selfArg, C.float(v))
}

// ImGuiListClipperData_GetLossynessOffset returns value of ImGuiListClipperData.LossynessOffset
func (self *ListClipperData) LossynessOffset() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiListClipperData_GetLossynessOffset(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg)))
}

// ImGuiListClipperData_SetStepNo sets value of ImGuiListClipperData.StepNo
func (self ListClipperData) SetStepNo(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetStepNo(selfArg, C.int(v))
}

// ImGuiListClipperData_GetStepNo returns value of ImGuiListClipperData.StepNo
func (self *ListClipperData) StepNo() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperData_GetStepNo(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg)))
}

// ImGuiListClipperData_SetItemsFrozen sets value of ImGuiListClipperData.ItemsFrozen
func (self ListClipperData) SetItemsFrozen(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetItemsFrozen(selfArg, C.int(v))
}

// ImGuiListClipperData_GetItemsFrozen returns value of ImGuiListClipperData.ItemsFrozen
func (self *ListClipperData) ItemsFrozen() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperData_GetItemsFrozen(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg)))
}

// ImGuiListClipperData_SetRanges sets value of ImGuiListClipperData.Ranges
func (self ListClipperData) SetRanges(v vectors.Vector[ListClipperRange]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiListClipperRange)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiListClipperRange](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperData_SetRanges(selfArg, *vVecArg)
}

// ImGuiListClipperData_GetRanges returns value of ImGuiListClipperData.Ranges
func (self *ListClipperData) Ranges() vectors.Vector[ListClipperRange] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiListClipperData_GetRanges(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg)).Size, C.wrap_ImGuiListClipperData_GetRanges(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg)).Capacity, NewListClipperRangeFromC(C.wrap_ImGuiListClipperData_GetRanges(internal.ReinterpretCast[*C.ImGuiListClipperData](selfArg)).Data))
}

// ImGuiListClipperRange_SetMin sets value of ImGuiListClipperRange.Min
func (self ListClipperRange) SetMin(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetMin(selfArg, C.int(v))
}

// ImGuiListClipperRange_GetMin returns value of ImGuiListClipperRange.Min
func (self *ListClipperRange) Min() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperRange_GetMin(internal.ReinterpretCast[*C.ImGuiListClipperRange](selfArg)))
}

// ImGuiListClipperRange_SetMax sets value of ImGuiListClipperRange.Max
func (self ListClipperRange) SetMax(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetMax(selfArg, C.int(v))
}

// ImGuiListClipperRange_GetMax returns value of ImGuiListClipperRange.Max
func (self *ListClipperRange) Max() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiListClipperRange_GetMax(internal.ReinterpretCast[*C.ImGuiListClipperRange](selfArg)))
}

// ImGuiListClipperRange_SetPosToIndexConvert sets value of ImGuiListClipperRange.PosToIndexConvert
//
// Begin/End are absolute position (will be converted to indices later)
func (self ListClipperRange) SetPosToIndexConvert(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetPosToIndexConvert(selfArg, C.bool(v))
}

// ImGuiListClipperRange_GetPosToIndexConvert returns value of ImGuiListClipperRange.PosToIndexConvert
//
// Begin/End are absolute position (will be converted to indices later)
func (self *ListClipperRange) PosToIndexConvert() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiListClipperRange_GetPosToIndexConvert(internal.ReinterpretCast[*C.ImGuiListClipperRange](selfArg)) == C.bool(true)
}

// ImGuiListClipperRange_SetPosToIndexOffsetMin sets value of ImGuiListClipperRange.PosToIndexOffsetMin
//
// Add to Min after converting to indices
func (self ListClipperRange) SetPosToIndexOffsetMin(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetPosToIndexOffsetMin(selfArg, C.ImS8(v))
}

// ImGuiListClipperRange_GetPosToIndexOffsetMin returns value of ImGuiListClipperRange.PosToIndexOffsetMin
//
// Add to Min after converting to indices
func (self *ListClipperRange) PosToIndexOffsetMin() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiListClipperRange_GetPosToIndexOffsetMin(internal.ReinterpretCast[*C.ImGuiListClipperRange](selfArg)))
}

// ImGuiListClipperRange_SetPosToIndexOffsetMax sets value of ImGuiListClipperRange.PosToIndexOffsetMax
//
// Add to Min after converting to indices
func (self ListClipperRange) SetPosToIndexOffsetMax(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiListClipperRange_SetPosToIndexOffsetMax(selfArg, C.ImS8(v))
}

// ImGuiListClipperRange_GetPosToIndexOffsetMax returns value of ImGuiListClipperRange.PosToIndexOffsetMax
//
// Add to Min after converting to indices
func (self *ListClipperRange) PosToIndexOffsetMax() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiListClipperRange_GetPosToIndexOffsetMax(internal.ReinterpretCast[*C.ImGuiListClipperRange](selfArg)))
}

// ImGuiLocEntry_SetKey sets value of ImGuiLocEntry.Key
func (self LocEntry) SetKey(v LocKey) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLocEntry_SetKey(selfArg, C.ImGuiLocKey(v))
}

// ImGuiLocEntry_GetKey returns value of ImGuiLocEntry.Key
func (self *LocEntry) Key() LocKey {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return LocKey(C.wrap_ImGuiLocEntry_GetKey(internal.ReinterpretCast[*C.ImGuiLocEntry](selfArg)))
}

// ImGuiLocEntry_SetText sets value of ImGuiLocEntry.Text
func (self LocEntry) SetText(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiLocEntry_SetText(selfArg, vArg)
}

// ImGuiLocEntry_GetText returns value of ImGuiLocEntry.Text
func (self *LocEntry) Text() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiLocEntry_GetText(internal.ReinterpretCast[*C.ImGuiLocEntry](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiMenuColumns_SetTotalWidth sets value of ImGuiMenuColumns.TotalWidth
func (self MenuColumns) SetTotalWidth(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetTotalWidth(selfArg, C.ImU32(v))
}

// ImGuiMenuColumns_GetTotalWidth returns value of ImGuiMenuColumns.TotalWidth
func (self *MenuColumns) TotalWidth() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiMenuColumns_GetTotalWidth(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg)))
}

// ImGuiMenuColumns_SetNextTotalWidth sets value of ImGuiMenuColumns.NextTotalWidth
func (self MenuColumns) SetNextTotalWidth(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetNextTotalWidth(selfArg, C.ImU32(v))
}

// ImGuiMenuColumns_GetNextTotalWidth returns value of ImGuiMenuColumns.NextTotalWidth
func (self *MenuColumns) NextTotalWidth() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiMenuColumns_GetNextTotalWidth(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg)))
}

// ImGuiMenuColumns_SetSpacing sets value of ImGuiMenuColumns.Spacing
func (self MenuColumns) SetSpacing(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetSpacing(selfArg, C.ImU16(v))
}

// ImGuiMenuColumns_GetSpacing returns value of ImGuiMenuColumns.Spacing
func (self *MenuColumns) Spacing() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetSpacing(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg)))
}

// ImGuiMenuColumns_SetOffsetIcon sets value of ImGuiMenuColumns.OffsetIcon
//
// Always zero for now
func (self MenuColumns) SetOffsetIcon(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetIcon(selfArg, C.ImU16(v))
}

// ImGuiMenuColumns_GetOffsetIcon returns value of ImGuiMenuColumns.OffsetIcon
//
// Always zero for now
func (self *MenuColumns) OffsetIcon() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetIcon(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg)))
}

// ImGuiMenuColumns_SetOffsetLabel sets value of ImGuiMenuColumns.OffsetLabel
//
// Offsets are locked in Update()
func (self MenuColumns) SetOffsetLabel(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetLabel(selfArg, C.ImU16(v))
}

// ImGuiMenuColumns_GetOffsetLabel returns value of ImGuiMenuColumns.OffsetLabel
//
// Offsets are locked in Update()
func (self *MenuColumns) OffsetLabel() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetLabel(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg)))
}

// ImGuiMenuColumns_SetOffsetShortcut sets value of ImGuiMenuColumns.OffsetShortcut
func (self MenuColumns) SetOffsetShortcut(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetShortcut(selfArg, C.ImU16(v))
}

// ImGuiMenuColumns_GetOffsetShortcut returns value of ImGuiMenuColumns.OffsetShortcut
func (self *MenuColumns) OffsetShortcut() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetShortcut(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg)))
}

// ImGuiMenuColumns_SetOffsetMark sets value of ImGuiMenuColumns.OffsetMark
func (self MenuColumns) SetOffsetMark(v uint16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetOffsetMark(selfArg, C.ImU16(v))
}

// ImGuiMenuColumns_GetOffsetMark returns value of ImGuiMenuColumns.OffsetMark
func (self *MenuColumns) OffsetMark() uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint16(C.wrap_ImGuiMenuColumns_GetOffsetMark(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg)))
}

// ImGuiMenuColumns_SetWidths sets value of ImGuiMenuColumns.Widths[4]
//
// Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)
func (self MenuColumns) SetWidths(v *[4]uint16) {
	vArg := make([]C.ImU16, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU16(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMenuColumns_SetWidths(selfArg, (*C.ImU16)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = uint16(vV)
	}
}

// ImGuiMenuColumns_GetWidths returns value of ImGuiMenuColumns.Widths[4]
//
// Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)
func (self *MenuColumns) Widths() [4]uint16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [4]uint16 {
		result := [4]uint16{}
		resultMirr := C.wrap_ImGuiMenuColumns_GetWidths(internal.ReinterpretCast[*C.ImGuiMenuColumns](selfArg))
		for i := range result {
			result[i] = uint16(C.cimgui_ImU16_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiMetricsConfig_SetShowDebugLog sets value of ImGuiMetricsConfig.ShowDebugLog
func (self MetricsConfig) SetShowDebugLog(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDebugLog(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowDebugLog returns value of ImGuiMetricsConfig.ShowDebugLog
func (self *MetricsConfig) ShowDebugLog() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDebugLog(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowIDStackTool sets value of ImGuiMetricsConfig.ShowIDStackTool
func (self MetricsConfig) SetShowIDStackTool(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowIDStackTool(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowIDStackTool returns value of ImGuiMetricsConfig.ShowIDStackTool
func (self *MetricsConfig) ShowIDStackTool() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowIDStackTool(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowWindowsRects sets value of ImGuiMetricsConfig.ShowWindowsRects
func (self MetricsConfig) SetShowWindowsRects(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowWindowsRects(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowWindowsRects returns value of ImGuiMetricsConfig.ShowWindowsRects
func (self *MetricsConfig) ShowWindowsRects() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowWindowsRects(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowWindowsBeginOrder sets value of ImGuiMetricsConfig.ShowWindowsBeginOrder
func (self MetricsConfig) SetShowWindowsBeginOrder(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowWindowsBeginOrder(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowWindowsBeginOrder returns value of ImGuiMetricsConfig.ShowWindowsBeginOrder
func (self *MetricsConfig) ShowWindowsBeginOrder() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowWindowsBeginOrder(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowTablesRects sets value of ImGuiMetricsConfig.ShowTablesRects
func (self MetricsConfig) SetShowTablesRects(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowTablesRects(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowTablesRects returns value of ImGuiMetricsConfig.ShowTablesRects
func (self *MetricsConfig) ShowTablesRects() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowTablesRects(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowDrawCmdMesh sets value of ImGuiMetricsConfig.ShowDrawCmdMesh
func (self MetricsConfig) SetShowDrawCmdMesh(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDrawCmdMesh(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowDrawCmdMesh returns value of ImGuiMetricsConfig.ShowDrawCmdMesh
func (self *MetricsConfig) ShowDrawCmdMesh() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDrawCmdMesh(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowDrawCmdBoundingBoxes sets value of ImGuiMetricsConfig.ShowDrawCmdBoundingBoxes
func (self MetricsConfig) SetShowDrawCmdBoundingBoxes(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDrawCmdBoundingBoxes(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowDrawCmdBoundingBoxes returns value of ImGuiMetricsConfig.ShowDrawCmdBoundingBoxes
func (self *MetricsConfig) ShowDrawCmdBoundingBoxes() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDrawCmdBoundingBoxes(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowTextEncodingViewer sets value of ImGuiMetricsConfig.ShowTextEncodingViewer
func (self MetricsConfig) SetShowTextEncodingViewer(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowTextEncodingViewer(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowTextEncodingViewer returns value of ImGuiMetricsConfig.ShowTextEncodingViewer
func (self *MetricsConfig) ShowTextEncodingViewer() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowTextEncodingViewer(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowAtlasTintedWithTextColor sets value of ImGuiMetricsConfig.ShowAtlasTintedWithTextColor
func (self MetricsConfig) SetShowAtlasTintedWithTextColor(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowAtlasTintedWithTextColor(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowAtlasTintedWithTextColor returns value of ImGuiMetricsConfig.ShowAtlasTintedWithTextColor
func (self *MetricsConfig) ShowAtlasTintedWithTextColor() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowAtlasTintedWithTextColor(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowDockingNodes sets value of ImGuiMetricsConfig.ShowDockingNodes
func (self MetricsConfig) SetShowDockingNodes(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowDockingNodes(selfArg, C.bool(v))
}

// ImGuiMetricsConfig_GetShowDockingNodes returns value of ImGuiMetricsConfig.ShowDockingNodes
func (self *MetricsConfig) ShowDockingNodes() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMetricsConfig_GetShowDockingNodes(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)) == C.bool(true)
}

// ImGuiMetricsConfig_SetShowWindowsRectsType sets value of ImGuiMetricsConfig.ShowWindowsRectsType
func (self MetricsConfig) SetShowWindowsRectsType(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowWindowsRectsType(selfArg, C.int(v))
}

// ImGuiMetricsConfig_GetShowWindowsRectsType returns value of ImGuiMetricsConfig.ShowWindowsRectsType
func (self *MetricsConfig) ShowWindowsRectsType() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMetricsConfig_GetShowWindowsRectsType(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)))
}

// ImGuiMetricsConfig_SetShowTablesRectsType sets value of ImGuiMetricsConfig.ShowTablesRectsType
func (self MetricsConfig) SetShowTablesRectsType(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetShowTablesRectsType(selfArg, C.int(v))
}

// ImGuiMetricsConfig_GetShowTablesRectsType returns value of ImGuiMetricsConfig.ShowTablesRectsType
func (self *MetricsConfig) ShowTablesRectsType() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMetricsConfig_GetShowTablesRectsType(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)))
}

// ImGuiMetricsConfig_SetHighlightMonitorIdx sets value of ImGuiMetricsConfig.HighlightMonitorIdx
func (self MetricsConfig) SetHighlightMonitorIdx(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetHighlightMonitorIdx(selfArg, C.int(v))
}

// ImGuiMetricsConfig_GetHighlightMonitorIdx returns value of ImGuiMetricsConfig.HighlightMonitorIdx
func (self *MetricsConfig) HighlightMonitorIdx() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMetricsConfig_GetHighlightMonitorIdx(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg)))
}

// ImGuiMetricsConfig_SetHighlightViewportID sets value of ImGuiMetricsConfig.HighlightViewportID
func (self MetricsConfig) SetHighlightViewportID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMetricsConfig_SetHighlightViewportID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiMetricsConfig_GetHighlightViewportID returns value of ImGuiMetricsConfig.HighlightViewportID
func (self *MetricsConfig) HighlightViewportID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiMetricsConfig_GetHighlightViewportID(internal.ReinterpretCast[*C.ImGuiMetricsConfig](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectIO_SetRequests sets value of ImGuiMultiSelectIO.Requests
//
//	   //------------------------------------------// BeginMultiSelect / EndMultiSelect
//	ms:w, app:r     /  ms:w  app:r   // Requests to apply to your selection data.
func (self MultiSelectIO) SetRequests(v vectors.Vector[SelectionRequest]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiSelectionRequest)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiSelectionRequest](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectIO_SetRequests(selfArg, *vVecArg)
}

// ImGuiMultiSelectIO_GetRequests returns value of ImGuiMultiSelectIO.Requests
//
//	   //------------------------------------------// BeginMultiSelect / EndMultiSelect
//	ms:w, app:r     /  ms:w  app:r   // Requests to apply to your selection data.
func (self *MultiSelectIO) Requests() vectors.Vector[SelectionRequest] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiMultiSelectIO_GetRequests(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg)).Size, C.wrap_ImGuiMultiSelectIO_GetRequests(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg)).Capacity, NewSelectionRequestFromC(C.wrap_ImGuiMultiSelectIO_GetRequests(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg)).Data))
}

// ImGuiMultiSelectIO_SetRangeSrcItem sets value of ImGuiMultiSelectIO.RangeSrcItem
//
//	ms:w  app:r     /                // (If using clipper) Begin: Source item (often the first selected item) must never be clipped: use clipper.IncludeItemByIndex() to ensure it is submitted.
func (self MultiSelectIO) SetRangeSrcItem(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectIO_SetRangeSrcItem(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiMultiSelectIO_GetRangeSrcItem returns value of ImGuiMultiSelectIO.RangeSrcItem
//
//	ms:w  app:r     /                // (If using clipper) Begin: Source item (often the first selected item) must never be clipped: use clipper.IncludeItemByIndex() to ensure it is submitted.
func (self *MultiSelectIO) RangeSrcItem() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiMultiSelectIO_GetRangeSrcItem(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectIO_SetNavIdItem sets value of ImGuiMultiSelectIO.NavIdItem
//
//	ms:w, app:r     /                // (If using deletion) Last known SetNextItemSelectionUserData() value for NavId (if part of submitted items).
func (self MultiSelectIO) SetNavIdItem(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectIO_SetNavIdItem(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiMultiSelectIO_GetNavIdItem returns value of ImGuiMultiSelectIO.NavIdItem
//
//	ms:w, app:r     /                // (If using deletion) Last known SetNextItemSelectionUserData() value for NavId (if part of submitted items).
func (self *MultiSelectIO) NavIdItem() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiMultiSelectIO_GetNavIdItem(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectIO_SetNavIdSelected sets value of ImGuiMultiSelectIO.NavIdSelected
//
//	ms:w, app:r     /        app:r   // (If using deletion) Last known selection state for NavId (if part of submitted items).
func (self MultiSelectIO) SetNavIdSelected(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectIO_SetNavIdSelected(selfArg, C.bool(v))
}

// ImGuiMultiSelectIO_GetNavIdSelected returns value of ImGuiMultiSelectIO.NavIdSelected
//
//	ms:w, app:r     /        app:r   // (If using deletion) Last known selection state for NavId (if part of submitted items).
func (self *MultiSelectIO) NavIdSelected() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectIO_GetNavIdSelected(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg)) == C.bool(true)
}

// ImGuiMultiSelectIO_SetRangeSrcReset sets value of ImGuiMultiSelectIO.RangeSrcReset
//
//	app:w     /  ms:r          // (If using deletion) Set before EndMultiSelect() to reset ResetSrcItem (e.g. if deleted selection).
func (self MultiSelectIO) SetRangeSrcReset(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectIO_SetRangeSrcReset(selfArg, C.bool(v))
}

// ImGuiMultiSelectIO_GetRangeSrcReset returns value of ImGuiMultiSelectIO.RangeSrcReset
//
//	app:w     /  ms:r          // (If using deletion) Set before EndMultiSelect() to reset ResetSrcItem (e.g. if deleted selection).
func (self *MultiSelectIO) RangeSrcReset() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectIO_GetRangeSrcReset(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg)) == C.bool(true)
}

// ImGuiMultiSelectIO_SetItemsCount sets value of ImGuiMultiSelectIO.ItemsCount
//
//	ms:w, app:r     /        app:r   // 'int items_count' parameter to BeginMultiSelect() is copied here for convenience, allowing simpler calls to your ApplyRequests handler. Not used internally.
func (self MultiSelectIO) SetItemsCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectIO_SetItemsCount(selfArg, C.int(v))
}

// ImGuiMultiSelectIO_GetItemsCount returns value of ImGuiMultiSelectIO.ItemsCount
//
//	ms:w, app:r     /        app:r   // 'int items_count' parameter to BeginMultiSelect() is copied here for convenience, allowing simpler calls to your ApplyRequests handler. Not used internally.
func (self *MultiSelectIO) ItemsCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMultiSelectIO_GetItemsCount(internal.ReinterpretCast[*C.ImGuiMultiSelectIO](selfArg)))
}

// ImGuiMultiSelectState_SetWindow sets value of ImGuiMultiSelectState.Window
func (self MultiSelectState) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiMultiSelectState_GetWindow returns value of ImGuiMultiSelectState.Window
func (self *MultiSelectState) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiMultiSelectState_GetWindow(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg)))
}

// ImGuiMultiSelectState_SetID sets value of ImGuiMultiSelectState.ID
func (self MultiSelectState) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiMultiSelectState_GetID returns value of ImGuiMultiSelectState.ID
func (self *MultiSelectState) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiMultiSelectState_GetID(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectState_SetLastFrameActive sets value of ImGuiMultiSelectState.LastFrameActive
//
// Last used frame-count, for GC.
func (self MultiSelectState) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetLastFrameActive(selfArg, C.int(v))
}

// ImGuiMultiSelectState_GetLastFrameActive returns value of ImGuiMultiSelectState.LastFrameActive
//
// Last used frame-count, for GC.
func (self *MultiSelectState) LastFrameActive() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMultiSelectState_GetLastFrameActive(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg)))
}

// ImGuiMultiSelectState_SetLastSelectionSize sets value of ImGuiMultiSelectState.LastSelectionSize
//
// Set by BeginMultiSelect() based on optional info provided by user. May be -1 if unknown.
func (self MultiSelectState) SetLastSelectionSize(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetLastSelectionSize(selfArg, C.int(v))
}

// ImGuiMultiSelectState_GetLastSelectionSize returns value of ImGuiMultiSelectState.LastSelectionSize
//
// Set by BeginMultiSelect() based on optional info provided by user. May be -1 if unknown.
func (self *MultiSelectState) LastSelectionSize() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiMultiSelectState_GetLastSelectionSize(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg)))
}

// ImGuiMultiSelectState_SetRangeSelected sets value of ImGuiMultiSelectState.RangeSelected
//
// -1 (don't have) or true/false
func (self MultiSelectState) SetRangeSelected(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetRangeSelected(selfArg, C.ImS8(v))
}

// ImGuiMultiSelectState_GetRangeSelected returns value of ImGuiMultiSelectState.RangeSelected
//
// -1 (don't have) or true/false
func (self *MultiSelectState) RangeSelected() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiMultiSelectState_GetRangeSelected(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg)))
}

// ImGuiMultiSelectState_SetNavIdSelected sets value of ImGuiMultiSelectState.NavIdSelected
//
// -1 (don't have) or true/false
func (self MultiSelectState) SetNavIdSelected(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetNavIdSelected(selfArg, C.ImS8(v))
}

// ImGuiMultiSelectState_GetNavIdSelected returns value of ImGuiMultiSelectState.NavIdSelected
//
// -1 (don't have) or true/false
func (self *MultiSelectState) NavIdSelected() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiMultiSelectState_GetNavIdSelected(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg)))
}

// ImGuiMultiSelectState_SetRangeSrcItem sets value of ImGuiMultiSelectState.RangeSrcItem
func (self MultiSelectState) SetRangeSrcItem(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetRangeSrcItem(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiMultiSelectState_GetRangeSrcItem returns value of ImGuiMultiSelectState.RangeSrcItem
func (self *MultiSelectState) RangeSrcItem() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiMultiSelectState_GetRangeSrcItem(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectState_SetNavIdItem sets value of ImGuiMultiSelectState.NavIdItem
//
// SetNextItemSelectionUserData() value for NavId (if part of submitted items)
func (self MultiSelectState) SetNavIdItem(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectState_SetNavIdItem(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiMultiSelectState_GetNavIdItem returns value of ImGuiMultiSelectState.NavIdItem
//
// SetNextItemSelectionUserData() value for NavId (if part of submitted items)
func (self *MultiSelectState) NavIdItem() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiMultiSelectState_GetNavIdItem(internal.ReinterpretCast[*C.ImGuiMultiSelectState](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectTempData_SetIO sets value of ImGuiMultiSelectTempData.IO
//
// MUST BE FIRST FIELD. Requests are set and returned by BeginMultiSelect()/EndMultiSelect() + written to by user during the loop.
func (self MultiSelectTempData) SetIO(v MultiSelectIO) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetIO(selfArg, internal.ReinterpretCast[C.ImGuiMultiSelectIO](vArg))
}

// ImGuiMultiSelectTempData_GetIO returns value of ImGuiMultiSelectTempData.IO
//
// MUST BE FIRST FIELD. Requests are set and returned by BeginMultiSelect()/EndMultiSelect() + written to by user during the loop.
func (self *MultiSelectTempData) IO() MultiSelectIO {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewMultiSelectIOFromC(func() *C.ImGuiMultiSelectIO {
		result := C.wrap_ImGuiMultiSelectTempData_GetIO(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectTempData_SetStorage sets value of ImGuiMultiSelectTempData.Storage
func (self MultiSelectTempData) SetStorage(v *MultiSelectState) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetStorage(selfArg, internal.ReinterpretCast[*C.ImGuiMultiSelectState](vArg))
}

// ImGuiMultiSelectTempData_GetStorage returns value of ImGuiMultiSelectTempData.Storage
func (self *MultiSelectTempData) Storage() *MultiSelectState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewMultiSelectStateFromC(C.wrap_ImGuiMultiSelectTempData_GetStorage(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)))
}

// ImGuiMultiSelectTempData_SetFocusScopeId sets value of ImGuiMultiSelectTempData.FocusScopeId
//
// Copied from g.CurrentFocusScopeId (unless another selection scope was pushed manually)
func (self MultiSelectTempData) SetFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiMultiSelectTempData_GetFocusScopeId returns value of ImGuiMultiSelectTempData.FocusScopeId
//
// Copied from g.CurrentFocusScopeId (unless another selection scope was pushed manually)
func (self *MultiSelectTempData) FocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiMultiSelectTempData_GetFocusScopeId(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectTempData_SetFlags sets value of ImGuiMultiSelectTempData.Flags
func (self MultiSelectTempData) SetFlags(v MultiSelectFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetFlags(selfArg, C.ImGuiMultiSelectFlags(v))
}

// ImGuiMultiSelectTempData_GetFlags returns value of ImGuiMultiSelectTempData.Flags
func (self *MultiSelectTempData) Flags() MultiSelectFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return MultiSelectFlags(C.wrap_ImGuiMultiSelectTempData_GetFlags(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)))
}

// ImGuiMultiSelectTempData_SetScopeRectMin sets value of ImGuiMultiSelectTempData.ScopeRectMin
func (self MultiSelectTempData) SetScopeRectMin(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetScopeRectMin(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiMultiSelectTempData_GetScopeRectMin returns value of ImGuiMultiSelectTempData.ScopeRectMin
func (self *MultiSelectTempData) ScopeRectMin() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiMultiSelectTempData_GetScopeRectMin(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiMultiSelectTempData_SetBackupCursorMaxPos sets value of ImGuiMultiSelectTempData.BackupCursorMaxPos
func (self MultiSelectTempData) SetBackupCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetBackupCursorMaxPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiMultiSelectTempData_GetBackupCursorMaxPos returns value of ImGuiMultiSelectTempData.BackupCursorMaxPos
func (self *MultiSelectTempData) BackupCursorMaxPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiMultiSelectTempData_GetBackupCursorMaxPos(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiMultiSelectTempData_SetLastSubmittedItem sets value of ImGuiMultiSelectTempData.LastSubmittedItem
//
// Copy of last submitted item data, used to merge output ranges.
func (self MultiSelectTempData) SetLastSubmittedItem(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetLastSubmittedItem(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiMultiSelectTempData_GetLastSubmittedItem returns value of ImGuiMultiSelectTempData.LastSubmittedItem
//
// Copy of last submitted item data, used to merge output ranges.
func (self *MultiSelectTempData) LastSubmittedItem() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiMultiSelectTempData_GetLastSubmittedItem(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectTempData_SetBoxSelectId sets value of ImGuiMultiSelectTempData.BoxSelectId
func (self MultiSelectTempData) SetBoxSelectId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetBoxSelectId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiMultiSelectTempData_GetBoxSelectId returns value of ImGuiMultiSelectTempData.BoxSelectId
func (self *MultiSelectTempData) BoxSelectId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiMultiSelectTempData_GetBoxSelectId(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectTempData_SetKeyMods sets value of ImGuiMultiSelectTempData.KeyMods
func (self MultiSelectTempData) SetKeyMods(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetKeyMods(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiMultiSelectTempData_GetKeyMods returns value of ImGuiMultiSelectTempData.KeyMods
func (self *MultiSelectTempData) KeyMods() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiMultiSelectTempData_GetKeyMods(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg))
		return &result
	}())
}

// ImGuiMultiSelectTempData_SetLoopRequestSetAll sets value of ImGuiMultiSelectTempData.LoopRequestSetAll
//
// -1: no operation, 0: clear all, 1: select all.
func (self MultiSelectTempData) SetLoopRequestSetAll(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetLoopRequestSetAll(selfArg, C.ImS8(v))
}

// ImGuiMultiSelectTempData_GetLoopRequestSetAll returns value of ImGuiMultiSelectTempData.LoopRequestSetAll
//
// -1: no operation, 0: clear all, 1: select all.
func (self *MultiSelectTempData) LoopRequestSetAll() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiMultiSelectTempData_GetLoopRequestSetAll(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)))
}

// ImGuiMultiSelectTempData_SetIsEndIO sets value of ImGuiMultiSelectTempData.IsEndIO
//
// Set when switching IO from BeginMultiSelect() to EndMultiSelect() state.
func (self MultiSelectTempData) SetIsEndIO(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetIsEndIO(selfArg, C.bool(v))
}

// ImGuiMultiSelectTempData_GetIsEndIO returns value of ImGuiMultiSelectTempData.IsEndIO
//
// Set when switching IO from BeginMultiSelect() to EndMultiSelect() state.
func (self *MultiSelectTempData) IsEndIO() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectTempData_GetIsEndIO(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)) == C.bool(true)
}

// ImGuiMultiSelectTempData_SetIsFocused sets value of ImGuiMultiSelectTempData.IsFocused
//
// Set if currently focusing the selection scope (any item of the selection). May be used if you have custom shortcut associated to selection.
func (self MultiSelectTempData) SetIsFocused(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetIsFocused(selfArg, C.bool(v))
}

// ImGuiMultiSelectTempData_GetIsFocused returns value of ImGuiMultiSelectTempData.IsFocused
//
// Set if currently focusing the selection scope (any item of the selection). May be used if you have custom shortcut associated to selection.
func (self *MultiSelectTempData) IsFocused() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectTempData_GetIsFocused(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)) == C.bool(true)
}

// ImGuiMultiSelectTempData_SetIsKeyboardSetRange sets value of ImGuiMultiSelectTempData.IsKeyboardSetRange
//
// Set by BeginMultiSelect() when using Shift+Navigation. Because scrolling may be affected we can't afford a frame of lag with Shift+Navigation.
func (self MultiSelectTempData) SetIsKeyboardSetRange(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetIsKeyboardSetRange(selfArg, C.bool(v))
}

// ImGuiMultiSelectTempData_GetIsKeyboardSetRange returns value of ImGuiMultiSelectTempData.IsKeyboardSetRange
//
// Set by BeginMultiSelect() when using Shift+Navigation. Because scrolling may be affected we can't afford a frame of lag with Shift+Navigation.
func (self *MultiSelectTempData) IsKeyboardSetRange() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectTempData_GetIsKeyboardSetRange(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)) == C.bool(true)
}

// ImGuiMultiSelectTempData_SetNavIdPassedBy sets value of ImGuiMultiSelectTempData.NavIdPassedBy
func (self MultiSelectTempData) SetNavIdPassedBy(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetNavIdPassedBy(selfArg, C.bool(v))
}

// ImGuiMultiSelectTempData_GetNavIdPassedBy returns value of ImGuiMultiSelectTempData.NavIdPassedBy
func (self *MultiSelectTempData) NavIdPassedBy() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectTempData_GetNavIdPassedBy(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)) == C.bool(true)
}

// ImGuiMultiSelectTempData_SetRangeSrcPassedBy sets value of ImGuiMultiSelectTempData.RangeSrcPassedBy
//
// Set by the item that matches RangeSrcItem.
func (self MultiSelectTempData) SetRangeSrcPassedBy(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetRangeSrcPassedBy(selfArg, C.bool(v))
}

// ImGuiMultiSelectTempData_GetRangeSrcPassedBy returns value of ImGuiMultiSelectTempData.RangeSrcPassedBy
//
// Set by the item that matches RangeSrcItem.
func (self *MultiSelectTempData) RangeSrcPassedBy() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectTempData_GetRangeSrcPassedBy(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)) == C.bool(true)
}

// ImGuiMultiSelectTempData_SetRangeDstPassedBy sets value of ImGuiMultiSelectTempData.RangeDstPassedBy
//
// Set by the item that matches NavJustMovedToId when IsSetRange is set.
func (self MultiSelectTempData) SetRangeDstPassedBy(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiMultiSelectTempData_SetRangeDstPassedBy(selfArg, C.bool(v))
}

// ImGuiMultiSelectTempData_GetRangeDstPassedBy returns value of ImGuiMultiSelectTempData.RangeDstPassedBy
//
// Set by the item that matches NavJustMovedToId when IsSetRange is set.
func (self *MultiSelectTempData) RangeDstPassedBy() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiMultiSelectTempData_GetRangeDstPassedBy(internal.ReinterpretCast[*C.ImGuiMultiSelectTempData](selfArg)) == C.bool(true)
}

// ImGuiNavItemData_SetWindow sets value of ImGuiNavItemData.Window
//
// Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)
func (self NavItemData) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiNavItemData_GetWindow returns value of ImGuiNavItemData.Window
//
// Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)
func (self *NavItemData) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiNavItemData_GetWindow(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg)))
}

// ImGuiNavItemData_SetID sets value of ImGuiNavItemData.ID
//
// Init,Move    // Best candidate item ID
func (self NavItemData) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiNavItemData_GetID returns value of ImGuiNavItemData.ID
//
// Init,Move    // Best candidate item ID
func (self *NavItemData) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiNavItemData_GetID(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg))
		return &result
	}())
}

// ImGuiNavItemData_SetFocusScopeId sets value of ImGuiNavItemData.FocusScopeId
//
// Init,Move    // Best candidate focus scope ID
func (self NavItemData) SetFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiNavItemData_GetFocusScopeId returns value of ImGuiNavItemData.FocusScopeId
//
// Init,Move    // Best candidate focus scope ID
func (self *NavItemData) FocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiNavItemData_GetFocusScopeId(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg))
		return &result
	}())
}

// ImGuiNavItemData_SetRectRel sets value of ImGuiNavItemData.RectRel
//
// Init,Move    // Best candidate bounding box in window relative space
func (self NavItemData) SetRectRel(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetRectRel(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiNavItemData_GetRectRel returns value of ImGuiNavItemData.RectRel
//
// Init,Move    // Best candidate bounding box in window relative space
func (self *NavItemData) RectRel() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiNavItemData_GetRectRel(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNavItemData_SetItemFlags sets value of ImGuiNavItemData.ItemFlags
//
// ????,Move    // Best candidate item flags
func (self NavItemData) SetItemFlags(v ItemFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetItemFlags(selfArg, C.ImGuiItemFlags(v))
}

// ImGuiNavItemData_GetItemFlags returns value of ImGuiNavItemData.ItemFlags
//
// ????,Move    // Best candidate item flags
func (self *NavItemData) ItemFlags() ItemFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiNavItemData_GetItemFlags(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg)))
}

// ImGuiNavItemData_SetDistBox sets value of ImGuiNavItemData.DistBox
//
//	Move    // Best candidate box distance to current NavId
func (self NavItemData) SetDistBox(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetDistBox(selfArg, C.float(v))
}

// ImGuiNavItemData_GetDistBox returns value of ImGuiNavItemData.DistBox
//
//	Move    // Best candidate box distance to current NavId
func (self *NavItemData) DistBox() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNavItemData_GetDistBox(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg)))
}

// ImGuiNavItemData_SetDistCenter sets value of ImGuiNavItemData.DistCenter
//
//	Move    // Best candidate center distance to current NavId
func (self NavItemData) SetDistCenter(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetDistCenter(selfArg, C.float(v))
}

// ImGuiNavItemData_GetDistCenter returns value of ImGuiNavItemData.DistCenter
//
//	Move    // Best candidate center distance to current NavId
func (self *NavItemData) DistCenter() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNavItemData_GetDistCenter(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg)))
}

// ImGuiNavItemData_SetDistAxial sets value of ImGuiNavItemData.DistAxial
//
//	Move    // Best candidate axial distance to current NavId
func (self NavItemData) SetDistAxial(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetDistAxial(selfArg, C.float(v))
}

// ImGuiNavItemData_GetDistAxial returns value of ImGuiNavItemData.DistAxial
//
//	Move    // Best candidate axial distance to current NavId
func (self *NavItemData) DistAxial() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNavItemData_GetDistAxial(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg)))
}

// ImGuiNavItemData_SetSelectionUserData sets value of ImGuiNavItemData.SelectionUserData
//
// I+Mov    // Best candidate SetNextItemSelectionUserData() value. Valid if (ItemFlags & ImGuiItemFlags_HasSelectionUserData)
func (self NavItemData) SetSelectionUserData(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNavItemData_SetSelectionUserData(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiNavItemData_GetSelectionUserData returns value of ImGuiNavItemData.SelectionUserData
//
// I+Mov    // Best candidate SetNextItemSelectionUserData() value. Valid if (ItemFlags & ImGuiItemFlags_HasSelectionUserData)
func (self *NavItemData) SelectionUserData() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiNavItemData_GetSelectionUserData(internal.ReinterpretCast[*C.ImGuiNavItemData](selfArg))
		return &result
	}())
}

// ImGuiNextItemData_SetHasFlags sets value of ImGuiNextItemData.HasFlags
//
// Called HasFlags instead of Flags to avoid mistaking this
func (self NextItemData) SetHasFlags(v NextItemDataFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetHasFlags(selfArg, C.ImGuiNextItemDataFlags(v))
}

// ImGuiNextItemData_GetHasFlags returns value of ImGuiNextItemData.HasFlags
//
// Called HasFlags instead of Flags to avoid mistaking this
func (self *NextItemData) HasFlags() NextItemDataFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NextItemDataFlags(C.wrap_ImGuiNextItemData_GetHasFlags(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg)))
}

// ImGuiNextItemData_SetItemFlags sets value of ImGuiNextItemData.ItemFlags
//
// Currently only tested/used for ImGuiItemFlags_AllowOverlap and ImGuiItemFlags_HasSelectionUserData.
func (self NextItemData) SetItemFlags(v ItemFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetItemFlags(selfArg, C.ImGuiItemFlags(v))
}

// ImGuiNextItemData_GetItemFlags returns value of ImGuiNextItemData.ItemFlags
//
// Currently only tested/used for ImGuiItemFlags_AllowOverlap and ImGuiItemFlags_HasSelectionUserData.
func (self *NextItemData) ItemFlags() ItemFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiNextItemData_GetItemFlags(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg)))
}

// ImGuiNextItemData_SetFocusScopeId sets value of ImGuiNextItemData.FocusScopeId
//
//	// Non-flags members are NOT cleared by ItemAdd() meaning they are still valid during NavProcessItem()
//
// Set by SetNextItemSelectionUserData()
func (self NextItemData) SetFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiNextItemData_GetFocusScopeId returns value of ImGuiNextItemData.FocusScopeId
//
//	// Non-flags members are NOT cleared by ItemAdd() meaning they are still valid during NavProcessItem()
//
// Set by SetNextItemSelectionUserData()
func (self *NextItemData) FocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiNextItemData_GetFocusScopeId(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg))
		return &result
	}())
}

// ImGuiNextItemData_SetSelectionUserData sets value of ImGuiNextItemData.SelectionUserData
//
// Set by SetNextItemSelectionUserData() (note that NULL/0 is a valid value, we use -1 == ImGuiSelectionUserData_Invalid to mark invalid values)
func (self NextItemData) SetSelectionUserData(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetSelectionUserData(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiNextItemData_GetSelectionUserData returns value of ImGuiNextItemData.SelectionUserData
//
// Set by SetNextItemSelectionUserData() (note that NULL/0 is a valid value, we use -1 == ImGuiSelectionUserData_Invalid to mark invalid values)
func (self *NextItemData) SelectionUserData() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiNextItemData_GetSelectionUserData(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg))
		return &result
	}())
}

// ImGuiNextItemData_SetWidth sets value of ImGuiNextItemData.Width
//
// Set by SetNextItemWidth()
func (self NextItemData) SetWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetWidth(selfArg, C.float(v))
}

// ImGuiNextItemData_GetWidth returns value of ImGuiNextItemData.Width
//
// Set by SetNextItemWidth()
func (self *NextItemData) Width() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNextItemData_GetWidth(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg)))
}

// ImGuiNextItemData_SetShortcut sets value of ImGuiNextItemData.Shortcut
//
// Set by SetNextItemShortcut()
func (self NextItemData) SetShortcut(v KeyChord) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetShortcut(selfArg, internal.ReinterpretCast[C.ImGuiKeyChord](vArg))
}

// ImGuiNextItemData_GetShortcut returns value of ImGuiNextItemData.Shortcut
//
// Set by SetNextItemShortcut()
func (self *NextItemData) Shortcut() KeyChord {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewKeyChordFromC(func() *C.ImGuiKeyChord {
		result := C.wrap_ImGuiNextItemData_GetShortcut(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg))
		return &result
	}())
}

// ImGuiNextItemData_SetShortcutFlags sets value of ImGuiNextItemData.ShortcutFlags
//
// Set by SetNextItemShortcut()
func (self NextItemData) SetShortcutFlags(v InputFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetShortcutFlags(selfArg, C.ImGuiInputFlags(v))
}

// ImGuiNextItemData_GetShortcutFlags returns value of ImGuiNextItemData.ShortcutFlags
//
// Set by SetNextItemShortcut()
func (self *NextItemData) ShortcutFlags() InputFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return InputFlags(C.wrap_ImGuiNextItemData_GetShortcutFlags(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg)))
}

// ImGuiNextItemData_SetOpenVal sets value of ImGuiNextItemData.OpenVal
//
// Set by SetNextItemOpen()
func (self NextItemData) SetOpenVal(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetOpenVal(selfArg, C.bool(v))
}

// ImGuiNextItemData_GetOpenVal returns value of ImGuiNextItemData.OpenVal
//
// Set by SetNextItemOpen()
func (self *NextItemData) OpenVal() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiNextItemData_GetOpenVal(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg)) == C.bool(true)
}

// ImGuiNextItemData_SetOpenCond sets value of ImGuiNextItemData.OpenCond
//
// Set by SetNextItemOpen()
func (self NextItemData) SetOpenCond(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetOpenCond(selfArg, C.ImU8(v))
}

// ImGuiNextItemData_GetOpenCond returns value of ImGuiNextItemData.OpenCond
//
// Set by SetNextItemOpen()
func (self *NextItemData) OpenCond() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiNextItemData_GetOpenCond(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg)))
}

// ImGuiNextItemData_SetRefVal sets value of ImGuiNextItemData.RefVal
//
// Not exposed yet, for ImGuiInputTextFlags_ParseEmptyAsRefVal
func (self NextItemData) SetRefVal(v DataTypeStorage) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetRefVal(selfArg, internal.ReinterpretCast[C.ImGuiDataTypeStorage](vArg))
}

// ImGuiNextItemData_GetRefVal returns value of ImGuiNextItemData.RefVal
//
// Not exposed yet, for ImGuiInputTextFlags_ParseEmptyAsRefVal
func (self *NextItemData) RefVal() DataTypeStorage {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDataTypeStorageFromC(func() *C.ImGuiDataTypeStorage {
		result := C.wrap_ImGuiNextItemData_GetRefVal(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg))
		return &result
	}())
}

// ImGuiNextItemData_SetStorageId sets value of ImGuiNextItemData.StorageId
//
// Set by SetNextItemStorageID()
func (self NextItemData) SetStorageId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextItemData_SetStorageId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiNextItemData_GetStorageId returns value of ImGuiNextItemData.StorageId
//
// Set by SetNextItemStorageID()
func (self *NextItemData) StorageId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiNextItemData_GetStorageId(internal.ReinterpretCast[*C.ImGuiNextItemData](selfArg))
		return &result
	}())
}

// ImGuiNextWindowData_SetFlags sets value of ImGuiNextWindowData.Flags
func (self NextWindowData) SetFlags(v NextWindowDataFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetFlags(selfArg, C.ImGuiNextWindowDataFlags(v))
}

// ImGuiNextWindowData_GetFlags returns value of ImGuiNextWindowData.Flags
func (self *NextWindowData) Flags() NextWindowDataFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NextWindowDataFlags(C.wrap_ImGuiNextWindowData_GetFlags(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetPosCond sets value of ImGuiNextWindowData.PosCond
func (self NextWindowData) SetPosCond(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosCond(selfArg, C.ImGuiCond(v))
}

// ImGuiNextWindowData_GetPosCond returns value of ImGuiNextWindowData.PosCond
func (self *NextWindowData) PosCond() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetPosCond(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetSizeCond sets value of ImGuiNextWindowData.SizeCond
func (self NextWindowData) SetSizeCond(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeCond(selfArg, C.ImGuiCond(v))
}

// ImGuiNextWindowData_GetSizeCond returns value of ImGuiNextWindowData.SizeCond
func (self *NextWindowData) SizeCond() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetSizeCond(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetCollapsedCond sets value of ImGuiNextWindowData.CollapsedCond
func (self NextWindowData) SetCollapsedCond(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetCollapsedCond(selfArg, C.ImGuiCond(v))
}

// ImGuiNextWindowData_GetCollapsedCond returns value of ImGuiNextWindowData.CollapsedCond
func (self *NextWindowData) CollapsedCond() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetCollapsedCond(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetDockCond sets value of ImGuiNextWindowData.DockCond
func (self NextWindowData) SetDockCond(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetDockCond(selfArg, C.ImGuiCond(v))
}

// ImGuiNextWindowData_GetDockCond returns value of ImGuiNextWindowData.DockCond
func (self *NextWindowData) DockCond() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiNextWindowData_GetDockCond(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetPosVal sets value of ImGuiNextWindowData.PosVal
func (self NextWindowData) SetPosVal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosVal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiNextWindowData_GetPosVal returns value of ImGuiNextWindowData.PosVal
func (self *NextWindowData) PosVal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiNextWindowData_GetPosVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNextWindowData_SetPosPivotVal sets value of ImGuiNextWindowData.PosPivotVal
func (self NextWindowData) SetPosPivotVal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosPivotVal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiNextWindowData_GetPosPivotVal returns value of ImGuiNextWindowData.PosPivotVal
func (self *NextWindowData) PosPivotVal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiNextWindowData_GetPosPivotVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNextWindowData_SetSizeVal sets value of ImGuiNextWindowData.SizeVal
func (self NextWindowData) SetSizeVal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeVal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiNextWindowData_GetSizeVal returns value of ImGuiNextWindowData.SizeVal
func (self *NextWindowData) SizeVal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiNextWindowData_GetSizeVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNextWindowData_SetContentSizeVal sets value of ImGuiNextWindowData.ContentSizeVal
func (self NextWindowData) SetContentSizeVal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetContentSizeVal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiNextWindowData_GetContentSizeVal returns value of ImGuiNextWindowData.ContentSizeVal
func (self *NextWindowData) ContentSizeVal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiNextWindowData_GetContentSizeVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNextWindowData_SetScrollVal sets value of ImGuiNextWindowData.ScrollVal
func (self NextWindowData) SetScrollVal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetScrollVal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiNextWindowData_GetScrollVal returns value of ImGuiNextWindowData.ScrollVal
func (self *NextWindowData) ScrollVal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiNextWindowData_GetScrollVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNextWindowData_SetChildFlags sets value of ImGuiNextWindowData.ChildFlags
func (self NextWindowData) SetChildFlags(v ChildFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetChildFlags(selfArg, C.ImGuiChildFlags(v))
}

// ImGuiNextWindowData_GetChildFlags returns value of ImGuiNextWindowData.ChildFlags
func (self *NextWindowData) ChildFlags() ChildFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ChildFlags(C.wrap_ImGuiNextWindowData_GetChildFlags(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetPosUndock sets value of ImGuiNextWindowData.PosUndock
func (self NextWindowData) SetPosUndock(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetPosUndock(selfArg, C.bool(v))
}

// ImGuiNextWindowData_GetPosUndock returns value of ImGuiNextWindowData.PosUndock
func (self *NextWindowData) PosUndock() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiNextWindowData_GetPosUndock(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)) == C.bool(true)
}

// ImGuiNextWindowData_SetCollapsedVal sets value of ImGuiNextWindowData.CollapsedVal
func (self NextWindowData) SetCollapsedVal(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetCollapsedVal(selfArg, C.bool(v))
}

// ImGuiNextWindowData_GetCollapsedVal returns value of ImGuiNextWindowData.CollapsedVal
func (self *NextWindowData) CollapsedVal() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiNextWindowData_GetCollapsedVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)) == C.bool(true)
}

// ImGuiNextWindowData_SetSizeConstraintRect sets value of ImGuiNextWindowData.SizeConstraintRect
func (self NextWindowData) SetSizeConstraintRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeConstraintRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiNextWindowData_GetSizeConstraintRect returns value of ImGuiNextWindowData.SizeConstraintRect
func (self *NextWindowData) SizeConstraintRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiNextWindowData_GetSizeConstraintRect(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNextWindowData_SetSizeCallback sets value of ImGuiNextWindowData.SizeCallback
func (self NextWindowData) SetSizeCallback(v SizeCallback) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeCallback(selfArg, internal.ReinterpretCast[C.ImGuiSizeCallback](vArg))
}

// ImGuiNextWindowData_GetSizeCallback returns value of ImGuiNextWindowData.SizeCallback
func (self *NextWindowData) SizeCallback() SizeCallback {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSizeCallbackFromC(func() *C.ImGuiSizeCallback {
		result := C.wrap_ImGuiNextWindowData_GetSizeCallback(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return &result
	}())
}

// ImGuiNextWindowData_SetSizeCallbackUserData sets value of ImGuiNextWindowData.SizeCallbackUserData
func (self NextWindowData) SetSizeCallbackUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetSizeCallbackUserData(selfArg, C.uintptr_t(v))
}

// ImGuiNextWindowData_GetSizeCallbackUserData returns value of ImGuiNextWindowData.SizeCallbackUserData
func (self *NextWindowData) SizeCallbackUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiNextWindowData_GetSizeCallbackUserData(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetBgAlphaVal sets value of ImGuiNextWindowData.BgAlphaVal
//
// Override background alpha
func (self NextWindowData) SetBgAlphaVal(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetBgAlphaVal(selfArg, C.float(v))
}

// ImGuiNextWindowData_GetBgAlphaVal returns value of ImGuiNextWindowData.BgAlphaVal
//
// Override background alpha
func (self *NextWindowData) BgAlphaVal() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiNextWindowData_GetBgAlphaVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiNextWindowData_SetViewportId sets value of ImGuiNextWindowData.ViewportId
func (self NextWindowData) SetViewportId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetViewportId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiNextWindowData_GetViewportId returns value of ImGuiNextWindowData.ViewportId
func (self *NextWindowData) ViewportId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiNextWindowData_GetViewportId(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return &result
	}())
}

// ImGuiNextWindowData_SetDockId sets value of ImGuiNextWindowData.DockId
func (self NextWindowData) SetDockId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetDockId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiNextWindowData_GetDockId returns value of ImGuiNextWindowData.DockId
func (self *NextWindowData) DockId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiNextWindowData_GetDockId(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return &result
	}())
}

// ImGuiNextWindowData_SetWindowClass sets value of ImGuiNextWindowData.WindowClass
func (self NextWindowData) SetWindowClass(v WindowClass) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetWindowClass(selfArg, internal.ReinterpretCast[C.ImGuiWindowClass](vArg))
}

// ImGuiNextWindowData_GetWindowClass returns value of ImGuiNextWindowData.WindowClass
func (self *NextWindowData) WindowClass() WindowClass {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewWindowClassFromC(func() *C.ImGuiWindowClass {
		result := C.wrap_ImGuiNextWindowData_GetWindowClass(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return &result
	}())
}

// ImGuiNextWindowData_SetMenuBarOffsetMinVal sets value of ImGuiNextWindowData.MenuBarOffsetMinVal
//
// (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)
func (self NextWindowData) SetMenuBarOffsetMinVal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetMenuBarOffsetMinVal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiNextWindowData_GetMenuBarOffsetMinVal returns value of ImGuiNextWindowData.MenuBarOffsetMinVal
//
// (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)
func (self *NextWindowData) MenuBarOffsetMinVal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiNextWindowData_GetMenuBarOffsetMinVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiNextWindowData_SetRefreshFlagsVal sets value of ImGuiNextWindowData.RefreshFlagsVal
func (self NextWindowData) SetRefreshFlagsVal(v WindowRefreshFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiNextWindowData_SetRefreshFlagsVal(selfArg, C.ImGuiWindowRefreshFlags(v))
}

// ImGuiNextWindowData_GetRefreshFlagsVal returns value of ImGuiNextWindowData.RefreshFlagsVal
func (self *NextWindowData) RefreshFlagsVal() WindowRefreshFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return WindowRefreshFlags(C.wrap_ImGuiNextWindowData_GetRefreshFlagsVal(internal.ReinterpretCast[*C.ImGuiNextWindowData](selfArg)))
}

// ImGuiOldColumnData_SetOffsetNorm sets value of ImGuiOldColumnData.OffsetNorm
//
// Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
func (self OldColumnData) SetOffsetNorm(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetOffsetNorm(selfArg, C.float(v))
}

// ImGuiOldColumnData_GetOffsetNorm returns value of ImGuiOldColumnData.OffsetNorm
//
// Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
func (self *OldColumnData) OffsetNorm() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumnData_GetOffsetNorm(internal.ReinterpretCast[*C.ImGuiOldColumnData](selfArg)))
}

// ImGuiOldColumnData_SetOffsetNormBeforeResize sets value of ImGuiOldColumnData.OffsetNormBeforeResize
func (self OldColumnData) SetOffsetNormBeforeResize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetOffsetNormBeforeResize(selfArg, C.float(v))
}

// ImGuiOldColumnData_GetOffsetNormBeforeResize returns value of ImGuiOldColumnData.OffsetNormBeforeResize
func (self *OldColumnData) OffsetNormBeforeResize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumnData_GetOffsetNormBeforeResize(internal.ReinterpretCast[*C.ImGuiOldColumnData](selfArg)))
}

// ImGuiOldColumnData_SetFlags sets value of ImGuiOldColumnData.Flags
//
// Not exposed
func (self OldColumnData) SetFlags(v OldColumnFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetFlags(selfArg, C.ImGuiOldColumnFlags(v))
}

// ImGuiOldColumnData_GetFlags returns value of ImGuiOldColumnData.Flags
//
// Not exposed
func (self *OldColumnData) Flags() OldColumnFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return OldColumnFlags(C.wrap_ImGuiOldColumnData_GetFlags(internal.ReinterpretCast[*C.ImGuiOldColumnData](selfArg)))
}

// ImGuiOldColumnData_SetClipRect sets value of ImGuiOldColumnData.ClipRect
func (self OldColumnData) SetClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumnData_SetClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiOldColumnData_GetClipRect returns value of ImGuiOldColumnData.ClipRect
func (self *OldColumnData) ClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiOldColumnData_GetClipRect(internal.ReinterpretCast[*C.ImGuiOldColumnData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiOldColumns_SetID sets value of ImGuiOldColumns.ID
func (self OldColumns) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiOldColumns_GetID returns value of ImGuiOldColumns.ID
func (self *OldColumns) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiOldColumns_GetID(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg))
		return &result
	}())
}

// ImGuiOldColumns_SetFlags sets value of ImGuiOldColumns.Flags
func (self OldColumns) SetFlags(v OldColumnFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetFlags(selfArg, C.ImGuiOldColumnFlags(v))
}

// ImGuiOldColumns_GetFlags returns value of ImGuiOldColumns.Flags
func (self *OldColumns) Flags() OldColumnFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return OldColumnFlags(C.wrap_ImGuiOldColumns_GetFlags(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetIsFirstFrame sets value of ImGuiOldColumns.IsFirstFrame
func (self OldColumns) SetIsFirstFrame(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetIsFirstFrame(selfArg, C.bool(v))
}

// ImGuiOldColumns_GetIsFirstFrame returns value of ImGuiOldColumns.IsFirstFrame
func (self *OldColumns) IsFirstFrame() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiOldColumns_GetIsFirstFrame(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)) == C.bool(true)
}

// ImGuiOldColumns_SetIsBeingResized sets value of ImGuiOldColumns.IsBeingResized
func (self OldColumns) SetIsBeingResized(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetIsBeingResized(selfArg, C.bool(v))
}

// ImGuiOldColumns_GetIsBeingResized returns value of ImGuiOldColumns.IsBeingResized
func (self *OldColumns) IsBeingResized() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiOldColumns_GetIsBeingResized(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)) == C.bool(true)
}

// ImGuiOldColumns_SetCurrent sets value of ImGuiOldColumns.Current
func (self OldColumns) SetCurrent(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetCurrent(selfArg, C.int(v))
}

// ImGuiOldColumns_GetCurrent returns value of ImGuiOldColumns.Current
func (self *OldColumns) Current() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiOldColumns_GetCurrent(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetCount sets value of ImGuiOldColumns.Count
func (self OldColumns) SetCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetCount(selfArg, C.int(v))
}

// ImGuiOldColumns_GetCount returns value of ImGuiOldColumns.Count
func (self *OldColumns) Count() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiOldColumns_GetCount(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetOffMinX sets value of ImGuiOldColumns.OffMinX
//
// Offsets from HostWorkRect.Min.x
func (self OldColumns) SetOffMinX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetOffMinX(selfArg, C.float(v))
}

// ImGuiOldColumns_GetOffMinX returns value of ImGuiOldColumns.OffMinX
//
// Offsets from HostWorkRect.Min.x
func (self *OldColumns) OffMinX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetOffMinX(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetOffMaxX sets value of ImGuiOldColumns.OffMaxX
//
// Offsets from HostWorkRect.Min.x
func (self OldColumns) SetOffMaxX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetOffMaxX(selfArg, C.float(v))
}

// ImGuiOldColumns_GetOffMaxX returns value of ImGuiOldColumns.OffMaxX
//
// Offsets from HostWorkRect.Min.x
func (self *OldColumns) OffMaxX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetOffMaxX(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetLineMinY sets value of ImGuiOldColumns.LineMinY
func (self OldColumns) SetLineMinY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetLineMinY(selfArg, C.float(v))
}

// ImGuiOldColumns_GetLineMinY returns value of ImGuiOldColumns.LineMinY
func (self *OldColumns) LineMinY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetLineMinY(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetLineMaxY sets value of ImGuiOldColumns.LineMaxY
func (self OldColumns) SetLineMaxY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetLineMaxY(selfArg, C.float(v))
}

// ImGuiOldColumns_GetLineMaxY returns value of ImGuiOldColumns.LineMaxY
func (self *OldColumns) LineMaxY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetLineMaxY(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetHostCursorPosY sets value of ImGuiOldColumns.HostCursorPosY
//
// Backup of CursorPos at the time of BeginColumns()
func (self OldColumns) SetHostCursorPosY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostCursorPosY(selfArg, C.float(v))
}

// ImGuiOldColumns_GetHostCursorPosY returns value of ImGuiOldColumns.HostCursorPosY
//
// Backup of CursorPos at the time of BeginColumns()
func (self *OldColumns) HostCursorPosY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetHostCursorPosY(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetHostCursorMaxPosX sets value of ImGuiOldColumns.HostCursorMaxPosX
//
// Backup of CursorMaxPos at the time of BeginColumns()
func (self OldColumns) SetHostCursorMaxPosX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostCursorMaxPosX(selfArg, C.float(v))
}

// ImGuiOldColumns_GetHostCursorMaxPosX returns value of ImGuiOldColumns.HostCursorMaxPosX
//
// Backup of CursorMaxPos at the time of BeginColumns()
func (self *OldColumns) HostCursorMaxPosX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiOldColumns_GetHostCursorMaxPosX(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)))
}

// ImGuiOldColumns_SetHostInitialClipRect sets value of ImGuiOldColumns.HostInitialClipRect
//
// Backup of ClipRect at the time of BeginColumns()
func (self OldColumns) SetHostInitialClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostInitialClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiOldColumns_GetHostInitialClipRect returns value of ImGuiOldColumns.HostInitialClipRect
//
// Backup of ClipRect at the time of BeginColumns()
func (self *OldColumns) HostInitialClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiOldColumns_GetHostInitialClipRect(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiOldColumns_SetHostBackupClipRect sets value of ImGuiOldColumns.HostBackupClipRect
//
// Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
func (self OldColumns) SetHostBackupClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostBackupClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiOldColumns_GetHostBackupClipRect returns value of ImGuiOldColumns.HostBackupClipRect
//
// Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
func (self *OldColumns) HostBackupClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiOldColumns_GetHostBackupClipRect(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiOldColumns_SetHostBackupParentWorkRect sets value of ImGuiOldColumns.HostBackupParentWorkRect
//
// Backup of WorkRect at the time of BeginColumns()
func (self OldColumns) SetHostBackupParentWorkRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetHostBackupParentWorkRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiOldColumns_GetHostBackupParentWorkRect returns value of ImGuiOldColumns.HostBackupParentWorkRect
//
// Backup of WorkRect at the time of BeginColumns()
func (self *OldColumns) HostBackupParentWorkRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiOldColumns_GetHostBackupParentWorkRect(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiOldColumns_SetColumns sets value of ImGuiOldColumns.Columns
func (self OldColumns) SetColumns(v vectors.Vector[OldColumnData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiOldColumnData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiOldColumnData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetColumns(selfArg, *vVecArg)
}

// ImGuiOldColumns_GetColumns returns value of ImGuiOldColumns.Columns
func (self *OldColumns) Columns() vectors.Vector[OldColumnData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiOldColumns_GetColumns(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)).Size, C.wrap_ImGuiOldColumns_GetColumns(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)).Capacity, NewOldColumnDataFromC(C.wrap_ImGuiOldColumns_GetColumns(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg)).Data))
}

// ImGuiOldColumns_SetSplitter sets value of ImGuiOldColumns.Splitter
func (self OldColumns) SetSplitter(v DrawListSplitter) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOldColumns_SetSplitter(selfArg, internal.ReinterpretCast[C.ImDrawListSplitter](vArg))
}

// ImGuiOldColumns_GetSplitter returns value of ImGuiOldColumns.Splitter
func (self *OldColumns) Splitter() DrawListSplitter {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawListSplitterFromC(func() *C.ImDrawListSplitter {
		result := C.wrap_ImGuiOldColumns_GetSplitter(internal.ReinterpretCast[*C.ImGuiOldColumns](selfArg))
		return &result
	}())
}

// ImGuiOnceUponAFrame_SetRefFrame sets value of ImGuiOnceUponAFrame.RefFrame
func (self OnceUponAFrame) SetRefFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiOnceUponAFrame_SetRefFrame(selfArg, C.int(v))
}

// ImGuiOnceUponAFrame_GetRefFrame returns value of ImGuiOnceUponAFrame.RefFrame
func (self *OnceUponAFrame) RefFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiOnceUponAFrame_GetRefFrame(internal.ReinterpretCast[*C.ImGuiOnceUponAFrame](selfArg)))
}

// ImGuiPayload_SetData sets value of ImGuiPayload.Data
//
//	// Members
//
// Data (copied and owned by dear imgui)
func (self Payload) SetData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetData(selfArg, C.uintptr_t(v))
}

// ImGuiPayload_GetData returns value of ImGuiPayload.Data
//
//	// Members
//
// Data (copied and owned by dear imgui)
func (self *Payload) Data() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiPayload_GetData(internal.ReinterpretCast[*C.ImGuiPayload](selfArg)))
}

// ImGuiPayload_SetDataSize sets value of ImGuiPayload.DataSize
//
// Data size
func (self Payload) SetDataSize(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetDataSize(selfArg, C.int(v))
}

// ImGuiPayload_GetDataSize returns value of ImGuiPayload.DataSize
//
// Data size
func (self *Payload) DataSize() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPayload_GetDataSize(internal.ReinterpretCast[*C.ImGuiPayload](selfArg)))
}

// ImGuiPayload_SetSourceId sets value of ImGuiPayload.SourceId
//
//	// [Internal]
//
// Source item id
func (self Payload) SetSourceId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetSourceId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiPayload_GetSourceId returns value of ImGuiPayload.SourceId
//
//	// [Internal]
//
// Source item id
func (self *Payload) SourceId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiPayload_GetSourceId(internal.ReinterpretCast[*C.ImGuiPayload](selfArg))
		return &result
	}())
}

// ImGuiPayload_SetSourceParentId sets value of ImGuiPayload.SourceParentId
//
// Source parent id (if available)
func (self Payload) SetSourceParentId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetSourceParentId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiPayload_GetSourceParentId returns value of ImGuiPayload.SourceParentId
//
// Source parent id (if available)
func (self *Payload) SourceParentId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiPayload_GetSourceParentId(internal.ReinterpretCast[*C.ImGuiPayload](selfArg))
		return &result
	}())
}

// ImGuiPayload_SetDataFrameCount sets value of ImGuiPayload.DataFrameCount
//
// Data timestamp
func (self Payload) SetDataFrameCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetDataFrameCount(selfArg, C.int(v))
}

// ImGuiPayload_GetDataFrameCount returns value of ImGuiPayload.DataFrameCount
//
// Data timestamp
func (self *Payload) DataFrameCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPayload_GetDataFrameCount(internal.ReinterpretCast[*C.ImGuiPayload](selfArg)))
}

// ImGuiPayload_SetDataType sets value of ImGuiPayload.DataType[32+1]
//
// Data type tag (short user-supplied string, 32 characters max)
func (self Payload) SetDataType(v *[33]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetDataType(selfArg, (*C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = rune(vV)
	}
}

// ImGuiPayload_GetDataType returns value of ImGuiPayload.DataType[32+1]
//
// Data type tag (short user-supplied string, 32 characters max)
func (self *Payload) DataType() [33]rune {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [33]rune {
		result := [33]rune{}
		resultMirr := C.wrap_ImGuiPayload_GetDataType(internal.ReinterpretCast[*C.ImGuiPayload](selfArg))
		for i := range result {
			result[i] = rune(C.cimgui_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiPayload_SetPreview sets value of ImGuiPayload.Preview
//
// Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
func (self Payload) SetPreview(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetPreview(selfArg, C.bool(v))
}

// ImGuiPayload_GetPreview returns value of ImGuiPayload.Preview
//
// Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
func (self *Payload) Preview() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiPayload_GetPreview(internal.ReinterpretCast[*C.ImGuiPayload](selfArg)) == C.bool(true)
}

// ImGuiPayload_SetDelivery sets value of ImGuiPayload.Delivery
//
// Set when AcceptDragDropPayload() was called and mouse button is released over the target item.
func (self Payload) SetDelivery(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPayload_SetDelivery(selfArg, C.bool(v))
}

// ImGuiPayload_GetDelivery returns value of ImGuiPayload.Delivery
//
// Set when AcceptDragDropPayload() was called and mouse button is released over the target item.
func (self *Payload) Delivery() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiPayload_GetDelivery(internal.ReinterpretCast[*C.ImGuiPayload](selfArg)) == C.bool(true)
}

// ImGuiPlatformIO_SetPlatform_ClipboardUserData sets value of ImGuiPlatformIO.Platform_ClipboardUserData
func (self PlatformIO) SetPlatformClipboardUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformIO_SetPlatform_ClipboardUserData(selfArg, C.uintptr_t(v))
}

// ImGuiPlatformIO_GetPlatform_ClipboardUserData returns value of ImGuiPlatformIO.Platform_ClipboardUserData
func (self *PlatformIO) PlatformClipboardUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiPlatformIO_GetPlatform_ClipboardUserData(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)))
}

// ImGuiPlatformIO_SetPlatform_OpenInShellUserData sets value of ImGuiPlatformIO.Platform_OpenInShellUserData
func (self PlatformIO) SetPlatformOpenInShellUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformIO_SetPlatform_OpenInShellUserData(selfArg, C.uintptr_t(v))
}

// ImGuiPlatformIO_GetPlatform_OpenInShellUserData returns value of ImGuiPlatformIO.Platform_OpenInShellUserData
func (self *PlatformIO) PlatformOpenInShellUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiPlatformIO_GetPlatform_OpenInShellUserData(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)))
}

// ImGuiPlatformIO_SetPlatform_ImeUserData sets value of ImGuiPlatformIO.Platform_ImeUserData
func (self PlatformIO) SetPlatformImeUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformIO_SetPlatform_ImeUserData(selfArg, C.uintptr_t(v))
}

// ImGuiPlatformIO_GetPlatform_ImeUserData returns value of ImGuiPlatformIO.Platform_ImeUserData
func (self *PlatformIO) PlatformImeUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiPlatformIO_GetPlatform_ImeUserData(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)))
}

// ImGuiPlatformIO_SetPlatform_LocaleDecimalPoint sets value of ImGuiPlatformIO.Platform_LocaleDecimalPoint
//
//	// Optional: Platform locale
//	// [Experimental] Configure decimal point e.g. '.' or ',' useful for some languages (e.g. German), generally pulled from *localeconv()->decimal_point
//
// '.'
func (self PlatformIO) SetPlatformLocaleDecimalPoint(v Wchar) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformIO_SetPlatform_LocaleDecimalPoint(selfArg, C.ImWchar(v))
}

// ImGuiPlatformIO_GetPlatform_LocaleDecimalPoint returns value of ImGuiPlatformIO.Platform_LocaleDecimalPoint
//
//	// Optional: Platform locale
//	// [Experimental] Configure decimal point e.g. '.' or ',' useful for some languages (e.g. German), generally pulled from *localeconv()->decimal_point
//
// '.'
func (self *PlatformIO) PlatformLocaleDecimalPoint() Wchar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Wchar(C.wrap_ImGuiPlatformIO_GetPlatform_LocaleDecimalPoint(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)))
}

// ImGuiPlatformIO_SetRenderer_RenderState sets value of ImGuiPlatformIO.Renderer_RenderState
//
//	// Written by some backends during ImGui_ImplXXXX_RenderDrawData() call to point backend_specific ImGui_ImplXXXX_RenderState* structure.
func (self PlatformIO) SetRendererRenderState(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformIO_SetRenderer_RenderState(selfArg, C.uintptr_t(v))
}

// ImGuiPlatformIO_GetRenderer_RenderState returns value of ImGuiPlatformIO.Renderer_RenderState
//
//	// Written by some backends during ImGui_ImplXXXX_RenderDrawData() call to point backend_specific ImGui_ImplXXXX_RenderState* structure.
func (self *PlatformIO) RendererRenderState() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiPlatformIO_GetRenderer_RenderState(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)))
}

// ImGuiPlatformIO_SetMonitors sets value of ImGuiPlatformIO.Monitors
//
//	// (Optional) Monitor list
//	// - Updated by: app/backend. Update every frame to dynamically support changing monitor or DPI configuration.
//	// - Used by: dear imgui to query DPI info, clamp popups/tooltips within same monitor and not have them straddle monitors.
func (self PlatformIO) SetMonitors(v vectors.Vector[PlatformMonitor]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiPlatformMonitor)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiPlatformMonitor](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformIO_SetMonitors(selfArg, *vVecArg)
}

// ImGuiPlatformIO_GetMonitors returns value of ImGuiPlatformIO.Monitors
//
//	// (Optional) Monitor list
//	// - Updated by: app/backend. Update every frame to dynamically support changing monitor or DPI configuration.
//	// - Used by: dear imgui to query DPI info, clamp popups/tooltips within same monitor and not have them straddle monitors.
func (self *PlatformIO) Monitors() vectors.Vector[PlatformMonitor] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiPlatformIO_GetMonitors(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)).Size, C.wrap_ImGuiPlatformIO_GetMonitors(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)).Capacity, NewPlatformMonitorFromC(C.wrap_ImGuiPlatformIO_GetMonitors(internal.ReinterpretCast[*C.ImGuiPlatformIO](selfArg)).Data))
}

// ImGuiPlatformImeData_SetWantVisible sets value of ImGuiPlatformImeData.WantVisible
//
// A widget wants the IME to be visible
func (self PlatformImeData) SetWantVisible(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformImeData_SetWantVisible(selfArg, C.bool(v))
}

// ImGuiPlatformImeData_GetWantVisible returns value of ImGuiPlatformImeData.WantVisible
//
// A widget wants the IME to be visible
func (self *PlatformImeData) WantVisible() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiPlatformImeData_GetWantVisible(internal.ReinterpretCast[*C.ImGuiPlatformImeData](selfArg)) == C.bool(true)
}

// ImGuiPlatformImeData_SetInputPos sets value of ImGuiPlatformImeData.InputPos
//
// Position of the input cursor
func (self PlatformImeData) SetInputPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformImeData_SetInputPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiPlatformImeData_GetInputPos returns value of ImGuiPlatformImeData.InputPos
//
// Position of the input cursor
func (self *PlatformImeData) InputPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiPlatformImeData_GetInputPos(internal.ReinterpretCast[*C.ImGuiPlatformImeData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiPlatformImeData_SetInputLineHeight sets value of ImGuiPlatformImeData.InputLineHeight
//
// Line height
func (self PlatformImeData) SetInputLineHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformImeData_SetInputLineHeight(selfArg, C.float(v))
}

// ImGuiPlatformImeData_GetInputLineHeight returns value of ImGuiPlatformImeData.InputLineHeight
//
// Line height
func (self *PlatformImeData) InputLineHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiPlatformImeData_GetInputLineHeight(internal.ReinterpretCast[*C.ImGuiPlatformImeData](selfArg)))
}

// ImGuiPlatformMonitor_SetMainPos sets value of ImGuiPlatformMonitor.MainPos
//
// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
func (self PlatformMonitor) SetMainPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetMainPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiPlatformMonitor_GetMainPos returns value of ImGuiPlatformMonitor.MainPos
//
// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
func (self *PlatformMonitor) MainPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiPlatformMonitor_GetMainPos(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiPlatformMonitor_SetMainSize sets value of ImGuiPlatformMonitor.MainSize
//
// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
func (self PlatformMonitor) SetMainSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetMainSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiPlatformMonitor_GetMainSize returns value of ImGuiPlatformMonitor.MainSize
//
// Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
func (self *PlatformMonitor) MainSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiPlatformMonitor_GetMainSize(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiPlatformMonitor_SetWorkPos sets value of ImGuiPlatformMonitor.WorkPos
//
// Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
func (self PlatformMonitor) SetWorkPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetWorkPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiPlatformMonitor_GetWorkPos returns value of ImGuiPlatformMonitor.WorkPos
//
// Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
func (self *PlatformMonitor) WorkPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiPlatformMonitor_GetWorkPos(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiPlatformMonitor_SetWorkSize sets value of ImGuiPlatformMonitor.WorkSize
//
// Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
func (self PlatformMonitor) SetWorkSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetWorkSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiPlatformMonitor_GetWorkSize returns value of ImGuiPlatformMonitor.WorkSize
//
// Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
func (self *PlatformMonitor) WorkSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiPlatformMonitor_GetWorkSize(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiPlatformMonitor_SetDpiScale sets value of ImGuiPlatformMonitor.DpiScale
//
// 1.0f = 96 DPI
func (self PlatformMonitor) SetDpiScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetDpiScale(selfArg, C.float(v))
}

// ImGuiPlatformMonitor_GetDpiScale returns value of ImGuiPlatformMonitor.DpiScale
//
// 1.0f = 96 DPI
func (self *PlatformMonitor) DpiScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiPlatformMonitor_GetDpiScale(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](selfArg)))
}

// ImGuiPlatformMonitor_SetPlatformHandle sets value of ImGuiPlatformMonitor.PlatformHandle
//
// Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
func (self PlatformMonitor) SetPlatformHandle(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPlatformMonitor_SetPlatformHandle(selfArg, C.uintptr_t(v))
}

// ImGuiPlatformMonitor_GetPlatformHandle returns value of ImGuiPlatformMonitor.PlatformHandle
//
// Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
func (self *PlatformMonitor) PlatformHandle() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiPlatformMonitor_GetPlatformHandle(internal.ReinterpretCast[*C.ImGuiPlatformMonitor](selfArg)))
}

// ImGuiPopupData_SetPopupId sets value of ImGuiPopupData.PopupId
//
// Set on OpenPopup()
func (self PopupData) SetPopupId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetPopupId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiPopupData_GetPopupId returns value of ImGuiPopupData.PopupId
//
// Set on OpenPopup()
func (self *PopupData) PopupId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiPopupData_GetPopupId(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg))
		return &result
	}())
}

// ImGuiPopupData_SetWindow sets value of ImGuiPopupData.Window
//
// Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
func (self PopupData) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiPopupData_GetWindow returns value of ImGuiPopupData.Window
//
// Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
func (self *PopupData) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiPopupData_GetWindow(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg)))
}

// ImGuiPopupData_SetRestoreNavWindow sets value of ImGuiPopupData.RestoreNavWindow
//
// Set on OpenPopup(), a NavWindow that will be restored on popup close
func (self PopupData) SetRestoreNavWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetRestoreNavWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiPopupData_GetRestoreNavWindow returns value of ImGuiPopupData.RestoreNavWindow
//
// Set on OpenPopup(), a NavWindow that will be restored on popup close
func (self *PopupData) RestoreNavWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiPopupData_GetRestoreNavWindow(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg)))
}

// ImGuiPopupData_SetParentNavLayer sets value of ImGuiPopupData.ParentNavLayer
//
// Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
func (self PopupData) SetParentNavLayer(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetParentNavLayer(selfArg, C.int(v))
}

// ImGuiPopupData_GetParentNavLayer returns value of ImGuiPopupData.ParentNavLayer
//
// Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
func (self *PopupData) ParentNavLayer() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPopupData_GetParentNavLayer(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg)))
}

// ImGuiPopupData_SetOpenFrameCount sets value of ImGuiPopupData.OpenFrameCount
//
// Set on OpenPopup()
func (self PopupData) SetOpenFrameCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenFrameCount(selfArg, C.int(v))
}

// ImGuiPopupData_GetOpenFrameCount returns value of ImGuiPopupData.OpenFrameCount
//
// Set on OpenPopup()
func (self *PopupData) OpenFrameCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPopupData_GetOpenFrameCount(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg)))
}

// ImGuiPopupData_SetOpenParentId sets value of ImGuiPopupData.OpenParentId
//
// Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
func (self PopupData) SetOpenParentId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenParentId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiPopupData_GetOpenParentId returns value of ImGuiPopupData.OpenParentId
//
// Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
func (self *PopupData) OpenParentId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiPopupData_GetOpenParentId(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg))
		return &result
	}())
}

// ImGuiPopupData_SetOpenPopupPos sets value of ImGuiPopupData.OpenPopupPos
//
// Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
func (self PopupData) SetOpenPopupPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenPopupPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiPopupData_GetOpenPopupPos returns value of ImGuiPopupData.OpenPopupPos
//
// Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
func (self *PopupData) OpenPopupPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiPopupData_GetOpenPopupPos(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiPopupData_SetOpenMousePos sets value of ImGuiPopupData.OpenMousePos
//
// Set on OpenPopup(), copy of mouse position at the time of opening popup
func (self PopupData) SetOpenMousePos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPopupData_SetOpenMousePos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiPopupData_GetOpenMousePos returns value of ImGuiPopupData.OpenMousePos
//
// Set on OpenPopup(), copy of mouse position at the time of opening popup
func (self *PopupData) OpenMousePos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiPopupData_GetOpenMousePos(internal.ReinterpretCast[*C.ImGuiPopupData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiPtrOrIndex_SetPtr sets value of ImGuiPtrOrIndex.Ptr
//
// Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
func (self PtrOrIndex) SetPtr(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPtrOrIndex_SetPtr(selfArg, C.uintptr_t(v))
}

// ImGuiPtrOrIndex_GetPtr returns value of ImGuiPtrOrIndex.Ptr
//
// Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
func (self *PtrOrIndex) Ptr() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiPtrOrIndex_GetPtr(internal.ReinterpretCast[*C.ImGuiPtrOrIndex](selfArg)))
}

// ImGuiPtrOrIndex_SetIndex sets value of ImGuiPtrOrIndex.Index
//
// Usually index in a main pool.
func (self PtrOrIndex) SetIndex(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiPtrOrIndex_SetIndex(selfArg, C.int(v))
}

// ImGuiPtrOrIndex_GetIndex returns value of ImGuiPtrOrIndex.Index
//
// Usually index in a main pool.
func (self *PtrOrIndex) Index() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiPtrOrIndex_GetIndex(internal.ReinterpretCast[*C.ImGuiPtrOrIndex](selfArg)))
}

// ImGuiSelectionBasicStorage_SetSize sets value of ImGuiSelectionBasicStorage.Size
//
//	// Members
//	     // Number of selected items, maintained by this helper.
func (self SelectionBasicStorage) SetSize(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionBasicStorage_SetSize(selfArg, C.int(v))
}

// ImGuiSelectionBasicStorage_GetSize returns value of ImGuiSelectionBasicStorage.Size
//
//	// Members
//	     // Number of selected items, maintained by this helper.
func (self *SelectionBasicStorage) Size() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiSelectionBasicStorage_GetSize(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg)))
}

// ImGuiSelectionBasicStorage_SetPreserveOrder sets value of ImGuiSelectionBasicStorage.PreserveOrder
//
// = false  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)
func (self SelectionBasicStorage) SetPreserveOrder(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionBasicStorage_SetPreserveOrder(selfArg, C.bool(v))
}

// ImGuiSelectionBasicStorage_GetPreserveOrder returns value of ImGuiSelectionBasicStorage.PreserveOrder
//
// = false  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)
func (self *SelectionBasicStorage) PreserveOrder() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiSelectionBasicStorage_GetPreserveOrder(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg)) == C.bool(true)
}

// ImGuiSelectionBasicStorage_SetUserData sets value of ImGuiSelectionBasicStorage.UserData
//
// = NULL   // User data for use by adapter function        // e.g. selection.UserData = (void*)my_items;
func (self SelectionBasicStorage) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionBasicStorage_SetUserData(selfArg, C.uintptr_t(v))
}

// ImGuiSelectionBasicStorage_GetUserData returns value of ImGuiSelectionBasicStorage.UserData
//
// = NULL   // User data for use by adapter function        // e.g. selection.UserData = (void*)my_items;
func (self *SelectionBasicStorage) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiSelectionBasicStorage_GetUserData(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg)))
}

// ImGuiSelectionBasicStorage_Set_SelectionOrder sets value of ImGuiSelectionBasicStorage._SelectionOrder
//
// [Internal] Increasing counter to store selection order
func (self SelectionBasicStorage) SetSelectionOrder(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionBasicStorage_Set_SelectionOrder(selfArg, C.int(v))
}

// ImGuiSelectionBasicStorage_Get_SelectionOrder returns value of ImGuiSelectionBasicStorage._SelectionOrder
//
// [Internal] Increasing counter to store selection order
func (self *SelectionBasicStorage) SelectionOrder() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiSelectionBasicStorage_Get_SelectionOrder(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg)))
}

// ImGuiSelectionBasicStorage_Set_Storage sets value of ImGuiSelectionBasicStorage._Storage
//
// [Internal] Selection set. Think of this as similar to e.g. std::set<ImGuiID>. Prefer not accessing directly: iterate with GetNextSelectedItem().
func (self SelectionBasicStorage) SetStorage(v Storage) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionBasicStorage_Set_Storage(selfArg, internal.ReinterpretCast[C.ImGuiStorage](vArg))
}

// ImGuiSelectionBasicStorage_Get_Storage returns value of ImGuiSelectionBasicStorage._Storage
//
// [Internal] Selection set. Think of this as similar to e.g. std::set<ImGuiID>. Prefer not accessing directly: iterate with GetNextSelectedItem().
func (self *SelectionBasicStorage) Storage() Storage {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewStorageFromC(func() *C.ImGuiStorage {
		result := C.wrap_ImGuiSelectionBasicStorage_Get_Storage(internal.ReinterpretCast[*C.ImGuiSelectionBasicStorage](selfArg))
		return &result
	}())
}

// ImGuiSelectionExternalStorage_SetUserData sets value of ImGuiSelectionExternalStorage.UserData
//
//	// Members
//
// User data for use by adapter function                                // e.g. selection.UserData = (void*)my_items;
func (self SelectionExternalStorage) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionExternalStorage_SetUserData(selfArg, C.uintptr_t(v))
}

// ImGuiSelectionExternalStorage_GetUserData returns value of ImGuiSelectionExternalStorage.UserData
//
//	// Members
//
// User data for use by adapter function                                // e.g. selection.UserData = (void*)my_items;
func (self *SelectionExternalStorage) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiSelectionExternalStorage_GetUserData(internal.ReinterpretCast[*C.ImGuiSelectionExternalStorage](selfArg)))
}

// ImGuiSelectionRequest_SetType sets value of ImGuiSelectionRequest.Type
//
//	   //------------------------------------------// BeginMultiSelect / EndMultiSelect
//	ms:w, app:r     /  ms:w, app:r   // Request type. You'll most often receive 1 Clear + 1 SetRange with a single-item range.
func (self SelectionRequest) SetType(v SelectionRequestType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionRequest_SetType(selfArg, C.ImGuiSelectionRequestType(v))
}

// ImGuiSelectionRequest_GetType returns value of ImGuiSelectionRequest.Type
//
//	   //------------------------------------------// BeginMultiSelect / EndMultiSelect
//	ms:w, app:r     /  ms:w, app:r   // Request type. You'll most often receive 1 Clear + 1 SetRange with a single-item range.
func (self *SelectionRequest) Type() SelectionRequestType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return SelectionRequestType(C.wrap_ImGuiSelectionRequest_GetType(internal.ReinterpretCast[*C.ImGuiSelectionRequest](selfArg)))
}

// ImGuiSelectionRequest_SetSelected sets value of ImGuiSelectionRequest.Selected
//
//	ms:w, app:r     /  ms:w, app:r   // Parameter for SetAll/SetRange requests (true = select, false = unselect)
func (self SelectionRequest) SetSelected(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionRequest_SetSelected(selfArg, C.bool(v))
}

// ImGuiSelectionRequest_GetSelected returns value of ImGuiSelectionRequest.Selected
//
//	ms:w, app:r     /  ms:w, app:r   // Parameter for SetAll/SetRange requests (true = select, false = unselect)
func (self *SelectionRequest) Selected() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiSelectionRequest_GetSelected(internal.ReinterpretCast[*C.ImGuiSelectionRequest](selfArg)) == C.bool(true)
}

// ImGuiSelectionRequest_SetRangeDirection sets value of ImGuiSelectionRequest.RangeDirection
//
//	/  ms:w  app:r   // Parameter for SetRange request: +1 when RangeFirstItem comes before RangeLastItem, -1 otherwise. Useful if you want to preserve selection order on a backward Shift+Click.
func (self SelectionRequest) SetRangeDirection(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionRequest_SetRangeDirection(selfArg, C.ImS8(v))
}

// ImGuiSelectionRequest_GetRangeDirection returns value of ImGuiSelectionRequest.RangeDirection
//
//	/  ms:w  app:r   // Parameter for SetRange request: +1 when RangeFirstItem comes before RangeLastItem, -1 otherwise. Useful if you want to preserve selection order on a backward Shift+Click.
func (self *SelectionRequest) RangeDirection() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiSelectionRequest_GetRangeDirection(internal.ReinterpretCast[*C.ImGuiSelectionRequest](selfArg)))
}

// ImGuiSelectionRequest_SetRangeFirstItem sets value of ImGuiSelectionRequest.RangeFirstItem
//
//	/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from top to bottom).
func (self SelectionRequest) SetRangeFirstItem(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionRequest_SetRangeFirstItem(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiSelectionRequest_GetRangeFirstItem returns value of ImGuiSelectionRequest.RangeFirstItem
//
//	/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from top to bottom).
func (self *SelectionRequest) RangeFirstItem() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiSelectionRequest_GetRangeFirstItem(internal.ReinterpretCast[*C.ImGuiSelectionRequest](selfArg))
		return &result
	}())
}

// ImGuiSelectionRequest_SetRangeLastItem sets value of ImGuiSelectionRequest.RangeLastItem
//
//	/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from bottom to top). Inclusive!
func (self SelectionRequest) SetRangeLastItem(v SelectionUserData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSelectionRequest_SetRangeLastItem(selfArg, internal.ReinterpretCast[C.ImGuiSelectionUserData](vArg))
}

// ImGuiSelectionRequest_GetRangeLastItem returns value of ImGuiSelectionRequest.RangeLastItem
//
//	/  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from bottom to top). Inclusive!
func (self *SelectionRequest) RangeLastItem() SelectionUserData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewSelectionUserDataFromC(func() *C.ImGuiSelectionUserData {
		result := C.wrap_ImGuiSelectionRequest_GetRangeLastItem(internal.ReinterpretCast[*C.ImGuiSelectionRequest](selfArg))
		return &result
	}())
}

// ImGuiSettingsHandler_SetTypeName sets value of ImGuiSettingsHandler.TypeName
//
// Short description stored in .ini file. Disallowed characters: '[' ']'
func (self SettingsHandler) SetTypeName(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSettingsHandler_SetTypeName(selfArg, vArg)
}

// ImGuiSettingsHandler_GetTypeName returns value of ImGuiSettingsHandler.TypeName
//
// Short description stored in .ini file. Disallowed characters: '[' ']'
func (self *SettingsHandler) TypeName() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiSettingsHandler_GetTypeName(internal.ReinterpretCast[*C.ImGuiSettingsHandler](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiSettingsHandler_SetTypeHash sets value of ImGuiSettingsHandler.TypeHash
//
// == ImHashStr(TypeName)
func (self SettingsHandler) SetTypeHash(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSettingsHandler_SetTypeHash(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiSettingsHandler_GetTypeHash returns value of ImGuiSettingsHandler.TypeHash
//
// == ImHashStr(TypeName)
func (self *SettingsHandler) TypeHash() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiSettingsHandler_GetTypeHash(internal.ReinterpretCast[*C.ImGuiSettingsHandler](selfArg))
		return &result
	}())
}

// ImGuiSettingsHandler_SetUserData sets value of ImGuiSettingsHandler.UserData
func (self SettingsHandler) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSettingsHandler_SetUserData(selfArg, C.uintptr_t(v))
}

// ImGuiSettingsHandler_GetUserData returns value of ImGuiSettingsHandler.UserData
func (self *SettingsHandler) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiSettingsHandler_GetUserData(internal.ReinterpretCast[*C.ImGuiSettingsHandler](selfArg)))
}

// ImGuiShrinkWidthItem_SetIndex sets value of ImGuiShrinkWidthItem.Index
func (self ShrinkWidthItem) SetIndex(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiShrinkWidthItem_SetIndex(selfArg, C.int(v))
}

// ImGuiShrinkWidthItem_GetIndex returns value of ImGuiShrinkWidthItem.Index
func (self *ShrinkWidthItem) Index() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiShrinkWidthItem_GetIndex(internal.ReinterpretCast[*C.ImGuiShrinkWidthItem](selfArg)))
}

// ImGuiShrinkWidthItem_SetWidth sets value of ImGuiShrinkWidthItem.Width
func (self ShrinkWidthItem) SetWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiShrinkWidthItem_SetWidth(selfArg, C.float(v))
}

// ImGuiShrinkWidthItem_GetWidth returns value of ImGuiShrinkWidthItem.Width
func (self *ShrinkWidthItem) Width() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiShrinkWidthItem_GetWidth(internal.ReinterpretCast[*C.ImGuiShrinkWidthItem](selfArg)))
}

// ImGuiShrinkWidthItem_SetInitialWidth sets value of ImGuiShrinkWidthItem.InitialWidth
func (self ShrinkWidthItem) SetInitialWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiShrinkWidthItem_SetInitialWidth(selfArg, C.float(v))
}

// ImGuiShrinkWidthItem_GetInitialWidth returns value of ImGuiShrinkWidthItem.InitialWidth
func (self *ShrinkWidthItem) InitialWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiShrinkWidthItem_GetInitialWidth(internal.ReinterpretCast[*C.ImGuiShrinkWidthItem](selfArg)))
}

// ImGuiSizeCallbackData_SetUserData sets value of ImGuiSizeCallbackData.UserData
//
// Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).
func (self SizeCallbackData) SetUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetUserData(selfArg, C.uintptr_t(v))
}

// ImGuiSizeCallbackData_GetUserData returns value of ImGuiSizeCallbackData.UserData
//
// Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).
func (self *SizeCallbackData) UserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiSizeCallbackData_GetUserData(internal.ReinterpretCast[*C.ImGuiSizeCallbackData](selfArg)))
}

// ImGuiSizeCallbackData_SetPos sets value of ImGuiSizeCallbackData.Pos
//
// Read-only.   Window position, for reference.
func (self SizeCallbackData) SetPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiSizeCallbackData_GetPos returns value of ImGuiSizeCallbackData.Pos
//
// Read-only.   Window position, for reference.
func (self *SizeCallbackData) Pos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiSizeCallbackData_GetPos(internal.ReinterpretCast[*C.ImGuiSizeCallbackData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiSizeCallbackData_SetCurrentSize sets value of ImGuiSizeCallbackData.CurrentSize
//
// Read-only.   Current window size.
func (self SizeCallbackData) SetCurrentSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetCurrentSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiSizeCallbackData_GetCurrentSize returns value of ImGuiSizeCallbackData.CurrentSize
//
// Read-only.   Current window size.
func (self *SizeCallbackData) CurrentSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiSizeCallbackData_GetCurrentSize(internal.ReinterpretCast[*C.ImGuiSizeCallbackData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiSizeCallbackData_SetDesiredSize sets value of ImGuiSizeCallbackData.DesiredSize
//
// Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
func (self SizeCallbackData) SetDesiredSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiSizeCallbackData_SetDesiredSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiSizeCallbackData_GetDesiredSize returns value of ImGuiSizeCallbackData.DesiredSize
//
// Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
func (self *SizeCallbackData) DesiredSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiSizeCallbackData_GetDesiredSize(internal.ReinterpretCast[*C.ImGuiSizeCallbackData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStackLevelInfo_SetID sets value of ImGuiStackLevelInfo.ID
func (self StackLevelInfo) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiStackLevelInfo_GetID returns value of ImGuiStackLevelInfo.ID
func (self *StackLevelInfo) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiStackLevelInfo_GetID(internal.ReinterpretCast[*C.ImGuiStackLevelInfo](selfArg))
		return &result
	}())
}

// ImGuiStackLevelInfo_SetQueryFrameCount sets value of ImGuiStackLevelInfo.QueryFrameCount
//
// >= 1: Query in progress
func (self StackLevelInfo) SetQueryFrameCount(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetQueryFrameCount(selfArg, C.ImS8(v))
}

// ImGuiStackLevelInfo_GetQueryFrameCount returns value of ImGuiStackLevelInfo.QueryFrameCount
//
// >= 1: Query in progress
func (self *StackLevelInfo) QueryFrameCount() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiStackLevelInfo_GetQueryFrameCount(internal.ReinterpretCast[*C.ImGuiStackLevelInfo](selfArg)))
}

// ImGuiStackLevelInfo_SetQuerySuccess sets value of ImGuiStackLevelInfo.QuerySuccess
//
// Obtained result from DebugHookIdInfo()
func (self StackLevelInfo) SetQuerySuccess(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetQuerySuccess(selfArg, C.bool(v))
}

// ImGuiStackLevelInfo_GetQuerySuccess returns value of ImGuiStackLevelInfo.QuerySuccess
//
// Obtained result from DebugHookIdInfo()
func (self *StackLevelInfo) QuerySuccess() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStackLevelInfo_GetQuerySuccess(internal.ReinterpretCast[*C.ImGuiStackLevelInfo](selfArg)) == C.bool(true)
}

// ImGuiStackLevelInfo_SetDataType sets value of ImGuiStackLevelInfo.DataType
func (self StackLevelInfo) SetDataType(v DataType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetDataType(selfArg, C.ImGuiDataType(v))
}

// ImGuiStackLevelInfo_GetDataType returns value of ImGuiStackLevelInfo.DataType
func (self *StackLevelInfo) DataType() DataType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DataType(C.wrap_ImGuiStackLevelInfo_GetDataType(internal.ReinterpretCast[*C.ImGuiStackLevelInfo](selfArg)))
}

// ImGuiStackLevelInfo_SetDesc sets value of ImGuiStackLevelInfo.Desc[57]
//
// Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.
func (self StackLevelInfo) SetDesc(v *[57]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStackLevelInfo_SetDesc(selfArg, (*C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = rune(vV)
	}
}

// ImGuiStackLevelInfo_GetDesc returns value of ImGuiStackLevelInfo.Desc[57]
//
// Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.
func (self *StackLevelInfo) Desc() [57]rune {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [57]rune {
		result := [57]rune{}
		resultMirr := C.wrap_ImGuiStackLevelInfo_GetDesc(internal.ReinterpretCast[*C.ImGuiStackLevelInfo](selfArg))
		for i := range result {
			result[i] = rune(C.cimgui_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiStorage_SetData sets value of ImGuiStorage.Data
//
//	// [Internal]
func (self Storage) SetData(v vectors.Vector[StoragePair]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiStoragePair)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiStoragePair](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStorage_SetData(selfArg, *vVecArg)
}

// ImGuiStorage_GetData returns value of ImGuiStorage.Data
//
//	// [Internal]
func (self *Storage) Data() vectors.Vector[StoragePair] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiStorage_GetData(internal.ReinterpretCast[*C.ImGuiStorage](selfArg)).Size, C.wrap_ImGuiStorage_GetData(internal.ReinterpretCast[*C.ImGuiStorage](selfArg)).Capacity, NewStoragePairFromC(C.wrap_ImGuiStorage_GetData(internal.ReinterpretCast[*C.ImGuiStorage](selfArg)).Data))
}

// ImGuiStoragePair_SetKey sets value of ImGuiStoragePair.key
func (self StoragePair) SetKey(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStoragePair_SetKey(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiStoragePair_GetKey returns value of ImGuiStoragePair.key
func (self *StoragePair) Key() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiStoragePair_GetKey(internal.ReinterpretCast[*C.ImGuiStoragePair](selfArg))
		return &result
	}())
}

// ImGuiStyle_SetAlpha sets value of ImGuiStyle.Alpha
//
// Global alpha applies to everything in Dear ImGui.
func (self Style) SetAlpha(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAlpha(selfArg, C.float(v))
}

// ImGuiStyle_GetAlpha returns value of ImGuiStyle.Alpha
//
// Global alpha applies to everything in Dear ImGui.
func (self *Style) Alpha() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetAlpha(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetDisabledAlpha sets value of ImGuiStyle.DisabledAlpha
//
// Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
func (self Style) SetDisabledAlpha(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDisabledAlpha(selfArg, C.float(v))
}

// ImGuiStyle_GetDisabledAlpha returns value of ImGuiStyle.DisabledAlpha
//
// Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
func (self *Style) DisabledAlpha() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetDisabledAlpha(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetWindowPadding sets value of ImGuiStyle.WindowPadding
//
// Padding within a window.
func (self Style) SetWindowPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetWindowPadding returns value of ImGuiStyle.WindowPadding
//
// Padding within a window.
func (self *Style) WindowPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetWindowPadding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetWindowRounding sets value of ImGuiStyle.WindowRounding
//
// Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
func (self Style) SetWindowRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowRounding(selfArg, C.float(v))
}

// ImGuiStyle_GetWindowRounding returns value of ImGuiStyle.WindowRounding
//
// Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
func (self *Style) WindowRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetWindowRounding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetWindowBorderSize sets value of ImGuiStyle.WindowBorderSize
//
// Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self Style) SetWindowBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowBorderSize(selfArg, C.float(v))
}

// ImGuiStyle_GetWindowBorderSize returns value of ImGuiStyle.WindowBorderSize
//
// Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self *Style) WindowBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetWindowBorderSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetWindowMinSize sets value of ImGuiStyle.WindowMinSize
//
// Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().
func (self Style) SetWindowMinSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowMinSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetWindowMinSize returns value of ImGuiStyle.WindowMinSize
//
// Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().
func (self *Style) WindowMinSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetWindowMinSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetWindowTitleAlign sets value of ImGuiStyle.WindowTitleAlign
//
// Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
func (self Style) SetWindowTitleAlign(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowTitleAlign(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetWindowTitleAlign returns value of ImGuiStyle.WindowTitleAlign
//
// Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
func (self *Style) WindowTitleAlign() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetWindowTitleAlign(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetWindowMenuButtonPosition sets value of ImGuiStyle.WindowMenuButtonPosition
//
// Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.
func (self Style) SetWindowMenuButtonPosition(v Dir) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetWindowMenuButtonPosition(selfArg, C.ImGuiDir(v))
}

// ImGuiStyle_GetWindowMenuButtonPosition returns value of ImGuiStyle.WindowMenuButtonPosition
//
// Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.
func (self *Style) WindowMenuButtonPosition() Dir {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiStyle_GetWindowMenuButtonPosition(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetChildRounding sets value of ImGuiStyle.ChildRounding
//
// Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
func (self Style) SetChildRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetChildRounding(selfArg, C.float(v))
}

// ImGuiStyle_GetChildRounding returns value of ImGuiStyle.ChildRounding
//
// Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
func (self *Style) ChildRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetChildRounding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetChildBorderSize sets value of ImGuiStyle.ChildBorderSize
//
// Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self Style) SetChildBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetChildBorderSize(selfArg, C.float(v))
}

// ImGuiStyle_GetChildBorderSize returns value of ImGuiStyle.ChildBorderSize
//
// Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self *Style) ChildBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetChildBorderSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetPopupRounding sets value of ImGuiStyle.PopupRounding
//
// Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
func (self Style) SetPopupRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetPopupRounding(selfArg, C.float(v))
}

// ImGuiStyle_GetPopupRounding returns value of ImGuiStyle.PopupRounding
//
// Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
func (self *Style) PopupRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetPopupRounding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetPopupBorderSize sets value of ImGuiStyle.PopupBorderSize
//
// Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self Style) SetPopupBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetPopupBorderSize(selfArg, C.float(v))
}

// ImGuiStyle_GetPopupBorderSize returns value of ImGuiStyle.PopupBorderSize
//
// Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self *Style) PopupBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetPopupBorderSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetFramePadding sets value of ImGuiStyle.FramePadding
//
// Padding within a framed rectangle (used by most widgets).
func (self Style) SetFramePadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetFramePadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetFramePadding returns value of ImGuiStyle.FramePadding
//
// Padding within a framed rectangle (used by most widgets).
func (self *Style) FramePadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetFramePadding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetFrameRounding sets value of ImGuiStyle.FrameRounding
//
// Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
func (self Style) SetFrameRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetFrameRounding(selfArg, C.float(v))
}

// ImGuiStyle_GetFrameRounding returns value of ImGuiStyle.FrameRounding
//
// Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
func (self *Style) FrameRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetFrameRounding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetFrameBorderSize sets value of ImGuiStyle.FrameBorderSize
//
// Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self Style) SetFrameBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetFrameBorderSize(selfArg, C.float(v))
}

// ImGuiStyle_GetFrameBorderSize returns value of ImGuiStyle.FrameBorderSize
//
// Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
func (self *Style) FrameBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetFrameBorderSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetItemSpacing sets value of ImGuiStyle.ItemSpacing
//
// Horizontal and vertical spacing between widgets/lines.
func (self Style) SetItemSpacing(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetItemSpacing(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetItemSpacing returns value of ImGuiStyle.ItemSpacing
//
// Horizontal and vertical spacing between widgets/lines.
func (self *Style) ItemSpacing() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetItemSpacing(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetItemInnerSpacing sets value of ImGuiStyle.ItemInnerSpacing
//
// Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
func (self Style) SetItemInnerSpacing(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetItemInnerSpacing(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetItemInnerSpacing returns value of ImGuiStyle.ItemInnerSpacing
//
// Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
func (self *Style) ItemInnerSpacing() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetItemInnerSpacing(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetCellPadding sets value of ImGuiStyle.CellPadding
//
// Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
func (self Style) SetCellPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetCellPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetCellPadding returns value of ImGuiStyle.CellPadding
//
// Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
func (self *Style) CellPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetCellPadding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetTouchExtraPadding sets value of ImGuiStyle.TouchExtraPadding
//
// Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
func (self Style) SetTouchExtraPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTouchExtraPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetTouchExtraPadding returns value of ImGuiStyle.TouchExtraPadding
//
// Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
func (self *Style) TouchExtraPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetTouchExtraPadding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetIndentSpacing sets value of ImGuiStyle.IndentSpacing
//
// Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
func (self Style) SetIndentSpacing(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetIndentSpacing(selfArg, C.float(v))
}

// ImGuiStyle_GetIndentSpacing returns value of ImGuiStyle.IndentSpacing
//
// Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
func (self *Style) IndentSpacing() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetIndentSpacing(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetColumnsMinSpacing sets value of ImGuiStyle.ColumnsMinSpacing
//
// Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
func (self Style) SetColumnsMinSpacing(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetColumnsMinSpacing(selfArg, C.float(v))
}

// ImGuiStyle_GetColumnsMinSpacing returns value of ImGuiStyle.ColumnsMinSpacing
//
// Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
func (self *Style) ColumnsMinSpacing() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetColumnsMinSpacing(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetScrollbarSize sets value of ImGuiStyle.ScrollbarSize
//
// Width of the vertical scrollbar, Height of the horizontal scrollbar.
func (self Style) SetScrollbarSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetScrollbarSize(selfArg, C.float(v))
}

// ImGuiStyle_GetScrollbarSize returns value of ImGuiStyle.ScrollbarSize
//
// Width of the vertical scrollbar, Height of the horizontal scrollbar.
func (self *Style) ScrollbarSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetScrollbarSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetScrollbarRounding sets value of ImGuiStyle.ScrollbarRounding
//
// Radius of grab corners for scrollbar.
func (self Style) SetScrollbarRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetScrollbarRounding(selfArg, C.float(v))
}

// ImGuiStyle_GetScrollbarRounding returns value of ImGuiStyle.ScrollbarRounding
//
// Radius of grab corners for scrollbar.
func (self *Style) ScrollbarRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetScrollbarRounding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetGrabMinSize sets value of ImGuiStyle.GrabMinSize
//
// Minimum width/height of a grab box for slider/scrollbar.
func (self Style) SetGrabMinSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetGrabMinSize(selfArg, C.float(v))
}

// ImGuiStyle_GetGrabMinSize returns value of ImGuiStyle.GrabMinSize
//
// Minimum width/height of a grab box for slider/scrollbar.
func (self *Style) GrabMinSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetGrabMinSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetGrabRounding sets value of ImGuiStyle.GrabRounding
//
// Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
func (self Style) SetGrabRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetGrabRounding(selfArg, C.float(v))
}

// ImGuiStyle_GetGrabRounding returns value of ImGuiStyle.GrabRounding
//
// Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
func (self *Style) GrabRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetGrabRounding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetLogSliderDeadzone sets value of ImGuiStyle.LogSliderDeadzone
//
// The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
func (self Style) SetLogSliderDeadzone(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetLogSliderDeadzone(selfArg, C.float(v))
}

// ImGuiStyle_GetLogSliderDeadzone returns value of ImGuiStyle.LogSliderDeadzone
//
// The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
func (self *Style) LogSliderDeadzone() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetLogSliderDeadzone(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetTabRounding sets value of ImGuiStyle.TabRounding
//
// Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
func (self Style) SetTabRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabRounding(selfArg, C.float(v))
}

// ImGuiStyle_GetTabRounding returns value of ImGuiStyle.TabRounding
//
// Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
func (self *Style) TabRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabRounding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetTabBorderSize sets value of ImGuiStyle.TabBorderSize
//
// Thickness of border around tabs.
func (self Style) SetTabBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabBorderSize(selfArg, C.float(v))
}

// ImGuiStyle_GetTabBorderSize returns value of ImGuiStyle.TabBorderSize
//
// Thickness of border around tabs.
func (self *Style) TabBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabBorderSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetTabMinWidthForCloseButton sets value of ImGuiStyle.TabMinWidthForCloseButton
//
// Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
func (self Style) SetTabMinWidthForCloseButton(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabMinWidthForCloseButton(selfArg, C.float(v))
}

// ImGuiStyle_GetTabMinWidthForCloseButton returns value of ImGuiStyle.TabMinWidthForCloseButton
//
// Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
func (self *Style) TabMinWidthForCloseButton() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabMinWidthForCloseButton(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetTabBarBorderSize sets value of ImGuiStyle.TabBarBorderSize
//
// Thickness of tab-bar separator, which takes on the tab active color to denote focus.
func (self Style) SetTabBarBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabBarBorderSize(selfArg, C.float(v))
}

// ImGuiStyle_GetTabBarBorderSize returns value of ImGuiStyle.TabBarBorderSize
//
// Thickness of tab-bar separator, which takes on the tab active color to denote focus.
func (self *Style) TabBarBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabBarBorderSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetTabBarOverlineSize sets value of ImGuiStyle.TabBarOverlineSize
//
// Thickness of tab-bar overline, which highlights the selected tab-bar.
func (self Style) SetTabBarOverlineSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTabBarOverlineSize(selfArg, C.float(v))
}

// ImGuiStyle_GetTabBarOverlineSize returns value of ImGuiStyle.TabBarOverlineSize
//
// Thickness of tab-bar overline, which highlights the selected tab-bar.
func (self *Style) TabBarOverlineSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTabBarOverlineSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetTableAngledHeadersAngle sets value of ImGuiStyle.TableAngledHeadersAngle
//
// Angle of angled headers (supported values range from -50.0f degrees to +50.0f degrees).
func (self Style) SetTableAngledHeadersAngle(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTableAngledHeadersAngle(selfArg, C.float(v))
}

// ImGuiStyle_GetTableAngledHeadersAngle returns value of ImGuiStyle.TableAngledHeadersAngle
//
// Angle of angled headers (supported values range from -50.0f degrees to +50.0f degrees).
func (self *Style) TableAngledHeadersAngle() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetTableAngledHeadersAngle(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetTableAngledHeadersTextAlign sets value of ImGuiStyle.TableAngledHeadersTextAlign
//
// Alignment of angled headers within the cell
func (self Style) SetTableAngledHeadersTextAlign(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetTableAngledHeadersTextAlign(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetTableAngledHeadersTextAlign returns value of ImGuiStyle.TableAngledHeadersTextAlign
//
// Alignment of angled headers within the cell
func (self *Style) TableAngledHeadersTextAlign() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetTableAngledHeadersTextAlign(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetColorButtonPosition sets value of ImGuiStyle.ColorButtonPosition
//
// Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
func (self Style) SetColorButtonPosition(v Dir) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetColorButtonPosition(selfArg, C.ImGuiDir(v))
}

// ImGuiStyle_GetColorButtonPosition returns value of ImGuiStyle.ColorButtonPosition
//
// Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
func (self *Style) ColorButtonPosition() Dir {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiStyle_GetColorButtonPosition(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetButtonTextAlign sets value of ImGuiStyle.ButtonTextAlign
//
// Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
func (self Style) SetButtonTextAlign(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetButtonTextAlign(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetButtonTextAlign returns value of ImGuiStyle.ButtonTextAlign
//
// Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
func (self *Style) ButtonTextAlign() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetButtonTextAlign(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetSelectableTextAlign sets value of ImGuiStyle.SelectableTextAlign
//
// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
func (self Style) SetSelectableTextAlign(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSelectableTextAlign(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetSelectableTextAlign returns value of ImGuiStyle.SelectableTextAlign
//
// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
func (self *Style) SelectableTextAlign() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetSelectableTextAlign(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetSeparatorTextBorderSize sets value of ImGuiStyle.SeparatorTextBorderSize
//
// Thickness of border in SeparatorText()
func (self Style) SetSeparatorTextBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSeparatorTextBorderSize(selfArg, C.float(v))
}

// ImGuiStyle_GetSeparatorTextBorderSize returns value of ImGuiStyle.SeparatorTextBorderSize
//
// Thickness of border in SeparatorText()
func (self *Style) SeparatorTextBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetSeparatorTextBorderSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetSeparatorTextAlign sets value of ImGuiStyle.SeparatorTextAlign
//
// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
func (self Style) SetSeparatorTextAlign(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSeparatorTextAlign(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetSeparatorTextAlign returns value of ImGuiStyle.SeparatorTextAlign
//
// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
func (self *Style) SeparatorTextAlign() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetSeparatorTextAlign(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetSeparatorTextPadding sets value of ImGuiStyle.SeparatorTextPadding
//
// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
func (self Style) SetSeparatorTextPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetSeparatorTextPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetSeparatorTextPadding returns value of ImGuiStyle.SeparatorTextPadding
//
// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
func (self *Style) SeparatorTextPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetSeparatorTextPadding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetDisplayWindowPadding sets value of ImGuiStyle.DisplayWindowPadding
//
// Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.
func (self Style) SetDisplayWindowPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDisplayWindowPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetDisplayWindowPadding returns value of ImGuiStyle.DisplayWindowPadding
//
// Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.
func (self *Style) DisplayWindowPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetDisplayWindowPadding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetDisplaySafeAreaPadding sets value of ImGuiStyle.DisplaySafeAreaPadding
//
// Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).
func (self Style) SetDisplaySafeAreaPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDisplaySafeAreaPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiStyle_GetDisplaySafeAreaPadding returns value of ImGuiStyle.DisplaySafeAreaPadding
//
// Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).
func (self *Style) DisplaySafeAreaPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiStyle_GetDisplaySafeAreaPadding(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiStyle_SetDockingSeparatorSize sets value of ImGuiStyle.DockingSeparatorSize
//
// Thickness of resizing border between docked windows
func (self Style) SetDockingSeparatorSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetDockingSeparatorSize(selfArg, C.float(v))
}

// ImGuiStyle_GetDockingSeparatorSize returns value of ImGuiStyle.DockingSeparatorSize
//
// Thickness of resizing border between docked windows
func (self *Style) DockingSeparatorSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetDockingSeparatorSize(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetMouseCursorScale sets value of ImGuiStyle.MouseCursorScale
//
// Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.
func (self Style) SetMouseCursorScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetMouseCursorScale(selfArg, C.float(v))
}

// ImGuiStyle_GetMouseCursorScale returns value of ImGuiStyle.MouseCursorScale
//
// Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.
func (self *Style) MouseCursorScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetMouseCursorScale(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetAntiAliasedLines sets value of ImGuiStyle.AntiAliasedLines
//
// Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
func (self Style) SetAntiAliasedLines(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAntiAliasedLines(selfArg, C.bool(v))
}

// ImGuiStyle_GetAntiAliasedLines returns value of ImGuiStyle.AntiAliasedLines
//
// Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
func (self *Style) AntiAliasedLines() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStyle_GetAntiAliasedLines(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)) == C.bool(true)
}

// ImGuiStyle_SetAntiAliasedLinesUseTex sets value of ImGuiStyle.AntiAliasedLinesUseTex
//
// Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).
func (self Style) SetAntiAliasedLinesUseTex(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAntiAliasedLinesUseTex(selfArg, C.bool(v))
}

// ImGuiStyle_GetAntiAliasedLinesUseTex returns value of ImGuiStyle.AntiAliasedLinesUseTex
//
// Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).
func (self *Style) AntiAliasedLinesUseTex() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStyle_GetAntiAliasedLinesUseTex(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)) == C.bool(true)
}

// ImGuiStyle_SetAntiAliasedFill sets value of ImGuiStyle.AntiAliasedFill
//
// Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
func (self Style) SetAntiAliasedFill(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetAntiAliasedFill(selfArg, C.bool(v))
}

// ImGuiStyle_GetAntiAliasedFill returns value of ImGuiStyle.AntiAliasedFill
//
// Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
func (self *Style) AntiAliasedFill() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiStyle_GetAntiAliasedFill(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)) == C.bool(true)
}

// ImGuiStyle_SetCurveTessellationTol sets value of ImGuiStyle.CurveTessellationTol
//
// Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
func (self Style) SetCurveTessellationTol(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetCurveTessellationTol(selfArg, C.float(v))
}

// ImGuiStyle_GetCurveTessellationTol returns value of ImGuiStyle.CurveTessellationTol
//
// Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
func (self *Style) CurveTessellationTol() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetCurveTessellationTol(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetCircleTessellationMaxError sets value of ImGuiStyle.CircleTessellationMaxError
//
// Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
func (self Style) SetCircleTessellationMaxError(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetCircleTessellationMaxError(selfArg, C.float(v))
}

// ImGuiStyle_GetCircleTessellationMaxError returns value of ImGuiStyle.CircleTessellationMaxError
//
// Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
func (self *Style) CircleTessellationMaxError() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetCircleTessellationMaxError(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetColors sets value of ImGuiStyle.Colors[ImGuiCol_COUNT]
func (self Style) SetColors(v *[58]Vec4) {
	vArg := make([]C.ImVec4, len(v))
	for i, vV := range v {
		vArg[i] = internal.ReinterpretCast[C.ImVec4](vV.ToC())
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetColors(selfArg, (*C.ImVec4)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() Vec4 { out := vV; return *(&Vec4{}).FromC(unsafe.Pointer(&out)) }()
	}
}

// ImGuiStyle_GetColors returns value of ImGuiStyle.Colors[ImGuiCol_COUNT]
func (self *Style) Colors() [58]Vec4 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [58]Vec4 {
		result := [58]Vec4{}
		resultMirr := C.wrap_ImGuiStyle_GetColors(internal.ReinterpretCast[*C.ImGuiStyle](selfArg))
		for i := range result {
			result[i] = func() Vec4 {
				out := C.cimgui_ImVec4_GetAtIdx(resultMirr, C.int(i))
				return *(&Vec4{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}

// ImGuiStyle_SetHoverStationaryDelay sets value of ImGuiStyle.HoverStationaryDelay
//
//	// Behaviors
//	// (It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO)
//
// Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
func (self Style) SetHoverStationaryDelay(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverStationaryDelay(selfArg, C.float(v))
}

// ImGuiStyle_GetHoverStationaryDelay returns value of ImGuiStyle.HoverStationaryDelay
//
//	// Behaviors
//	// (It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO)
//
// Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
func (self *Style) HoverStationaryDelay() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetHoverStationaryDelay(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetHoverDelayShort sets value of ImGuiStyle.HoverDelayShort
//
// Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
func (self Style) SetHoverDelayShort(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverDelayShort(selfArg, C.float(v))
}

// ImGuiStyle_GetHoverDelayShort returns value of ImGuiStyle.HoverDelayShort
//
// Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
func (self *Style) HoverDelayShort() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetHoverDelayShort(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetHoverDelayNormal sets value of ImGuiStyle.HoverDelayNormal
//
// Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
func (self Style) SetHoverDelayNormal(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverDelayNormal(selfArg, C.float(v))
}

// ImGuiStyle_GetHoverDelayNormal returns value of ImGuiStyle.HoverDelayNormal
//
// Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
func (self *Style) HoverDelayNormal() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiStyle_GetHoverDelayNormal(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetHoverFlagsForTooltipMouse sets value of ImGuiStyle.HoverFlagsForTooltipMouse
//
// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
func (self Style) SetHoverFlagsForTooltipMouse(v HoveredFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverFlagsForTooltipMouse(selfArg, C.ImGuiHoveredFlags(v))
}

// ImGuiStyle_GetHoverFlagsForTooltipMouse returns value of ImGuiStyle.HoverFlagsForTooltipMouse
//
// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
func (self *Style) HoverFlagsForTooltipMouse() HoveredFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return HoveredFlags(C.wrap_ImGuiStyle_GetHoverFlagsForTooltipMouse(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyle_SetHoverFlagsForTooltipNav sets value of ImGuiStyle.HoverFlagsForTooltipNav
//
// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
func (self Style) SetHoverFlagsForTooltipNav(v HoveredFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyle_SetHoverFlagsForTooltipNav(selfArg, C.ImGuiHoveredFlags(v))
}

// ImGuiStyle_GetHoverFlagsForTooltipNav returns value of ImGuiStyle.HoverFlagsForTooltipNav
//
// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
func (self *Style) HoverFlagsForTooltipNav() HoveredFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return HoveredFlags(C.wrap_ImGuiStyle_GetHoverFlagsForTooltipNav(internal.ReinterpretCast[*C.ImGuiStyle](selfArg)))
}

// ImGuiStyleMod_SetVarIdx sets value of ImGuiStyleMod.VarIdx
func (self StyleMod) SetVarIdx(v StyleVar) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiStyleMod_SetVarIdx(selfArg, C.ImGuiStyleVar(v))
}

// ImGuiStyleMod_GetVarIdx returns value of ImGuiStyleMod.VarIdx
func (self *StyleMod) VarIdx() StyleVar {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return StyleVar(C.wrap_ImGuiStyleMod_GetVarIdx(internal.ReinterpretCast[*C.ImGuiStyleMod](selfArg)))
}

// ImGuiTabBar_SetWindow sets value of ImGuiTabBar.Window
func (self TabBar) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiTabBar_GetWindow returns value of ImGuiTabBar.Window
func (self *TabBar) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiTabBar_GetWindow(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetTabs sets value of ImGuiTabBar.Tabs
func (self TabBar) SetTabs(v vectors.Vector[TabItem]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiTabItem)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiTabItem](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabs(selfArg, *vVecArg)
}

// ImGuiTabBar_GetTabs returns value of ImGuiTabBar.Tabs
func (self *TabBar) Tabs() vectors.Vector[TabItem] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiTabBar_GetTabs(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)).Size, C.wrap_ImGuiTabBar_GetTabs(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)).Capacity, NewTabItemFromC(C.wrap_ImGuiTabBar_GetTabs(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)).Data))
}

// ImGuiTabBar_SetFlags sets value of ImGuiTabBar.Flags
func (self TabBar) SetFlags(v TabBarFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetFlags(selfArg, C.ImGuiTabBarFlags(v))
}

// ImGuiTabBar_GetFlags returns value of ImGuiTabBar.Flags
func (self *TabBar) Flags() TabBarFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TabBarFlags(C.wrap_ImGuiTabBar_GetFlags(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetID sets value of ImGuiTabBar.ID
//
// Zero for tab-bars used by docking
func (self TabBar) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTabBar_GetID returns value of ImGuiTabBar.ID
//
// Zero for tab-bars used by docking
func (self *TabBar) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTabBar_GetID(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return &result
	}())
}

// ImGuiTabBar_SetSelectedTabId sets value of ImGuiTabBar.SelectedTabId
//
// Selected tab/window
func (self TabBar) SetSelectedTabId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetSelectedTabId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTabBar_GetSelectedTabId returns value of ImGuiTabBar.SelectedTabId
//
// Selected tab/window
func (self *TabBar) SelectedTabId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTabBar_GetSelectedTabId(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return &result
	}())
}

// ImGuiTabBar_SetNextSelectedTabId sets value of ImGuiTabBar.NextSelectedTabId
//
// Next selected tab/window. Will also trigger a scrolling animation
func (self TabBar) SetNextSelectedTabId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetNextSelectedTabId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTabBar_GetNextSelectedTabId returns value of ImGuiTabBar.NextSelectedTabId
//
// Next selected tab/window. Will also trigger a scrolling animation
func (self *TabBar) NextSelectedTabId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTabBar_GetNextSelectedTabId(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return &result
	}())
}

// ImGuiTabBar_SetVisibleTabId sets value of ImGuiTabBar.VisibleTabId
//
// Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
func (self TabBar) SetVisibleTabId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetVisibleTabId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTabBar_GetVisibleTabId returns value of ImGuiTabBar.VisibleTabId
//
// Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
func (self *TabBar) VisibleTabId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTabBar_GetVisibleTabId(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return &result
	}())
}

// ImGuiTabBar_SetCurrFrameVisible sets value of ImGuiTabBar.CurrFrameVisible
func (self TabBar) SetCurrFrameVisible(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetCurrFrameVisible(selfArg, C.int(v))
}

// ImGuiTabBar_GetCurrFrameVisible returns value of ImGuiTabBar.CurrFrameVisible
func (self *TabBar) CurrFrameVisible() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabBar_GetCurrFrameVisible(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetPrevFrameVisible sets value of ImGuiTabBar.PrevFrameVisible
func (self TabBar) SetPrevFrameVisible(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetPrevFrameVisible(selfArg, C.int(v))
}

// ImGuiTabBar_GetPrevFrameVisible returns value of ImGuiTabBar.PrevFrameVisible
func (self *TabBar) PrevFrameVisible() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabBar_GetPrevFrameVisible(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetBarRect sets value of ImGuiTabBar.BarRect
func (self TabBar) SetBarRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetBarRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTabBar_GetBarRect returns value of ImGuiTabBar.BarRect
func (self *TabBar) BarRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTabBar_GetBarRect(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTabBar_SetCurrTabsContentsHeight sets value of ImGuiTabBar.CurrTabsContentsHeight
func (self TabBar) SetCurrTabsContentsHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetCurrTabsContentsHeight(selfArg, C.float(v))
}

// ImGuiTabBar_GetCurrTabsContentsHeight returns value of ImGuiTabBar.CurrTabsContentsHeight
func (self *TabBar) CurrTabsContentsHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetCurrTabsContentsHeight(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetPrevTabsContentsHeight sets value of ImGuiTabBar.PrevTabsContentsHeight
//
// Record the height of contents submitted below the tab bar
func (self TabBar) SetPrevTabsContentsHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetPrevTabsContentsHeight(selfArg, C.float(v))
}

// ImGuiTabBar_GetPrevTabsContentsHeight returns value of ImGuiTabBar.PrevTabsContentsHeight
//
// Record the height of contents submitted below the tab bar
func (self *TabBar) PrevTabsContentsHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetPrevTabsContentsHeight(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetWidthAllTabs sets value of ImGuiTabBar.WidthAllTabs
//
// Actual width of all tabs (locked during layout)
func (self TabBar) SetWidthAllTabs(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetWidthAllTabs(selfArg, C.float(v))
}

// ImGuiTabBar_GetWidthAllTabs returns value of ImGuiTabBar.WidthAllTabs
//
// Actual width of all tabs (locked during layout)
func (self *TabBar) WidthAllTabs() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetWidthAllTabs(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetWidthAllTabsIdeal sets value of ImGuiTabBar.WidthAllTabsIdeal
//
// Ideal width if all tabs were visible and not clipped
func (self TabBar) SetWidthAllTabsIdeal(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetWidthAllTabsIdeal(selfArg, C.float(v))
}

// ImGuiTabBar_GetWidthAllTabsIdeal returns value of ImGuiTabBar.WidthAllTabsIdeal
//
// Ideal width if all tabs were visible and not clipped
func (self *TabBar) WidthAllTabsIdeal() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetWidthAllTabsIdeal(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetScrollingAnim sets value of ImGuiTabBar.ScrollingAnim
func (self TabBar) SetScrollingAnim(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingAnim(selfArg, C.float(v))
}

// ImGuiTabBar_GetScrollingAnim returns value of ImGuiTabBar.ScrollingAnim
func (self *TabBar) ScrollingAnim() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingAnim(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetScrollingTarget sets value of ImGuiTabBar.ScrollingTarget
func (self TabBar) SetScrollingTarget(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingTarget(selfArg, C.float(v))
}

// ImGuiTabBar_GetScrollingTarget returns value of ImGuiTabBar.ScrollingTarget
func (self *TabBar) ScrollingTarget() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingTarget(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetScrollingTargetDistToVisibility sets value of ImGuiTabBar.ScrollingTargetDistToVisibility
func (self TabBar) SetScrollingTargetDistToVisibility(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingTargetDistToVisibility(selfArg, C.float(v))
}

// ImGuiTabBar_GetScrollingTargetDistToVisibility returns value of ImGuiTabBar.ScrollingTargetDistToVisibility
func (self *TabBar) ScrollingTargetDistToVisibility() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingTargetDistToVisibility(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetScrollingSpeed sets value of ImGuiTabBar.ScrollingSpeed
func (self TabBar) SetScrollingSpeed(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingSpeed(selfArg, C.float(v))
}

// ImGuiTabBar_GetScrollingSpeed returns value of ImGuiTabBar.ScrollingSpeed
func (self *TabBar) ScrollingSpeed() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingSpeed(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetScrollingRectMinX sets value of ImGuiTabBar.ScrollingRectMinX
func (self TabBar) SetScrollingRectMinX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingRectMinX(selfArg, C.float(v))
}

// ImGuiTabBar_GetScrollingRectMinX returns value of ImGuiTabBar.ScrollingRectMinX
func (self *TabBar) ScrollingRectMinX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingRectMinX(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetScrollingRectMaxX sets value of ImGuiTabBar.ScrollingRectMaxX
func (self TabBar) SetScrollingRectMaxX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetScrollingRectMaxX(selfArg, C.float(v))
}

// ImGuiTabBar_GetScrollingRectMaxX returns value of ImGuiTabBar.ScrollingRectMaxX
func (self *TabBar) ScrollingRectMaxX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetScrollingRectMaxX(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetSeparatorMinX sets value of ImGuiTabBar.SeparatorMinX
func (self TabBar) SetSeparatorMinX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetSeparatorMinX(selfArg, C.float(v))
}

// ImGuiTabBar_GetSeparatorMinX returns value of ImGuiTabBar.SeparatorMinX
func (self *TabBar) SeparatorMinX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetSeparatorMinX(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetSeparatorMaxX sets value of ImGuiTabBar.SeparatorMaxX
func (self TabBar) SetSeparatorMaxX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetSeparatorMaxX(selfArg, C.float(v))
}

// ImGuiTabBar_GetSeparatorMaxX returns value of ImGuiTabBar.SeparatorMaxX
func (self *TabBar) SeparatorMaxX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetSeparatorMaxX(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetReorderRequestTabId sets value of ImGuiTabBar.ReorderRequestTabId
func (self TabBar) SetReorderRequestTabId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetReorderRequestTabId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTabBar_GetReorderRequestTabId returns value of ImGuiTabBar.ReorderRequestTabId
func (self *TabBar) ReorderRequestTabId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTabBar_GetReorderRequestTabId(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return &result
	}())
}

// ImGuiTabBar_SetReorderRequestOffset sets value of ImGuiTabBar.ReorderRequestOffset
func (self TabBar) SetReorderRequestOffset(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetReorderRequestOffset(selfArg, C.ImS16(v))
}

// ImGuiTabBar_GetReorderRequestOffset returns value of ImGuiTabBar.ReorderRequestOffset
func (self *TabBar) ReorderRequestOffset() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTabBar_GetReorderRequestOffset(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetBeginCount sets value of ImGuiTabBar.BeginCount
func (self TabBar) SetBeginCount(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetBeginCount(selfArg, C.ImS8(v))
}

// ImGuiTabBar_GetBeginCount returns value of ImGuiTabBar.BeginCount
func (self *TabBar) BeginCount() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabBar_GetBeginCount(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetWantLayout sets value of ImGuiTabBar.WantLayout
func (self TabBar) SetWantLayout(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetWantLayout(selfArg, C.bool(v))
}

// ImGuiTabBar_GetWantLayout returns value of ImGuiTabBar.WantLayout
func (self *TabBar) WantLayout() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabBar_GetWantLayout(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)) == C.bool(true)
}

// ImGuiTabBar_SetVisibleTabWasSubmitted sets value of ImGuiTabBar.VisibleTabWasSubmitted
func (self TabBar) SetVisibleTabWasSubmitted(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetVisibleTabWasSubmitted(selfArg, C.bool(v))
}

// ImGuiTabBar_GetVisibleTabWasSubmitted returns value of ImGuiTabBar.VisibleTabWasSubmitted
func (self *TabBar) VisibleTabWasSubmitted() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabBar_GetVisibleTabWasSubmitted(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)) == C.bool(true)
}

// ImGuiTabBar_SetTabsAddedNew sets value of ImGuiTabBar.TabsAddedNew
//
// Set to true when a new tab item or button has been added to the tab bar during last frame
func (self TabBar) SetTabsAddedNew(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabsAddedNew(selfArg, C.bool(v))
}

// ImGuiTabBar_GetTabsAddedNew returns value of ImGuiTabBar.TabsAddedNew
//
// Set to true when a new tab item or button has been added to the tab bar during last frame
func (self *TabBar) TabsAddedNew() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabBar_GetTabsAddedNew(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)) == C.bool(true)
}

// ImGuiTabBar_SetTabsActiveCount sets value of ImGuiTabBar.TabsActiveCount
//
// Number of tabs submitted this frame.
func (self TabBar) SetTabsActiveCount(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabsActiveCount(selfArg, C.ImS16(v))
}

// ImGuiTabBar_GetTabsActiveCount returns value of ImGuiTabBar.TabsActiveCount
//
// Number of tabs submitted this frame.
func (self *TabBar) TabsActiveCount() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTabBar_GetTabsActiveCount(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetLastTabItemIdx sets value of ImGuiTabBar.LastTabItemIdx
//
// Index of last BeginTabItem() tab for use by EndTabItem()
func (self TabBar) SetLastTabItemIdx(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetLastTabItemIdx(selfArg, C.ImS16(v))
}

// ImGuiTabBar_GetLastTabItemIdx returns value of ImGuiTabBar.LastTabItemIdx
//
// Index of last BeginTabItem() tab for use by EndTabItem()
func (self *TabBar) LastTabItemIdx() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTabBar_GetLastTabItemIdx(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetItemSpacingY sets value of ImGuiTabBar.ItemSpacingY
func (self TabBar) SetItemSpacingY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetItemSpacingY(selfArg, C.float(v))
}

// ImGuiTabBar_GetItemSpacingY returns value of ImGuiTabBar.ItemSpacingY
func (self *TabBar) ItemSpacingY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabBar_GetItemSpacingY(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg)))
}

// ImGuiTabBar_SetFramePadding sets value of ImGuiTabBar.FramePadding
//
// style.FramePadding locked at the time of BeginTabBar()
func (self TabBar) SetFramePadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetFramePadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiTabBar_GetFramePadding returns value of ImGuiTabBar.FramePadding
//
// style.FramePadding locked at the time of BeginTabBar()
func (self *TabBar) FramePadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiTabBar_GetFramePadding(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTabBar_SetBackupCursorPos sets value of ImGuiTabBar.BackupCursorPos
func (self TabBar) SetBackupCursorPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetBackupCursorPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiTabBar_GetBackupCursorPos returns value of ImGuiTabBar.BackupCursorPos
func (self *TabBar) BackupCursorPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiTabBar_GetBackupCursorPos(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTabBar_SetTabsNames sets value of ImGuiTabBar.TabsNames
//
// For non-docking tab bar we re-append names in a contiguous buffer.
func (self TabBar) SetTabsNames(v TextBuffer) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabBar_SetTabsNames(selfArg, internal.ReinterpretCast[C.ImGuiTextBuffer](vArg))
}

// ImGuiTabBar_GetTabsNames returns value of ImGuiTabBar.TabsNames
//
// For non-docking tab bar we re-append names in a contiguous buffer.
func (self *TabBar) TabsNames() TextBuffer {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextBufferFromC(func() *C.ImGuiTextBuffer {
		result := C.wrap_ImGuiTabBar_GetTabsNames(internal.ReinterpretCast[*C.ImGuiTabBar](selfArg))
		return &result
	}())
}

// ImGuiTabItem_SetID sets value of ImGuiTabItem.ID
func (self TabItem) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTabItem_GetID returns value of ImGuiTabItem.ID
func (self *TabItem) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTabItem_GetID(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg))
		return &result
	}())
}

// ImGuiTabItem_SetFlags sets value of ImGuiTabItem.Flags
func (self TabItem) SetFlags(v TabItemFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetFlags(selfArg, C.ImGuiTabItemFlags(v))
}

// ImGuiTabItem_GetFlags returns value of ImGuiTabItem.Flags
func (self *TabItem) Flags() TabItemFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TabItemFlags(C.wrap_ImGuiTabItem_GetFlags(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetWindow sets value of ImGuiTabItem.Window
//
// When TabItem is part of a DockNode's TabBar, we hold on to a window.
func (self TabItem) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiTabItem_GetWindow returns value of ImGuiTabItem.Window
//
// When TabItem is part of a DockNode's TabBar, we hold on to a window.
func (self *TabItem) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiTabItem_GetWindow(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetLastFrameVisible sets value of ImGuiTabItem.LastFrameVisible
func (self TabItem) SetLastFrameVisible(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetLastFrameVisible(selfArg, C.int(v))
}

// ImGuiTabItem_GetLastFrameVisible returns value of ImGuiTabItem.LastFrameVisible
func (self *TabItem) LastFrameVisible() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabItem_GetLastFrameVisible(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetLastFrameSelected sets value of ImGuiTabItem.LastFrameSelected
//
// This allows us to infer an ordered list of the last activated tabs with little maintenance
func (self TabItem) SetLastFrameSelected(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetLastFrameSelected(selfArg, C.int(v))
}

// ImGuiTabItem_GetLastFrameSelected returns value of ImGuiTabItem.LastFrameSelected
//
// This allows us to infer an ordered list of the last activated tabs with little maintenance
func (self *TabItem) LastFrameSelected() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTabItem_GetLastFrameSelected(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetOffset sets value of ImGuiTabItem.Offset
//
// Position relative to beginning of tab
func (self TabItem) SetOffset(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetOffset(selfArg, C.float(v))
}

// ImGuiTabItem_GetOffset returns value of ImGuiTabItem.Offset
//
// Position relative to beginning of tab
func (self *TabItem) Offset() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetOffset(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetWidth sets value of ImGuiTabItem.Width
//
// Width currently displayed
func (self TabItem) SetWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetWidth(selfArg, C.float(v))
}

// ImGuiTabItem_GetWidth returns value of ImGuiTabItem.Width
//
// Width currently displayed
func (self *TabItem) Width() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetWidth(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetContentWidth sets value of ImGuiTabItem.ContentWidth
//
// Width of label, stored during BeginTabItem() call
func (self TabItem) SetContentWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetContentWidth(selfArg, C.float(v))
}

// ImGuiTabItem_GetContentWidth returns value of ImGuiTabItem.ContentWidth
//
// Width of label, stored during BeginTabItem() call
func (self *TabItem) ContentWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetContentWidth(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetRequestedWidth sets value of ImGuiTabItem.RequestedWidth
//
// Width optionally requested by caller, -1.0f is unused
func (self TabItem) SetRequestedWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetRequestedWidth(selfArg, C.float(v))
}

// ImGuiTabItem_GetRequestedWidth returns value of ImGuiTabItem.RequestedWidth
//
// Width optionally requested by caller, -1.0f is unused
func (self *TabItem) RequestedWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTabItem_GetRequestedWidth(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetNameOffset sets value of ImGuiTabItem.NameOffset
//
// When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
func (self TabItem) SetNameOffset(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetNameOffset(selfArg, C.ImS32(v))
}

// ImGuiTabItem_GetNameOffset returns value of ImGuiTabItem.NameOffset
//
// When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
func (self *TabItem) NameOffset() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTabItem_GetNameOffset(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetBeginOrder sets value of ImGuiTabItem.BeginOrder
//
// BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
func (self TabItem) SetBeginOrder(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetBeginOrder(selfArg, C.ImS16(v))
}

// ImGuiTabItem_GetBeginOrder returns value of ImGuiTabItem.BeginOrder
//
// BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
func (self *TabItem) BeginOrder() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTabItem_GetBeginOrder(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetIndexDuringLayout sets value of ImGuiTabItem.IndexDuringLayout
//
// Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.
func (self TabItem) SetIndexDuringLayout(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetIndexDuringLayout(selfArg, C.ImS16(v))
}

// ImGuiTabItem_GetIndexDuringLayout returns value of ImGuiTabItem.IndexDuringLayout
//
// Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.
func (self *TabItem) IndexDuringLayout() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTabItem_GetIndexDuringLayout(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)))
}

// ImGuiTabItem_SetWantClose sets value of ImGuiTabItem.WantClose
//
// Marked as closed by SetTabItemClosed()
func (self TabItem) SetWantClose(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTabItem_SetWantClose(selfArg, C.bool(v))
}

// ImGuiTabItem_GetWantClose returns value of ImGuiTabItem.WantClose
//
// Marked as closed by SetTabItemClosed()
func (self *TabItem) WantClose() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTabItem_GetWantClose(internal.ReinterpretCast[*C.ImGuiTabItem](selfArg)) == C.bool(true)
}

// ImGuiTable_SetID sets value of ImGuiTable.ID
func (self Table) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTable_GetID returns value of ImGuiTable.ID
func (self *Table) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTable_GetID(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetFlags sets value of ImGuiTable.Flags
func (self Table) SetFlags(v TableFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetFlags(selfArg, C.ImGuiTableFlags(v))
}

// ImGuiTable_GetFlags returns value of ImGuiTable.Flags
func (self *Table) Flags() TableFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TableFlags(C.wrap_ImGuiTable_GetFlags(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRawData sets value of ImGuiTable.RawData
//
// Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]
func (self Table) SetRawData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRawData(selfArg, C.uintptr_t(v))
}

// ImGuiTable_GetRawData returns value of ImGuiTable.RawData
//
// Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]
func (self *Table) RawData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiTable_GetRawData(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetTempData sets value of ImGuiTable.TempData
//
// Transient data while table is active. Point within g.CurrentTableStack[]
func (self Table) SetTempData(v *TableTempData) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetTempData(selfArg, internal.ReinterpretCast[*C.ImGuiTableTempData](vArg))
}

// ImGuiTable_GetTempData returns value of ImGuiTable.TempData
//
// Transient data while table is active. Point within g.CurrentTableStack[]
func (self *Table) TempData() *TableTempData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewTableTempDataFromC(C.wrap_ImGuiTable_GetTempData(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetEnabledMaskByDisplayOrder sets value of ImGuiTable.EnabledMaskByDisplayOrder
//
// Column DisplayOrder -> IsEnabled map
func (self Table) SetEnabledMaskByDisplayOrder(v BitArrayPtr) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetEnabledMaskByDisplayOrder(selfArg, internal.ReinterpretCast[C.ImBitArrayPtr](vArg))
}

// ImGuiTable_GetEnabledMaskByDisplayOrder returns value of ImGuiTable.EnabledMaskByDisplayOrder
//
// Column DisplayOrder -> IsEnabled map
func (self *Table) EnabledMaskByDisplayOrder() BitArrayPtr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewBitArrayPtrFromC(func() *C.ImBitArrayPtr {
		result := C.wrap_ImGuiTable_GetEnabledMaskByDisplayOrder(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetEnabledMaskByIndex sets value of ImGuiTable.EnabledMaskByIndex
//
// Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data
func (self Table) SetEnabledMaskByIndex(v BitArrayPtr) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetEnabledMaskByIndex(selfArg, internal.ReinterpretCast[C.ImBitArrayPtr](vArg))
}

// ImGuiTable_GetEnabledMaskByIndex returns value of ImGuiTable.EnabledMaskByIndex
//
// Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data
func (self *Table) EnabledMaskByIndex() BitArrayPtr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewBitArrayPtrFromC(func() *C.ImBitArrayPtr {
		result := C.wrap_ImGuiTable_GetEnabledMaskByIndex(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetVisibleMaskByIndex sets value of ImGuiTable.VisibleMaskByIndex
//
// Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)
func (self Table) SetVisibleMaskByIndex(v BitArrayPtr) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetVisibleMaskByIndex(selfArg, internal.ReinterpretCast[C.ImBitArrayPtr](vArg))
}

// ImGuiTable_GetVisibleMaskByIndex returns value of ImGuiTable.VisibleMaskByIndex
//
// Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)
func (self *Table) VisibleMaskByIndex() BitArrayPtr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewBitArrayPtrFromC(func() *C.ImBitArrayPtr {
		result := C.wrap_ImGuiTable_GetVisibleMaskByIndex(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetSettingsLoadedFlags sets value of ImGuiTable.SettingsLoadedFlags
//
// Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)
func (self Table) SetSettingsLoadedFlags(v TableFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSettingsLoadedFlags(selfArg, C.ImGuiTableFlags(v))
}

// ImGuiTable_GetSettingsLoadedFlags returns value of ImGuiTable.SettingsLoadedFlags
//
// Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)
func (self *Table) SettingsLoadedFlags() TableFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TableFlags(C.wrap_ImGuiTable_GetSettingsLoadedFlags(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetSettingsOffset sets value of ImGuiTable.SettingsOffset
//
// Offset in g.SettingsTables
func (self Table) SetSettingsOffset(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSettingsOffset(selfArg, C.int(v))
}

// ImGuiTable_GetSettingsOffset returns value of ImGuiTable.SettingsOffset
//
// Offset in g.SettingsTables
func (self *Table) SettingsOffset() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetSettingsOffset(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetLastFrameActive sets value of ImGuiTable.LastFrameActive
func (self Table) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetLastFrameActive(selfArg, C.int(v))
}

// ImGuiTable_GetLastFrameActive returns value of ImGuiTable.LastFrameActive
func (self *Table) LastFrameActive() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetLastFrameActive(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetColumnsCount sets value of ImGuiTable.ColumnsCount
//
// Number of columns declared in BeginTable()
func (self Table) SetColumnsCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsCount(selfArg, C.int(v))
}

// ImGuiTable_GetColumnsCount returns value of ImGuiTable.ColumnsCount
//
// Number of columns declared in BeginTable()
func (self *Table) ColumnsCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetColumnsCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetCurrentRow sets value of ImGuiTable.CurrentRow
func (self Table) SetCurrentRow(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCurrentRow(selfArg, C.int(v))
}

// ImGuiTable_GetCurrentRow returns value of ImGuiTable.CurrentRow
func (self *Table) CurrentRow() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetCurrentRow(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetCurrentColumn sets value of ImGuiTable.CurrentColumn
func (self Table) SetCurrentColumn(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCurrentColumn(selfArg, C.int(v))
}

// ImGuiTable_GetCurrentColumn returns value of ImGuiTable.CurrentColumn
func (self *Table) CurrentColumn() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetCurrentColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetInstanceCurrent sets value of ImGuiTable.InstanceCurrent
//
// Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.
func (self Table) SetInstanceCurrent(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceCurrent(selfArg, C.ImS16(v))
}

// ImGuiTable_GetInstanceCurrent returns value of ImGuiTable.InstanceCurrent
//
// Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.
func (self *Table) InstanceCurrent() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTable_GetInstanceCurrent(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetInstanceInteracted sets value of ImGuiTable.InstanceInteracted
//
// Mark which instance (generally 0) of the same ID is being interacted with
func (self Table) SetInstanceInteracted(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceInteracted(selfArg, C.ImS16(v))
}

// ImGuiTable_GetInstanceInteracted returns value of ImGuiTable.InstanceInteracted
//
// Mark which instance (generally 0) of the same ID is being interacted with
func (self *Table) InstanceInteracted() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTable_GetInstanceInteracted(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowPosY1 sets value of ImGuiTable.RowPosY1
func (self Table) SetRowPosY1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowPosY1(selfArg, C.float(v))
}

// ImGuiTable_GetRowPosY1 returns value of ImGuiTable.RowPosY1
func (self *Table) RowPosY1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowPosY1(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowPosY2 sets value of ImGuiTable.RowPosY2
func (self Table) SetRowPosY2(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowPosY2(selfArg, C.float(v))
}

// ImGuiTable_GetRowPosY2 returns value of ImGuiTable.RowPosY2
func (self *Table) RowPosY2() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowPosY2(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowMinHeight sets value of ImGuiTable.RowMinHeight
//
// Height submitted to TableNextRow()
func (self Table) SetRowMinHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowMinHeight(selfArg, C.float(v))
}

// ImGuiTable_GetRowMinHeight returns value of ImGuiTable.RowMinHeight
//
// Height submitted to TableNextRow()
func (self *Table) RowMinHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowMinHeight(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowCellPaddingY sets value of ImGuiTable.RowCellPaddingY
//
// Top and bottom padding. Reloaded during row change.
func (self Table) SetRowCellPaddingY(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowCellPaddingY(selfArg, C.float(v))
}

// ImGuiTable_GetRowCellPaddingY returns value of ImGuiTable.RowCellPaddingY
//
// Top and bottom padding. Reloaded during row change.
func (self *Table) RowCellPaddingY() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowCellPaddingY(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowTextBaseline sets value of ImGuiTable.RowTextBaseline
func (self Table) SetRowTextBaseline(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowTextBaseline(selfArg, C.float(v))
}

// ImGuiTable_GetRowTextBaseline returns value of ImGuiTable.RowTextBaseline
func (self *Table) RowTextBaseline() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowTextBaseline(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowIndentOffsetX sets value of ImGuiTable.RowIndentOffsetX
func (self Table) SetRowIndentOffsetX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowIndentOffsetX(selfArg, C.float(v))
}

// ImGuiTable_GetRowIndentOffsetX returns value of ImGuiTable.RowIndentOffsetX
func (self *Table) RowIndentOffsetX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRowIndentOffsetX(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowFlags sets value of ImGuiTable.RowFlags
//
// Current row flags, see ImGuiTableRowFlags_
func (self Table) SetRowFlags(v TableRowFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowFlags(selfArg, C.ImGuiTableRowFlags(v))
}

// ImGuiTable_GetRowFlags returns value of ImGuiTable.RowFlags
//
// Current row flags, see ImGuiTableRowFlags_
func (self *Table) RowFlags() TableRowFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TableRowFlags(C.wrap_ImGuiTable_GetRowFlags(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetLastRowFlags sets value of ImGuiTable.LastRowFlags
func (self Table) SetLastRowFlags(v TableRowFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetLastRowFlags(selfArg, C.ImGuiTableRowFlags(v))
}

// ImGuiTable_GetLastRowFlags returns value of ImGuiTable.LastRowFlags
func (self *Table) LastRowFlags() TableRowFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TableRowFlags(C.wrap_ImGuiTable_GetLastRowFlags(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowBgColorCounter sets value of ImGuiTable.RowBgColorCounter
//
// Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.
func (self Table) SetRowBgColorCounter(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowBgColorCounter(selfArg, C.int(v))
}

// ImGuiTable_GetRowBgColorCounter returns value of ImGuiTable.RowBgColorCounter
//
// Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.
func (self *Table) RowBgColorCounter() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTable_GetRowBgColorCounter(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRowBgColor sets value of ImGuiTable.RowBgColor[2]
//
// Background color override for current row.
func (self Table) SetRowBgColor(v *[2]uint32) {
	vArg := make([]C.ImU32, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU32(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowBgColor(selfArg, (*C.ImU32)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = uint32(vV)
	}
}

// ImGuiTable_GetRowBgColor returns value of ImGuiTable.RowBgColor[2]
//
// Background color override for current row.
func (self *Table) RowBgColor() [2]uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [2]uint32 {
		result := [2]uint32{}
		resultMirr := C.wrap_ImGuiTable_GetRowBgColor(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		for i := range result {
			result[i] = uint32(C.cimgui_ImU32_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiTable_SetBorderColorStrong sets value of ImGuiTable.BorderColorStrong
func (self Table) SetBorderColorStrong(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderColorStrong(selfArg, C.ImU32(v))
}

// ImGuiTable_GetBorderColorStrong returns value of ImGuiTable.BorderColorStrong
func (self *Table) BorderColorStrong() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTable_GetBorderColorStrong(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetBorderColorLight sets value of ImGuiTable.BorderColorLight
func (self Table) SetBorderColorLight(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderColorLight(selfArg, C.ImU32(v))
}

// ImGuiTable_GetBorderColorLight returns value of ImGuiTable.BorderColorLight
func (self *Table) BorderColorLight() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTable_GetBorderColorLight(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetBorderX1 sets value of ImGuiTable.BorderX1
func (self Table) SetBorderX1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderX1(selfArg, C.float(v))
}

// ImGuiTable_GetBorderX1 returns value of ImGuiTable.BorderX1
func (self *Table) BorderX1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetBorderX1(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetBorderX2 sets value of ImGuiTable.BorderX2
func (self Table) SetBorderX2(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBorderX2(selfArg, C.float(v))
}

// ImGuiTable_GetBorderX2 returns value of ImGuiTable.BorderX2
func (self *Table) BorderX2() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetBorderX2(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetHostIndentX sets value of ImGuiTable.HostIndentX
func (self Table) SetHostIndentX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostIndentX(selfArg, C.float(v))
}

// ImGuiTable_GetHostIndentX returns value of ImGuiTable.HostIndentX
func (self *Table) HostIndentX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetHostIndentX(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetMinColumnWidth sets value of ImGuiTable.MinColumnWidth
func (self Table) SetMinColumnWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetMinColumnWidth(selfArg, C.float(v))
}

// ImGuiTable_GetMinColumnWidth returns value of ImGuiTable.MinColumnWidth
func (self *Table) MinColumnWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetMinColumnWidth(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetOuterPaddingX sets value of ImGuiTable.OuterPaddingX
func (self Table) SetOuterPaddingX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetOuterPaddingX(selfArg, C.float(v))
}

// ImGuiTable_GetOuterPaddingX returns value of ImGuiTable.OuterPaddingX
func (self *Table) OuterPaddingX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetOuterPaddingX(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetCellPaddingX sets value of ImGuiTable.CellPaddingX
//
// Padding from each borders. Locked in BeginTable()/Layout.
func (self Table) SetCellPaddingX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCellPaddingX(selfArg, C.float(v))
}

// ImGuiTable_GetCellPaddingX returns value of ImGuiTable.CellPaddingX
//
// Padding from each borders. Locked in BeginTable()/Layout.
func (self *Table) CellPaddingX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetCellPaddingX(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetCellSpacingX1 sets value of ImGuiTable.CellSpacingX1
//
// Spacing between non-bordered cells. Locked in BeginTable()/Layout.
func (self Table) SetCellSpacingX1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCellSpacingX1(selfArg, C.float(v))
}

// ImGuiTable_GetCellSpacingX1 returns value of ImGuiTable.CellSpacingX1
//
// Spacing between non-bordered cells. Locked in BeginTable()/Layout.
func (self *Table) CellSpacingX1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetCellSpacingX1(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetCellSpacingX2 sets value of ImGuiTable.CellSpacingX2
func (self Table) SetCellSpacingX2(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetCellSpacingX2(selfArg, C.float(v))
}

// ImGuiTable_GetCellSpacingX2 returns value of ImGuiTable.CellSpacingX2
func (self *Table) CellSpacingX2() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetCellSpacingX2(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetInnerWidth sets value of ImGuiTable.InnerWidth
//
// User value passed to BeginTable(), see comments at the top of BeginTable() for details.
func (self Table) SetInnerWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerWidth(selfArg, C.float(v))
}

// ImGuiTable_GetInnerWidth returns value of ImGuiTable.InnerWidth
//
// User value passed to BeginTable(), see comments at the top of BeginTable() for details.
func (self *Table) InnerWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetInnerWidth(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetColumnsGivenWidth sets value of ImGuiTable.ColumnsGivenWidth
//
// Sum of current column width
func (self Table) SetColumnsGivenWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsGivenWidth(selfArg, C.float(v))
}

// ImGuiTable_GetColumnsGivenWidth returns value of ImGuiTable.ColumnsGivenWidth
//
// Sum of current column width
func (self *Table) ColumnsGivenWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetColumnsGivenWidth(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetColumnsAutoFitWidth sets value of ImGuiTable.ColumnsAutoFitWidth
//
// Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window
func (self Table) SetColumnsAutoFitWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsAutoFitWidth(selfArg, C.float(v))
}

// ImGuiTable_GetColumnsAutoFitWidth returns value of ImGuiTable.ColumnsAutoFitWidth
//
// Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window
func (self *Table) ColumnsAutoFitWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetColumnsAutoFitWidth(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetColumnsStretchSumWeights sets value of ImGuiTable.ColumnsStretchSumWeights
//
// Sum of weight of all enabled stretching columns
func (self Table) SetColumnsStretchSumWeights(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsStretchSumWeights(selfArg, C.float(v))
}

// ImGuiTable_GetColumnsStretchSumWeights returns value of ImGuiTable.ColumnsStretchSumWeights
//
// Sum of weight of all enabled stretching columns
func (self *Table) ColumnsStretchSumWeights() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetColumnsStretchSumWeights(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetResizedColumnNextWidth sets value of ImGuiTable.ResizedColumnNextWidth
func (self Table) SetResizedColumnNextWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetResizedColumnNextWidth(selfArg, C.float(v))
}

// ImGuiTable_GetResizedColumnNextWidth returns value of ImGuiTable.ResizedColumnNextWidth
func (self *Table) ResizedColumnNextWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetResizedColumnNextWidth(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetResizeLockMinContentsX2 sets value of ImGuiTable.ResizeLockMinContentsX2
//
// Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.
func (self Table) SetResizeLockMinContentsX2(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetResizeLockMinContentsX2(selfArg, C.float(v))
}

// ImGuiTable_GetResizeLockMinContentsX2 returns value of ImGuiTable.ResizeLockMinContentsX2
//
// Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.
func (self *Table) ResizeLockMinContentsX2() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetResizeLockMinContentsX2(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetRefScale sets value of ImGuiTable.RefScale
//
// Reference scale to be able to rescale columns on font/dpi changes.
func (self Table) SetRefScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRefScale(selfArg, C.float(v))
}

// ImGuiTable_GetRefScale returns value of ImGuiTable.RefScale
//
// Reference scale to be able to rescale columns on font/dpi changes.
func (self *Table) RefScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetRefScale(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetAngledHeadersHeight sets value of ImGuiTable.AngledHeadersHeight
//
// Set by TableAngledHeadersRow(), used in TableUpdateLayout()
func (self Table) SetAngledHeadersHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetAngledHeadersHeight(selfArg, C.float(v))
}

// ImGuiTable_GetAngledHeadersHeight returns value of ImGuiTable.AngledHeadersHeight
//
// Set by TableAngledHeadersRow(), used in TableUpdateLayout()
func (self *Table) AngledHeadersHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetAngledHeadersHeight(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetAngledHeadersSlope sets value of ImGuiTable.AngledHeadersSlope
//
// Set by TableAngledHeadersRow(), used in TableUpdateLayout()
func (self Table) SetAngledHeadersSlope(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetAngledHeadersSlope(selfArg, C.float(v))
}

// ImGuiTable_GetAngledHeadersSlope returns value of ImGuiTable.AngledHeadersSlope
//
// Set by TableAngledHeadersRow(), used in TableUpdateLayout()
func (self *Table) AngledHeadersSlope() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTable_GetAngledHeadersSlope(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetOuterRect sets value of ImGuiTable.OuterRect
//
// Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().
func (self Table) SetOuterRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetOuterRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetOuterRect returns value of ImGuiTable.OuterRect
//
// Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().
func (self *Table) OuterRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetOuterRect(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetInnerRect sets value of ImGuiTable.InnerRect
//
// InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is
func (self Table) SetInnerRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetInnerRect returns value of ImGuiTable.InnerRect
//
// InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is
func (self *Table) InnerRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetInnerRect(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetWorkRect sets value of ImGuiTable.WorkRect
func (self Table) SetWorkRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetWorkRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetWorkRect returns value of ImGuiTable.WorkRect
func (self *Table) WorkRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetWorkRect(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetInnerClipRect sets value of ImGuiTable.InnerClipRect
func (self Table) SetInnerClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetInnerClipRect returns value of ImGuiTable.InnerClipRect
func (self *Table) InnerClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetInnerClipRect(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetBgClipRect sets value of ImGuiTable.BgClipRect
//
// We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries
func (self Table) SetBgClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBgClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetBgClipRect returns value of ImGuiTable.BgClipRect
//
// We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries
func (self *Table) BgClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetBgClipRect(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetBg0ClipRectForDrawCmd sets value of ImGuiTable.Bg0ClipRectForDrawCmd
//
// Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped
func (self Table) SetBg0ClipRectForDrawCmd(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg0ClipRectForDrawCmd(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetBg0ClipRectForDrawCmd returns value of ImGuiTable.Bg0ClipRectForDrawCmd
//
// Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped
func (self *Table) Bg0ClipRectForDrawCmd() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetBg0ClipRectForDrawCmd(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetBg2ClipRectForDrawCmd sets value of ImGuiTable.Bg2ClipRectForDrawCmd
//
// Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.
func (self Table) SetBg2ClipRectForDrawCmd(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg2ClipRectForDrawCmd(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetBg2ClipRectForDrawCmd returns value of ImGuiTable.Bg2ClipRectForDrawCmd
//
// Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.
func (self *Table) Bg2ClipRectForDrawCmd() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetBg2ClipRectForDrawCmd(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetHostClipRect sets value of ImGuiTable.HostClipRect
//
// This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.
func (self Table) SetHostClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetHostClipRect returns value of ImGuiTable.HostClipRect
//
// This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.
func (self *Table) HostClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetHostClipRect(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetHostBackupInnerClipRect sets value of ImGuiTable.HostBackupInnerClipRect
//
// Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()
func (self Table) SetHostBackupInnerClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostBackupInnerClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTable_GetHostBackupInnerClipRect returns value of ImGuiTable.HostBackupInnerClipRect
//
// Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()
func (self *Table) HostBackupInnerClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTable_GetHostBackupInnerClipRect(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTable_SetOuterWindow sets value of ImGuiTable.OuterWindow
//
// Parent window for the table
func (self Table) SetOuterWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetOuterWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiTable_GetOuterWindow returns value of ImGuiTable.OuterWindow
//
// Parent window for the table
func (self *Table) OuterWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiTable_GetOuterWindow(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetInnerWindow sets value of ImGuiTable.InnerWindow
//
// Window holding the table data (== OuterWindow or a child window)
func (self Table) SetInnerWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInnerWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiTable_GetInnerWindow returns value of ImGuiTable.InnerWindow
//
// Window holding the table data (== OuterWindow or a child window)
func (self *Table) InnerWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiTable_GetInnerWindow(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetColumnsNames sets value of ImGuiTable.ColumnsNames
//
// Contiguous buffer holding columns names
func (self Table) SetColumnsNames(v TextBuffer) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsNames(selfArg, internal.ReinterpretCast[C.ImGuiTextBuffer](vArg))
}

// ImGuiTable_GetColumnsNames returns value of ImGuiTable.ColumnsNames
//
// Contiguous buffer holding columns names
func (self *Table) ColumnsNames() TextBuffer {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTextBufferFromC(func() *C.ImGuiTextBuffer {
		result := C.wrap_ImGuiTable_GetColumnsNames(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetDrawSplitter sets value of ImGuiTable.DrawSplitter
//
// Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly
func (self Table) SetDrawSplitter(v *DrawListSplitter) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetDrawSplitter(selfArg, internal.ReinterpretCast[*C.ImDrawListSplitter](vArg))
}

// ImGuiTable_GetDrawSplitter returns value of ImGuiTable.DrawSplitter
//
// Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly
func (self *Table) DrawSplitter() *DrawListSplitter {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDrawListSplitterFromC(C.wrap_ImGuiTable_GetDrawSplitter(internal.ReinterpretCast[*C.ImGuiTable](selfArg)))
}

// ImGuiTable_SetInstanceDataFirst sets value of ImGuiTable.InstanceDataFirst
func (self Table) SetInstanceDataFirst(v TableInstanceData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceDataFirst(selfArg, internal.ReinterpretCast[C.ImGuiTableInstanceData](vArg))
}

// ImGuiTable_GetInstanceDataFirst returns value of ImGuiTable.InstanceDataFirst
func (self *Table) InstanceDataFirst() TableInstanceData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableInstanceDataFromC(func() *C.ImGuiTableInstanceData {
		result := C.wrap_ImGuiTable_GetInstanceDataFirst(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetInstanceDataExtra sets value of ImGuiTable.InstanceDataExtra
//
// FIXME-OPT: Using a small-vector pattern would be good.
func (self Table) SetInstanceDataExtra(v vectors.Vector[TableInstanceData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiTableInstanceData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiTableInstanceData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetInstanceDataExtra(selfArg, *vVecArg)
}

// ImGuiTable_GetInstanceDataExtra returns value of ImGuiTable.InstanceDataExtra
//
// FIXME-OPT: Using a small-vector pattern would be good.
func (self *Table) InstanceDataExtra() vectors.Vector[TableInstanceData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiTable_GetInstanceDataExtra(internal.ReinterpretCast[*C.ImGuiTable](selfArg)).Size, C.wrap_ImGuiTable_GetInstanceDataExtra(internal.ReinterpretCast[*C.ImGuiTable](selfArg)).Capacity, NewTableInstanceDataFromC(C.wrap_ImGuiTable_GetInstanceDataExtra(internal.ReinterpretCast[*C.ImGuiTable](selfArg)).Data))
}

// ImGuiTable_SetSortSpecsSingle sets value of ImGuiTable.SortSpecsSingle
func (self Table) SetSortSpecsSingle(v TableColumnSortSpecs) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSortSpecsSingle(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnSortSpecs](vArg))
}

// ImGuiTable_GetSortSpecsSingle returns value of ImGuiTable.SortSpecsSingle
func (self *Table) SortSpecsSingle() TableColumnSortSpecs {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnSortSpecsFromC(func() *C.ImGuiTableColumnSortSpecs {
		result := C.wrap_ImGuiTable_GetSortSpecsSingle(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetSortSpecsMulti sets value of ImGuiTable.SortSpecsMulti
//
// FIXME-OPT: Using a small-vector pattern would be good.
func (self Table) SetSortSpecsMulti(v vectors.Vector[TableColumnSortSpecs]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiTableColumnSortSpecs)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiTableColumnSortSpecs](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSortSpecsMulti(selfArg, *vVecArg)
}

// ImGuiTable_GetSortSpecsMulti returns value of ImGuiTable.SortSpecsMulti
//
// FIXME-OPT: Using a small-vector pattern would be good.
func (self *Table) SortSpecsMulti() vectors.Vector[TableColumnSortSpecs] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiTable_GetSortSpecsMulti(internal.ReinterpretCast[*C.ImGuiTable](selfArg)).Size, C.wrap_ImGuiTable_GetSortSpecsMulti(internal.ReinterpretCast[*C.ImGuiTable](selfArg)).Capacity, NewTableColumnSortSpecsFromC(C.wrap_ImGuiTable_GetSortSpecsMulti(internal.ReinterpretCast[*C.ImGuiTable](selfArg)).Data))
}

// ImGuiTable_SetSortSpecs sets value of ImGuiTable.SortSpecs
//
// Public facing sorts specs, this is what we return in TableGetSortSpecs()
func (self Table) SetSortSpecs(v TableSortSpecs) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSortSpecs(selfArg, internal.ReinterpretCast[C.ImGuiTableSortSpecs](vArg))
}

// ImGuiTable_GetSortSpecs returns value of ImGuiTable.SortSpecs
//
// Public facing sorts specs, this is what we return in TableGetSortSpecs()
func (self *Table) SortSpecs() TableSortSpecs {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableSortSpecsFromC(func() *C.ImGuiTableSortSpecs {
		result := C.wrap_ImGuiTable_GetSortSpecs(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetSortSpecsCount sets value of ImGuiTable.SortSpecsCount
func (self Table) SetSortSpecsCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetSortSpecsCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetSortSpecsCount returns value of ImGuiTable.SortSpecsCount
func (self *Table) SortSpecsCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetSortSpecsCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetColumnsEnabledCount sets value of ImGuiTable.ColumnsEnabledCount
//
// Number of enabled columns (<= ColumnsCount)
func (self Table) SetColumnsEnabledCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsEnabledCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetColumnsEnabledCount returns value of ImGuiTable.ColumnsEnabledCount
//
// Number of enabled columns (<= ColumnsCount)
func (self *Table) ColumnsEnabledCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetColumnsEnabledCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetColumnsEnabledFixedCount sets value of ImGuiTable.ColumnsEnabledFixedCount
//
// Number of enabled columns using fixed width (<= ColumnsCount)
func (self Table) SetColumnsEnabledFixedCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetColumnsEnabledFixedCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetColumnsEnabledFixedCount returns value of ImGuiTable.ColumnsEnabledFixedCount
//
// Number of enabled columns using fixed width (<= ColumnsCount)
func (self *Table) ColumnsEnabledFixedCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetColumnsEnabledFixedCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetDeclColumnsCount sets value of ImGuiTable.DeclColumnsCount
//
// Count calls to TableSetupColumn()
func (self Table) SetDeclColumnsCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetDeclColumnsCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetDeclColumnsCount returns value of ImGuiTable.DeclColumnsCount
//
// Count calls to TableSetupColumn()
func (self *Table) DeclColumnsCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetDeclColumnsCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetAngledHeadersCount sets value of ImGuiTable.AngledHeadersCount
//
// Count columns with angled headers
func (self Table) SetAngledHeadersCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetAngledHeadersCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetAngledHeadersCount returns value of ImGuiTable.AngledHeadersCount
//
// Count columns with angled headers
func (self *Table) AngledHeadersCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetAngledHeadersCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetHoveredColumnBody sets value of ImGuiTable.HoveredColumnBody
//
// Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!
func (self Table) SetHoveredColumnBody(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHoveredColumnBody(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetHoveredColumnBody returns value of ImGuiTable.HoveredColumnBody
//
// Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!
func (self *Table) HoveredColumnBody() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetHoveredColumnBody(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetHoveredColumnBorder sets value of ImGuiTable.HoveredColumnBorder
//
// Index of column whose right-border is being hovered (for resizing).
func (self Table) SetHoveredColumnBorder(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHoveredColumnBorder(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetHoveredColumnBorder returns value of ImGuiTable.HoveredColumnBorder
//
// Index of column whose right-border is being hovered (for resizing).
func (self *Table) HoveredColumnBorder() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetHoveredColumnBorder(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetHighlightColumnHeader sets value of ImGuiTable.HighlightColumnHeader
//
// Index of column which should be highlighted.
func (self Table) SetHighlightColumnHeader(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHighlightColumnHeader(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetHighlightColumnHeader returns value of ImGuiTable.HighlightColumnHeader
//
// Index of column which should be highlighted.
func (self *Table) HighlightColumnHeader() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetHighlightColumnHeader(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetAutoFitSingleColumn sets value of ImGuiTable.AutoFitSingleColumn
//
// Index of single column requesting auto-fit.
func (self Table) SetAutoFitSingleColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetAutoFitSingleColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetAutoFitSingleColumn returns value of ImGuiTable.AutoFitSingleColumn
//
// Index of single column requesting auto-fit.
func (self *Table) AutoFitSingleColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetAutoFitSingleColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetResizedColumn sets value of ImGuiTable.ResizedColumn
//
// Index of column being resized. Reset when InstanceCurrent==0.
func (self Table) SetResizedColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetResizedColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetResizedColumn returns value of ImGuiTable.ResizedColumn
//
// Index of column being resized. Reset when InstanceCurrent==0.
func (self *Table) ResizedColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetResizedColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetLastResizedColumn sets value of ImGuiTable.LastResizedColumn
//
// Index of column being resized from previous frame.
func (self Table) SetLastResizedColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetLastResizedColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetLastResizedColumn returns value of ImGuiTable.LastResizedColumn
//
// Index of column being resized from previous frame.
func (self *Table) LastResizedColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetLastResizedColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetHeldHeaderColumn sets value of ImGuiTable.HeldHeaderColumn
//
// Index of column header being held.
func (self Table) SetHeldHeaderColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHeldHeaderColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetHeldHeaderColumn returns value of ImGuiTable.HeldHeaderColumn
//
// Index of column header being held.
func (self *Table) HeldHeaderColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetHeldHeaderColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetReorderColumn sets value of ImGuiTable.ReorderColumn
//
// Index of column being reordered. (not cleared)
func (self Table) SetReorderColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetReorderColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetReorderColumn returns value of ImGuiTable.ReorderColumn
//
// Index of column being reordered. (not cleared)
func (self *Table) ReorderColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetReorderColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetReorderColumnDir sets value of ImGuiTable.ReorderColumnDir
//
// -1 or +1
func (self Table) SetReorderColumnDir(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetReorderColumnDir(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetReorderColumnDir returns value of ImGuiTable.ReorderColumnDir
//
// -1 or +1
func (self *Table) ReorderColumnDir() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetReorderColumnDir(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetLeftMostEnabledColumn sets value of ImGuiTable.LeftMostEnabledColumn
//
// Index of left-most non-hidden column.
func (self Table) SetLeftMostEnabledColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetLeftMostEnabledColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetLeftMostEnabledColumn returns value of ImGuiTable.LeftMostEnabledColumn
//
// Index of left-most non-hidden column.
func (self *Table) LeftMostEnabledColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetLeftMostEnabledColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetRightMostEnabledColumn sets value of ImGuiTable.RightMostEnabledColumn
//
// Index of right-most non-hidden column.
func (self Table) SetRightMostEnabledColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRightMostEnabledColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetRightMostEnabledColumn returns value of ImGuiTable.RightMostEnabledColumn
//
// Index of right-most non-hidden column.
func (self *Table) RightMostEnabledColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetRightMostEnabledColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetLeftMostStretchedColumn sets value of ImGuiTable.LeftMostStretchedColumn
//
// Index of left-most stretched column.
func (self Table) SetLeftMostStretchedColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetLeftMostStretchedColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetLeftMostStretchedColumn returns value of ImGuiTable.LeftMostStretchedColumn
//
// Index of left-most stretched column.
func (self *Table) LeftMostStretchedColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetLeftMostStretchedColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetRightMostStretchedColumn sets value of ImGuiTable.RightMostStretchedColumn
//
// Index of right-most stretched column.
func (self Table) SetRightMostStretchedColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRightMostStretchedColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetRightMostStretchedColumn returns value of ImGuiTable.RightMostStretchedColumn
//
// Index of right-most stretched column.
func (self *Table) RightMostStretchedColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetRightMostStretchedColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetContextPopupColumn sets value of ImGuiTable.ContextPopupColumn
//
// Column right-clicked on, of -1 if opening context menu from a neutral/empty spot
func (self Table) SetContextPopupColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetContextPopupColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetContextPopupColumn returns value of ImGuiTable.ContextPopupColumn
//
// Column right-clicked on, of -1 if opening context menu from a neutral/empty spot
func (self *Table) ContextPopupColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetContextPopupColumn(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetFreezeRowsRequest sets value of ImGuiTable.FreezeRowsRequest
//
// Requested frozen rows count
func (self Table) SetFreezeRowsRequest(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetFreezeRowsRequest(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetFreezeRowsRequest returns value of ImGuiTable.FreezeRowsRequest
//
// Requested frozen rows count
func (self *Table) FreezeRowsRequest() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetFreezeRowsRequest(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetFreezeRowsCount sets value of ImGuiTable.FreezeRowsCount
//
// Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)
func (self Table) SetFreezeRowsCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetFreezeRowsCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetFreezeRowsCount returns value of ImGuiTable.FreezeRowsCount
//
// Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)
func (self *Table) FreezeRowsCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetFreezeRowsCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetFreezeColumnsRequest sets value of ImGuiTable.FreezeColumnsRequest
//
// Requested frozen columns count
func (self Table) SetFreezeColumnsRequest(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetFreezeColumnsRequest(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetFreezeColumnsRequest returns value of ImGuiTable.FreezeColumnsRequest
//
// Requested frozen columns count
func (self *Table) FreezeColumnsRequest() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetFreezeColumnsRequest(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetFreezeColumnsCount sets value of ImGuiTable.FreezeColumnsCount
//
// Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)
func (self Table) SetFreezeColumnsCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetFreezeColumnsCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetFreezeColumnsCount returns value of ImGuiTable.FreezeColumnsCount
//
// Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)
func (self *Table) FreezeColumnsCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetFreezeColumnsCount(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetRowCellDataCurrent sets value of ImGuiTable.RowCellDataCurrent
//
// Index of current RowCellData[] entry in current row
func (self Table) SetRowCellDataCurrent(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetRowCellDataCurrent(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTable_GetRowCellDataCurrent returns value of ImGuiTable.RowCellDataCurrent
//
// Index of current RowCellData[] entry in current row
func (self *Table) RowCellDataCurrent() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTable_GetRowCellDataCurrent(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetDummyDrawChannel sets value of ImGuiTable.DummyDrawChannel
//
// Redirect non-visible columns here.
func (self Table) SetDummyDrawChannel(v TableDrawChannelIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetDummyDrawChannel(selfArg, internal.ReinterpretCast[C.ImGuiTableDrawChannelIdx](vArg))
}

// ImGuiTable_GetDummyDrawChannel returns value of ImGuiTable.DummyDrawChannel
//
// Redirect non-visible columns here.
func (self *Table) DummyDrawChannel() TableDrawChannelIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx {
		result := C.wrap_ImGuiTable_GetDummyDrawChannel(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetBg2DrawChannelCurrent sets value of ImGuiTable.Bg2DrawChannelCurrent
//
// For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]
func (self Table) SetBg2DrawChannelCurrent(v TableDrawChannelIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg2DrawChannelCurrent(selfArg, internal.ReinterpretCast[C.ImGuiTableDrawChannelIdx](vArg))
}

// ImGuiTable_GetBg2DrawChannelCurrent returns value of ImGuiTable.Bg2DrawChannelCurrent
//
// For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]
func (self *Table) Bg2DrawChannelCurrent() TableDrawChannelIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx {
		result := C.wrap_ImGuiTable_GetBg2DrawChannelCurrent(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetBg2DrawChannelUnfrozen sets value of ImGuiTable.Bg2DrawChannelUnfrozen
func (self Table) SetBg2DrawChannelUnfrozen(v TableDrawChannelIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetBg2DrawChannelUnfrozen(selfArg, internal.ReinterpretCast[C.ImGuiTableDrawChannelIdx](vArg))
}

// ImGuiTable_GetBg2DrawChannelUnfrozen returns value of ImGuiTable.Bg2DrawChannelUnfrozen
func (self *Table) Bg2DrawChannelUnfrozen() TableDrawChannelIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx {
		result := C.wrap_ImGuiTable_GetBg2DrawChannelUnfrozen(internal.ReinterpretCast[*C.ImGuiTable](selfArg))
		return &result
	}())
}

// ImGuiTable_SetIsLayoutLocked sets value of ImGuiTable.IsLayoutLocked
//
// Set by TableUpdateLayout() which is called when beginning the first row.
func (self Table) SetIsLayoutLocked(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsLayoutLocked(selfArg, C.bool(v))
}

// ImGuiTable_GetIsLayoutLocked returns value of ImGuiTable.IsLayoutLocked
//
// Set by TableUpdateLayout() which is called when beginning the first row.
func (self *Table) IsLayoutLocked() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsLayoutLocked(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsInsideRow sets value of ImGuiTable.IsInsideRow
//
// Set when inside TableBeginRow()/TableEndRow().
func (self Table) SetIsInsideRow(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsInsideRow(selfArg, C.bool(v))
}

// ImGuiTable_GetIsInsideRow returns value of ImGuiTable.IsInsideRow
//
// Set when inside TableBeginRow()/TableEndRow().
func (self *Table) IsInsideRow() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsInsideRow(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsInitializing sets value of ImGuiTable.IsInitializing
func (self Table) SetIsInitializing(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsInitializing(selfArg, C.bool(v))
}

// ImGuiTable_GetIsInitializing returns value of ImGuiTable.IsInitializing
func (self *Table) IsInitializing() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsInitializing(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsSortSpecsDirty sets value of ImGuiTable.IsSortSpecsDirty
func (self Table) SetIsSortSpecsDirty(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsSortSpecsDirty(selfArg, C.bool(v))
}

// ImGuiTable_GetIsSortSpecsDirty returns value of ImGuiTable.IsSortSpecsDirty
func (self *Table) IsSortSpecsDirty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsSortSpecsDirty(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsUsingHeaders sets value of ImGuiTable.IsUsingHeaders
//
// Set when the first row had the ImGuiTableRowFlags_Headers flag.
func (self Table) SetIsUsingHeaders(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsUsingHeaders(selfArg, C.bool(v))
}

// ImGuiTable_GetIsUsingHeaders returns value of ImGuiTable.IsUsingHeaders
//
// Set when the first row had the ImGuiTableRowFlags_Headers flag.
func (self *Table) IsUsingHeaders() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsUsingHeaders(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsContextPopupOpen sets value of ImGuiTable.IsContextPopupOpen
//
// Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).
func (self Table) SetIsContextPopupOpen(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsContextPopupOpen(selfArg, C.bool(v))
}

// ImGuiTable_GetIsContextPopupOpen returns value of ImGuiTable.IsContextPopupOpen
//
// Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).
func (self *Table) IsContextPopupOpen() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsContextPopupOpen(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetDisableDefaultContextMenu sets value of ImGuiTable.DisableDefaultContextMenu
//
// Disable default context menu contents. You may submit your own using TableBeginContextMenuPopup()/EndPopup()
func (self Table) SetDisableDefaultContextMenu(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetDisableDefaultContextMenu(selfArg, C.bool(v))
}

// ImGuiTable_GetDisableDefaultContextMenu returns value of ImGuiTable.DisableDefaultContextMenu
//
// Disable default context menu contents. You may submit your own using TableBeginContextMenuPopup()/EndPopup()
func (self *Table) DisableDefaultContextMenu() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetDisableDefaultContextMenu(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsSettingsRequestLoad sets value of ImGuiTable.IsSettingsRequestLoad
func (self Table) SetIsSettingsRequestLoad(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsSettingsRequestLoad(selfArg, C.bool(v))
}

// ImGuiTable_GetIsSettingsRequestLoad returns value of ImGuiTable.IsSettingsRequestLoad
func (self *Table) IsSettingsRequestLoad() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsSettingsRequestLoad(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsSettingsDirty sets value of ImGuiTable.IsSettingsDirty
//
// Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.
func (self Table) SetIsSettingsDirty(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsSettingsDirty(selfArg, C.bool(v))
}

// ImGuiTable_GetIsSettingsDirty returns value of ImGuiTable.IsSettingsDirty
//
// Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.
func (self *Table) IsSettingsDirty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsSettingsDirty(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsDefaultDisplayOrder sets value of ImGuiTable.IsDefaultDisplayOrder
//
// Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)
func (self Table) SetIsDefaultDisplayOrder(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsDefaultDisplayOrder(selfArg, C.bool(v))
}

// ImGuiTable_GetIsDefaultDisplayOrder returns value of ImGuiTable.IsDefaultDisplayOrder
//
// Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)
func (self *Table) IsDefaultDisplayOrder() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsDefaultDisplayOrder(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsResetAllRequest sets value of ImGuiTable.IsResetAllRequest
func (self Table) SetIsResetAllRequest(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsResetAllRequest(selfArg, C.bool(v))
}

// ImGuiTable_GetIsResetAllRequest returns value of ImGuiTable.IsResetAllRequest
func (self *Table) IsResetAllRequest() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsResetAllRequest(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsResetDisplayOrderRequest sets value of ImGuiTable.IsResetDisplayOrderRequest
func (self Table) SetIsResetDisplayOrderRequest(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsResetDisplayOrderRequest(selfArg, C.bool(v))
}

// ImGuiTable_GetIsResetDisplayOrderRequest returns value of ImGuiTable.IsResetDisplayOrderRequest
func (self *Table) IsResetDisplayOrderRequest() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsResetDisplayOrderRequest(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsUnfrozenRows sets value of ImGuiTable.IsUnfrozenRows
//
// Set when we got past the frozen row.
func (self Table) SetIsUnfrozenRows(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsUnfrozenRows(selfArg, C.bool(v))
}

// ImGuiTable_GetIsUnfrozenRows returns value of ImGuiTable.IsUnfrozenRows
//
// Set when we got past the frozen row.
func (self *Table) IsUnfrozenRows() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsUnfrozenRows(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsDefaultSizingPolicy sets value of ImGuiTable.IsDefaultSizingPolicy
//
// Set if user didn't explicitly set a sizing policy in BeginTable()
func (self Table) SetIsDefaultSizingPolicy(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsDefaultSizingPolicy(selfArg, C.bool(v))
}

// ImGuiTable_GetIsDefaultSizingPolicy returns value of ImGuiTable.IsDefaultSizingPolicy
//
// Set if user didn't explicitly set a sizing policy in BeginTable()
func (self *Table) IsDefaultSizingPolicy() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsDefaultSizingPolicy(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsActiveIdAliveBeforeTable sets value of ImGuiTable.IsActiveIdAliveBeforeTable
func (self Table) SetIsActiveIdAliveBeforeTable(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsActiveIdAliveBeforeTable(selfArg, C.bool(v))
}

// ImGuiTable_GetIsActiveIdAliveBeforeTable returns value of ImGuiTable.IsActiveIdAliveBeforeTable
func (self *Table) IsActiveIdAliveBeforeTable() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsActiveIdAliveBeforeTable(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetIsActiveIdInTable sets value of ImGuiTable.IsActiveIdInTable
func (self Table) SetIsActiveIdInTable(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetIsActiveIdInTable(selfArg, C.bool(v))
}

// ImGuiTable_GetIsActiveIdInTable returns value of ImGuiTable.IsActiveIdInTable
func (self *Table) IsActiveIdInTable() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetIsActiveIdInTable(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetHasScrollbarYCurr sets value of ImGuiTable.HasScrollbarYCurr
//
// Whether ANY instance of this table had a vertical scrollbar during the current frame.
func (self Table) SetHasScrollbarYCurr(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHasScrollbarYCurr(selfArg, C.bool(v))
}

// ImGuiTable_GetHasScrollbarYCurr returns value of ImGuiTable.HasScrollbarYCurr
//
// Whether ANY instance of this table had a vertical scrollbar during the current frame.
func (self *Table) HasScrollbarYCurr() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetHasScrollbarYCurr(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetHasScrollbarYPrev sets value of ImGuiTable.HasScrollbarYPrev
//
// Whether ANY instance of this table had a vertical scrollbar during the previous.
func (self Table) SetHasScrollbarYPrev(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHasScrollbarYPrev(selfArg, C.bool(v))
}

// ImGuiTable_GetHasScrollbarYPrev returns value of ImGuiTable.HasScrollbarYPrev
//
// Whether ANY instance of this table had a vertical scrollbar during the previous.
func (self *Table) HasScrollbarYPrev() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetHasScrollbarYPrev(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetMemoryCompacted sets value of ImGuiTable.MemoryCompacted
func (self Table) SetMemoryCompacted(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetMemoryCompacted(selfArg, C.bool(v))
}

// ImGuiTable_GetMemoryCompacted returns value of ImGuiTable.MemoryCompacted
func (self *Table) MemoryCompacted() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetMemoryCompacted(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTable_SetHostSkipItems sets value of ImGuiTable.HostSkipItems
//
// Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis
func (self Table) SetHostSkipItems(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTable_SetHostSkipItems(selfArg, C.bool(v))
}

// ImGuiTable_GetHostSkipItems returns value of ImGuiTable.HostSkipItems
//
// Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis
func (self *Table) HostSkipItems() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTable_GetHostSkipItems(internal.ReinterpretCast[*C.ImGuiTable](selfArg)) == C.bool(true)
}

// ImGuiTableCellData_SetBgColor sets value of ImGuiTableCellData.BgColor
//
// Actual color
func (self TableCellData) SetBgColor(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableCellData_SetBgColor(selfArg, C.ImU32(v))
}

// ImGuiTableCellData_GetBgColor returns value of ImGuiTableCellData.BgColor
//
// Actual color
func (self *TableCellData) BgColor() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTableCellData_GetBgColor(internal.ReinterpretCast[*C.ImGuiTableCellData](selfArg)))
}

// ImGuiTableCellData_SetColumn sets value of ImGuiTableCellData.Column
//
// Column number
func (self TableCellData) SetColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableCellData_SetColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableCellData_GetColumn returns value of ImGuiTableCellData.Column
//
// Column number
func (self *TableCellData) Column() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableCellData_GetColumn(internal.ReinterpretCast[*C.ImGuiTableCellData](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetFlags sets value of ImGuiTableColumn.Flags
//
// Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_
func (self TableColumn) SetFlags(v TableColumnFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetFlags(selfArg, C.ImGuiTableColumnFlags(v))
}

// ImGuiTableColumn_GetFlags returns value of ImGuiTableColumn.Flags
//
// Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_
func (self *TableColumn) Flags() TableColumnFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TableColumnFlags(C.wrap_ImGuiTableColumn_GetFlags(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetWidthGiven sets value of ImGuiTableColumn.WidthGiven
//
// Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.
func (self TableColumn) SetWidthGiven(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWidthGiven(selfArg, C.float(v))
}

// ImGuiTableColumn_GetWidthGiven returns value of ImGuiTableColumn.WidthGiven
//
// Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.
func (self *TableColumn) WidthGiven() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWidthGiven(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetMinX sets value of ImGuiTableColumn.MinX
//
// Absolute positions
func (self TableColumn) SetMinX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetMinX(selfArg, C.float(v))
}

// ImGuiTableColumn_GetMinX returns value of ImGuiTableColumn.MinX
//
// Absolute positions
func (self *TableColumn) MinX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetMinX(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetMaxX sets value of ImGuiTableColumn.MaxX
func (self TableColumn) SetMaxX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetMaxX(selfArg, C.float(v))
}

// ImGuiTableColumn_GetMaxX returns value of ImGuiTableColumn.MaxX
func (self *TableColumn) MaxX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetMaxX(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetWidthRequest sets value of ImGuiTableColumn.WidthRequest
//
// Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()
func (self TableColumn) SetWidthRequest(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWidthRequest(selfArg, C.float(v))
}

// ImGuiTableColumn_GetWidthRequest returns value of ImGuiTableColumn.WidthRequest
//
// Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()
func (self *TableColumn) WidthRequest() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWidthRequest(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetWidthAuto sets value of ImGuiTableColumn.WidthAuto
//
// Automatic width
func (self TableColumn) SetWidthAuto(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWidthAuto(selfArg, C.float(v))
}

// ImGuiTableColumn_GetWidthAuto returns value of ImGuiTableColumn.WidthAuto
//
// Automatic width
func (self *TableColumn) WidthAuto() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWidthAuto(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetWidthMax sets value of ImGuiTableColumn.WidthMax
//
// Maximum width (FIXME: overwritten by each instance)
func (self TableColumn) SetWidthMax(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWidthMax(selfArg, C.float(v))
}

// ImGuiTableColumn_GetWidthMax returns value of ImGuiTableColumn.WidthMax
//
// Maximum width (FIXME: overwritten by each instance)
func (self *TableColumn) WidthMax() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWidthMax(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetStretchWeight sets value of ImGuiTableColumn.StretchWeight
//
// Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.
func (self TableColumn) SetStretchWeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetStretchWeight(selfArg, C.float(v))
}

// ImGuiTableColumn_GetStretchWeight returns value of ImGuiTableColumn.StretchWeight
//
// Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.
func (self *TableColumn) StretchWeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetStretchWeight(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetInitStretchWeightOrWidth sets value of ImGuiTableColumn.InitStretchWeightOrWidth
//
// Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).
func (self TableColumn) SetInitStretchWeightOrWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetInitStretchWeightOrWidth(selfArg, C.float(v))
}

// ImGuiTableColumn_GetInitStretchWeightOrWidth returns value of ImGuiTableColumn.InitStretchWeightOrWidth
//
// Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).
func (self *TableColumn) InitStretchWeightOrWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetInitStretchWeightOrWidth(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetClipRect sets value of ImGuiTableColumn.ClipRect
//
// Clipping rectangle for the column
func (self TableColumn) SetClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTableColumn_GetClipRect returns value of ImGuiTableColumn.ClipRect
//
// Clipping rectangle for the column
func (self *TableColumn) ClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTableColumn_GetClipRect(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTableColumn_SetUserID sets value of ImGuiTableColumn.UserID
//
// Optional, value passed to TableSetupColumn()
func (self TableColumn) SetUserID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetUserID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTableColumn_GetUserID returns value of ImGuiTableColumn.UserID
//
// Optional, value passed to TableSetupColumn()
func (self *TableColumn) UserID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTableColumn_GetUserID(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetWorkMinX sets value of ImGuiTableColumn.WorkMinX
//
// Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column
func (self TableColumn) SetWorkMinX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWorkMinX(selfArg, C.float(v))
}

// ImGuiTableColumn_GetWorkMinX returns value of ImGuiTableColumn.WorkMinX
//
// Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column
func (self *TableColumn) WorkMinX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWorkMinX(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetWorkMaxX sets value of ImGuiTableColumn.WorkMaxX
//
// Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
func (self TableColumn) SetWorkMaxX(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetWorkMaxX(selfArg, C.float(v))
}

// ImGuiTableColumn_GetWorkMaxX returns value of ImGuiTableColumn.WorkMaxX
//
// Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
func (self *TableColumn) WorkMaxX() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetWorkMaxX(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetItemWidth sets value of ImGuiTableColumn.ItemWidth
//
// Current item width for the column, preserved across rows
func (self TableColumn) SetItemWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetItemWidth(selfArg, C.float(v))
}

// ImGuiTableColumn_GetItemWidth returns value of ImGuiTableColumn.ItemWidth
//
// Current item width for the column, preserved across rows
func (self *TableColumn) ItemWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetItemWidth(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetContentMaxXFrozen sets value of ImGuiTableColumn.ContentMaxXFrozen
//
// Contents maximum position for frozen rows (apart from headers), from which we can infer content width.
func (self TableColumn) SetContentMaxXFrozen(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXFrozen(selfArg, C.float(v))
}

// ImGuiTableColumn_GetContentMaxXFrozen returns value of ImGuiTableColumn.ContentMaxXFrozen
//
// Contents maximum position for frozen rows (apart from headers), from which we can infer content width.
func (self *TableColumn) ContentMaxXFrozen() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXFrozen(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetContentMaxXUnfrozen sets value of ImGuiTableColumn.ContentMaxXUnfrozen
func (self TableColumn) SetContentMaxXUnfrozen(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXUnfrozen(selfArg, C.float(v))
}

// ImGuiTableColumn_GetContentMaxXUnfrozen returns value of ImGuiTableColumn.ContentMaxXUnfrozen
func (self *TableColumn) ContentMaxXUnfrozen() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXUnfrozen(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetContentMaxXHeadersUsed sets value of ImGuiTableColumn.ContentMaxXHeadersUsed
//
// Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls
func (self TableColumn) SetContentMaxXHeadersUsed(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXHeadersUsed(selfArg, C.float(v))
}

// ImGuiTableColumn_GetContentMaxXHeadersUsed returns value of ImGuiTableColumn.ContentMaxXHeadersUsed
//
// Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls
func (self *TableColumn) ContentMaxXHeadersUsed() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXHeadersUsed(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetContentMaxXHeadersIdeal sets value of ImGuiTableColumn.ContentMaxXHeadersIdeal
func (self TableColumn) SetContentMaxXHeadersIdeal(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetContentMaxXHeadersIdeal(selfArg, C.float(v))
}

// ImGuiTableColumn_GetContentMaxXHeadersIdeal returns value of ImGuiTableColumn.ContentMaxXHeadersIdeal
func (self *TableColumn) ContentMaxXHeadersIdeal() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumn_GetContentMaxXHeadersIdeal(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetNameOffset sets value of ImGuiTableColumn.NameOffset
//
// Offset into parent ColumnsNames[]
func (self TableColumn) SetNameOffset(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetNameOffset(selfArg, C.ImS16(v))
}

// ImGuiTableColumn_GetNameOffset returns value of ImGuiTableColumn.NameOffset
//
// Offset into parent ColumnsNames[]
func (self *TableColumn) NameOffset() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTableColumn_GetNameOffset(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetDisplayOrder sets value of ImGuiTableColumn.DisplayOrder
//
// Index within Table's IndexToDisplayOrder[] (column may be reordered by users)
func (self TableColumn) SetDisplayOrder(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetDisplayOrder(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumn_GetDisplayOrder returns value of ImGuiTableColumn.DisplayOrder
//
// Index within Table's IndexToDisplayOrder[] (column may be reordered by users)
func (self *TableColumn) DisplayOrder() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumn_GetDisplayOrder(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetIndexWithinEnabledSet sets value of ImGuiTableColumn.IndexWithinEnabledSet
//
// Index within enabled/visible set (<= IndexToDisplayOrder)
func (self TableColumn) SetIndexWithinEnabledSet(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIndexWithinEnabledSet(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumn_GetIndexWithinEnabledSet returns value of ImGuiTableColumn.IndexWithinEnabledSet
//
// Index within enabled/visible set (<= IndexToDisplayOrder)
func (self *TableColumn) IndexWithinEnabledSet() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumn_GetIndexWithinEnabledSet(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetPrevEnabledColumn sets value of ImGuiTableColumn.PrevEnabledColumn
//
// Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column
func (self TableColumn) SetPrevEnabledColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetPrevEnabledColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumn_GetPrevEnabledColumn returns value of ImGuiTableColumn.PrevEnabledColumn
//
// Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column
func (self *TableColumn) PrevEnabledColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumn_GetPrevEnabledColumn(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetNextEnabledColumn sets value of ImGuiTableColumn.NextEnabledColumn
//
// Index of next enabled/visible column within Columns[], -1 if last enabled/visible column
func (self TableColumn) SetNextEnabledColumn(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetNextEnabledColumn(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumn_GetNextEnabledColumn returns value of ImGuiTableColumn.NextEnabledColumn
//
// Index of next enabled/visible column within Columns[], -1 if last enabled/visible column
func (self *TableColumn) NextEnabledColumn() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumn_GetNextEnabledColumn(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetSortOrder sets value of ImGuiTableColumn.SortOrder
//
// Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort
func (self TableColumn) SetSortOrder(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortOrder(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumn_GetSortOrder returns value of ImGuiTableColumn.SortOrder
//
// Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort
func (self *TableColumn) SortOrder() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumn_GetSortOrder(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetDrawChannelCurrent sets value of ImGuiTableColumn.DrawChannelCurrent
//
// Index within DrawSplitter.Channels[]
func (self TableColumn) SetDrawChannelCurrent(v TableDrawChannelIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetDrawChannelCurrent(selfArg, internal.ReinterpretCast[C.ImGuiTableDrawChannelIdx](vArg))
}

// ImGuiTableColumn_GetDrawChannelCurrent returns value of ImGuiTableColumn.DrawChannelCurrent
//
// Index within DrawSplitter.Channels[]
func (self *TableColumn) DrawChannelCurrent() TableDrawChannelIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx {
		result := C.wrap_ImGuiTableColumn_GetDrawChannelCurrent(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetDrawChannelFrozen sets value of ImGuiTableColumn.DrawChannelFrozen
//
// Draw channels for frozen rows (often headers)
func (self TableColumn) SetDrawChannelFrozen(v TableDrawChannelIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetDrawChannelFrozen(selfArg, internal.ReinterpretCast[C.ImGuiTableDrawChannelIdx](vArg))
}

// ImGuiTableColumn_GetDrawChannelFrozen returns value of ImGuiTableColumn.DrawChannelFrozen
//
// Draw channels for frozen rows (often headers)
func (self *TableColumn) DrawChannelFrozen() TableDrawChannelIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx {
		result := C.wrap_ImGuiTableColumn_GetDrawChannelFrozen(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetDrawChannelUnfrozen sets value of ImGuiTableColumn.DrawChannelUnfrozen
//
// Draw channels for unfrozen rows
func (self TableColumn) SetDrawChannelUnfrozen(v TableDrawChannelIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetDrawChannelUnfrozen(selfArg, internal.ReinterpretCast[C.ImGuiTableDrawChannelIdx](vArg))
}

// ImGuiTableColumn_GetDrawChannelUnfrozen returns value of ImGuiTableColumn.DrawChannelUnfrozen
//
// Draw channels for unfrozen rows
func (self *TableColumn) DrawChannelUnfrozen() TableDrawChannelIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableDrawChannelIdxFromC(func() *C.ImGuiTableDrawChannelIdx {
		result := C.wrap_ImGuiTableColumn_GetDrawChannelUnfrozen(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg))
		return &result
	}())
}

// ImGuiTableColumn_SetIsEnabled sets value of ImGuiTableColumn.IsEnabled
//
// IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0
func (self TableColumn) SetIsEnabled(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsEnabled(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsEnabled returns value of ImGuiTableColumn.IsEnabled
//
// IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0
func (self *TableColumn) IsEnabled() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsEnabled(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetIsUserEnabled sets value of ImGuiTableColumn.IsUserEnabled
//
// Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).
func (self TableColumn) SetIsUserEnabled(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsUserEnabled(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsUserEnabled returns value of ImGuiTableColumn.IsUserEnabled
//
// Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).
func (self *TableColumn) IsUserEnabled() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsUserEnabled(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetIsUserEnabledNextFrame sets value of ImGuiTableColumn.IsUserEnabledNextFrame
func (self TableColumn) SetIsUserEnabledNextFrame(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsUserEnabledNextFrame(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsUserEnabledNextFrame returns value of ImGuiTableColumn.IsUserEnabledNextFrame
func (self *TableColumn) IsUserEnabledNextFrame() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsUserEnabledNextFrame(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetIsVisibleX sets value of ImGuiTableColumn.IsVisibleX
//
// Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).
func (self TableColumn) SetIsVisibleX(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsVisibleX(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsVisibleX returns value of ImGuiTableColumn.IsVisibleX
//
// Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).
func (self *TableColumn) IsVisibleX() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsVisibleX(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetIsVisibleY sets value of ImGuiTableColumn.IsVisibleY
func (self TableColumn) SetIsVisibleY(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsVisibleY(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsVisibleY returns value of ImGuiTableColumn.IsVisibleY
func (self *TableColumn) IsVisibleY() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsVisibleY(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetIsRequestOutput sets value of ImGuiTableColumn.IsRequestOutput
//
// Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.
func (self TableColumn) SetIsRequestOutput(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsRequestOutput(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsRequestOutput returns value of ImGuiTableColumn.IsRequestOutput
//
// Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.
func (self *TableColumn) IsRequestOutput() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsRequestOutput(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetIsSkipItems sets value of ImGuiTableColumn.IsSkipItems
//
// Do we want item submissions to this column to be completely ignored (no layout will happen).
func (self TableColumn) SetIsSkipItems(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsSkipItems(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsSkipItems returns value of ImGuiTableColumn.IsSkipItems
//
// Do we want item submissions to this column to be completely ignored (no layout will happen).
func (self *TableColumn) IsSkipItems() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsSkipItems(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetIsPreserveWidthAuto sets value of ImGuiTableColumn.IsPreserveWidthAuto
func (self TableColumn) SetIsPreserveWidthAuto(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetIsPreserveWidthAuto(selfArg, C.bool(v))
}

// ImGuiTableColumn_GetIsPreserveWidthAuto returns value of ImGuiTableColumn.IsPreserveWidthAuto
func (self *TableColumn) IsPreserveWidthAuto() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableColumn_GetIsPreserveWidthAuto(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)) == C.bool(true)
}

// ImGuiTableColumn_SetNavLayerCurrent sets value of ImGuiTableColumn.NavLayerCurrent
//
// ImGuiNavLayer in 1 byte
func (self TableColumn) SetNavLayerCurrent(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetNavLayerCurrent(selfArg, C.ImS8(v))
}

// ImGuiTableColumn_GetNavLayerCurrent returns value of ImGuiTableColumn.NavLayerCurrent
//
// ImGuiNavLayer in 1 byte
func (self *TableColumn) NavLayerCurrent() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTableColumn_GetNavLayerCurrent(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetAutoFitQueue sets value of ImGuiTableColumn.AutoFitQueue
//
// Queue of 8 values for the next 8 frames to request auto-fit
func (self TableColumn) SetAutoFitQueue(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetAutoFitQueue(selfArg, C.ImU8(v))
}

// ImGuiTableColumn_GetAutoFitQueue returns value of ImGuiTableColumn.AutoFitQueue
//
// Queue of 8 values for the next 8 frames to request auto-fit
func (self *TableColumn) AutoFitQueue() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetAutoFitQueue(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetCannotSkipItemsQueue sets value of ImGuiTableColumn.CannotSkipItemsQueue
//
// Queue of 8 values for the next 8 frames to disable Clipped/SkipItem
func (self TableColumn) SetCannotSkipItemsQueue(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetCannotSkipItemsQueue(selfArg, C.ImU8(v))
}

// ImGuiTableColumn_GetCannotSkipItemsQueue returns value of ImGuiTableColumn.CannotSkipItemsQueue
//
// Queue of 8 values for the next 8 frames to disable Clipped/SkipItem
func (self *TableColumn) CannotSkipItemsQueue() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetCannotSkipItemsQueue(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetSortDirection sets value of ImGuiTableColumn.SortDirection
//
// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
func (self TableColumn) SetSortDirection(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirection(selfArg, C.ImU8(v))
}

// ImGuiTableColumn_GetSortDirection returns value of ImGuiTableColumn.SortDirection
//
// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
func (self *TableColumn) SortDirection() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirection(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetSortDirectionsAvailCount sets value of ImGuiTableColumn.SortDirectionsAvailCount
//
// Number of available sort directions (0 to 3)
func (self TableColumn) SetSortDirectionsAvailCount(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirectionsAvailCount(selfArg, C.ImU8(v))
}

// ImGuiTableColumn_GetSortDirectionsAvailCount returns value of ImGuiTableColumn.SortDirectionsAvailCount
//
// Number of available sort directions (0 to 3)
func (self *TableColumn) SortDirectionsAvailCount() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirectionsAvailCount(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetSortDirectionsAvailMask sets value of ImGuiTableColumn.SortDirectionsAvailMask
//
// Mask of available sort directions (1-bit each)
func (self TableColumn) SetSortDirectionsAvailMask(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirectionsAvailMask(selfArg, C.ImU8(v))
}

// ImGuiTableColumn_GetSortDirectionsAvailMask returns value of ImGuiTableColumn.SortDirectionsAvailMask
//
// Mask of available sort directions (1-bit each)
func (self *TableColumn) SortDirectionsAvailMask() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirectionsAvailMask(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumn_SetSortDirectionsAvailList sets value of ImGuiTableColumn.SortDirectionsAvailList
//
// Ordered list of available sort directions (2-bits each, total 8-bits)
func (self TableColumn) SetSortDirectionsAvailList(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumn_SetSortDirectionsAvailList(selfArg, C.ImU8(v))
}

// ImGuiTableColumn_GetSortDirectionsAvailList returns value of ImGuiTableColumn.SortDirectionsAvailList
//
// Ordered list of available sort directions (2-bits each, total 8-bits)
func (self *TableColumn) SortDirectionsAvailList() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumn_GetSortDirectionsAvailList(internal.ReinterpretCast[*C.ImGuiTableColumn](selfArg)))
}

// ImGuiTableColumnSettings_SetWidthOrWeight sets value of ImGuiTableColumnSettings.WidthOrWeight
func (self TableColumnSettings) SetWidthOrWeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetWidthOrWeight(selfArg, C.float(v))
}

// ImGuiTableColumnSettings_GetWidthOrWeight returns value of ImGuiTableColumnSettings.WidthOrWeight
func (self *TableColumnSettings) WidthOrWeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableColumnSettings_GetWidthOrWeight(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg)))
}

// ImGuiTableColumnSettings_SetUserID sets value of ImGuiTableColumnSettings.UserID
func (self TableColumnSettings) SetUserID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetUserID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTableColumnSettings_GetUserID returns value of ImGuiTableColumnSettings.UserID
func (self *TableColumnSettings) UserID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTableColumnSettings_GetUserID(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg))
		return &result
	}())
}

// ImGuiTableColumnSettings_SetIndex sets value of ImGuiTableColumnSettings.Index
func (self TableColumnSettings) SetIndex(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetIndex(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumnSettings_GetIndex returns value of ImGuiTableColumnSettings.Index
func (self *TableColumnSettings) Index() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumnSettings_GetIndex(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg))
		return &result
	}())
}

// ImGuiTableColumnSettings_SetDisplayOrder sets value of ImGuiTableColumnSettings.DisplayOrder
func (self TableColumnSettings) SetDisplayOrder(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetDisplayOrder(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumnSettings_GetDisplayOrder returns value of ImGuiTableColumnSettings.DisplayOrder
func (self *TableColumnSettings) DisplayOrder() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumnSettings_GetDisplayOrder(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg))
		return &result
	}())
}

// ImGuiTableColumnSettings_SetSortOrder sets value of ImGuiTableColumnSettings.SortOrder
func (self TableColumnSettings) SetSortOrder(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetSortOrder(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableColumnSettings_GetSortOrder returns value of ImGuiTableColumnSettings.SortOrder
func (self *TableColumnSettings) SortOrder() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableColumnSettings_GetSortOrder(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg))
		return &result
	}())
}

// ImGuiTableColumnSettings_SetSortDirection sets value of ImGuiTableColumnSettings.SortDirection
func (self TableColumnSettings) SetSortDirection(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetSortDirection(selfArg, C.ImU8(v))
}

// ImGuiTableColumnSettings_GetSortDirection returns value of ImGuiTableColumnSettings.SortDirection
func (self *TableColumnSettings) SortDirection() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumnSettings_GetSortDirection(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg)))
}

// ImGuiTableColumnSettings_SetIsEnabled sets value of ImGuiTableColumnSettings.IsEnabled
//
// "Visible" in ini file
func (self TableColumnSettings) SetIsEnabled(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetIsEnabled(selfArg, C.ImU8(v))
}

// ImGuiTableColumnSettings_GetIsEnabled returns value of ImGuiTableColumnSettings.IsEnabled
//
// "Visible" in ini file
func (self *TableColumnSettings) IsEnabled() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumnSettings_GetIsEnabled(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg)))
}

// ImGuiTableColumnSettings_SetIsStretch sets value of ImGuiTableColumnSettings.IsStretch
func (self TableColumnSettings) SetIsStretch(v byte) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSettings_SetIsStretch(selfArg, C.ImU8(v))
}

// ImGuiTableColumnSettings_GetIsStretch returns value of ImGuiTableColumnSettings.IsStretch
func (self *TableColumnSettings) IsStretch() byte {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return byte(C.wrap_ImGuiTableColumnSettings_GetIsStretch(internal.ReinterpretCast[*C.ImGuiTableColumnSettings](selfArg)))
}

// ImGuiTableColumnSortSpecs_SetColumnUserID sets value of ImGuiTableColumnSortSpecs.ColumnUserID
//
// User id of the column (if specified by a TableSetupColumn() call)
func (self TableColumnSortSpecs) SetColumnUserID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetColumnUserID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTableColumnSortSpecs_GetColumnUserID returns value of ImGuiTableColumnSortSpecs.ColumnUserID
//
// User id of the column (if specified by a TableSetupColumn() call)
func (self *TableColumnSortSpecs) ColumnUserID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTableColumnSortSpecs_GetColumnUserID(internal.ReinterpretCast[*C.ImGuiTableColumnSortSpecs](selfArg))
		return &result
	}())
}

// ImGuiTableColumnSortSpecs_SetColumnIndex sets value of ImGuiTableColumnSortSpecs.ColumnIndex
//
// Index of the column
func (self TableColumnSortSpecs) SetColumnIndex(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetColumnIndex(selfArg, C.ImS16(v))
}

// ImGuiTableColumnSortSpecs_GetColumnIndex returns value of ImGuiTableColumnSortSpecs.ColumnIndex
//
// Index of the column
func (self *TableColumnSortSpecs) ColumnIndex() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTableColumnSortSpecs_GetColumnIndex(internal.ReinterpretCast[*C.ImGuiTableColumnSortSpecs](selfArg)))
}

// ImGuiTableColumnSortSpecs_SetSortOrder sets value of ImGuiTableColumnSortSpecs.SortOrder
//
// Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)
func (self TableColumnSortSpecs) SetSortOrder(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetSortOrder(selfArg, C.ImS16(v))
}

// ImGuiTableColumnSortSpecs_GetSortOrder returns value of ImGuiTableColumnSortSpecs.SortOrder
//
// Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)
func (self *TableColumnSortSpecs) SortOrder() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiTableColumnSortSpecs_GetSortOrder(internal.ReinterpretCast[*C.ImGuiTableColumnSortSpecs](selfArg)))
}

// ImGuiTableColumnSortSpecs_SetSortDirection sets value of ImGuiTableColumnSortSpecs.SortDirection
//
// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
func (self TableColumnSortSpecs) SetSortDirection(v SortDirection) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableColumnSortSpecs_SetSortDirection(selfArg, C.ImGuiSortDirection(v))
}

// ImGuiTableColumnSortSpecs_GetSortDirection returns value of ImGuiTableColumnSortSpecs.SortDirection
//
// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
func (self *TableColumnSortSpecs) SortDirection() SortDirection {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return SortDirection(C.wrap_ImGuiTableColumnSortSpecs_GetSortDirection(internal.ReinterpretCast[*C.ImGuiTableColumnSortSpecs](selfArg)))
}

// ImGuiTableHeaderData_SetIndex sets value of ImGuiTableHeaderData.Index
//
// Column index
func (self TableHeaderData) SetIndex(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableHeaderData_SetIndex(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableHeaderData_GetIndex returns value of ImGuiTableHeaderData.Index
//
// Column index
func (self *TableHeaderData) Index() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableHeaderData_GetIndex(internal.ReinterpretCast[*C.ImGuiTableHeaderData](selfArg))
		return &result
	}())
}

// ImGuiTableHeaderData_SetTextColor sets value of ImGuiTableHeaderData.TextColor
func (self TableHeaderData) SetTextColor(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableHeaderData_SetTextColor(selfArg, C.ImU32(v))
}

// ImGuiTableHeaderData_GetTextColor returns value of ImGuiTableHeaderData.TextColor
func (self *TableHeaderData) TextColor() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTableHeaderData_GetTextColor(internal.ReinterpretCast[*C.ImGuiTableHeaderData](selfArg)))
}

// ImGuiTableHeaderData_SetBgColor0 sets value of ImGuiTableHeaderData.BgColor0
func (self TableHeaderData) SetBgColor0(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableHeaderData_SetBgColor0(selfArg, C.ImU32(v))
}

// ImGuiTableHeaderData_GetBgColor0 returns value of ImGuiTableHeaderData.BgColor0
func (self *TableHeaderData) BgColor0() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTableHeaderData_GetBgColor0(internal.ReinterpretCast[*C.ImGuiTableHeaderData](selfArg)))
}

// ImGuiTableHeaderData_SetBgColor1 sets value of ImGuiTableHeaderData.BgColor1
func (self TableHeaderData) SetBgColor1(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableHeaderData_SetBgColor1(selfArg, C.ImU32(v))
}

// ImGuiTableHeaderData_GetBgColor1 returns value of ImGuiTableHeaderData.BgColor1
func (self *TableHeaderData) BgColor1() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiTableHeaderData_GetBgColor1(internal.ReinterpretCast[*C.ImGuiTableHeaderData](selfArg)))
}

// ImGuiTableInstanceData_SetTableInstanceID sets value of ImGuiTableInstanceData.TableInstanceID
func (self TableInstanceData) SetTableInstanceID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetTableInstanceID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTableInstanceData_GetTableInstanceID returns value of ImGuiTableInstanceData.TableInstanceID
func (self *TableInstanceData) TableInstanceID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTableInstanceData_GetTableInstanceID(internal.ReinterpretCast[*C.ImGuiTableInstanceData](selfArg))
		return &result
	}())
}

// ImGuiTableInstanceData_SetLastOuterHeight sets value of ImGuiTableInstanceData.LastOuterHeight
//
// Outer height from last frame
func (self TableInstanceData) SetLastOuterHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetLastOuterHeight(selfArg, C.float(v))
}

// ImGuiTableInstanceData_GetLastOuterHeight returns value of ImGuiTableInstanceData.LastOuterHeight
//
// Outer height from last frame
func (self *TableInstanceData) LastOuterHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableInstanceData_GetLastOuterHeight(internal.ReinterpretCast[*C.ImGuiTableInstanceData](selfArg)))
}

// ImGuiTableInstanceData_SetLastTopHeadersRowHeight sets value of ImGuiTableInstanceData.LastTopHeadersRowHeight
//
// Height of first consecutive header rows from last frame (FIXME: this is used assuming consecutive headers are in same frozen set)
func (self TableInstanceData) SetLastTopHeadersRowHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetLastTopHeadersRowHeight(selfArg, C.float(v))
}

// ImGuiTableInstanceData_GetLastTopHeadersRowHeight returns value of ImGuiTableInstanceData.LastTopHeadersRowHeight
//
// Height of first consecutive header rows from last frame (FIXME: this is used assuming consecutive headers are in same frozen set)
func (self *TableInstanceData) LastTopHeadersRowHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableInstanceData_GetLastTopHeadersRowHeight(internal.ReinterpretCast[*C.ImGuiTableInstanceData](selfArg)))
}

// ImGuiTableInstanceData_SetLastFrozenHeight sets value of ImGuiTableInstanceData.LastFrozenHeight
//
// Height of frozen section from last frame
func (self TableInstanceData) SetLastFrozenHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetLastFrozenHeight(selfArg, C.float(v))
}

// ImGuiTableInstanceData_GetLastFrozenHeight returns value of ImGuiTableInstanceData.LastFrozenHeight
//
// Height of frozen section from last frame
func (self *TableInstanceData) LastFrozenHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableInstanceData_GetLastFrozenHeight(internal.ReinterpretCast[*C.ImGuiTableInstanceData](selfArg)))
}

// ImGuiTableInstanceData_SetHoveredRowLast sets value of ImGuiTableInstanceData.HoveredRowLast
//
// Index of row which was hovered last frame.
func (self TableInstanceData) SetHoveredRowLast(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetHoveredRowLast(selfArg, C.int(v))
}

// ImGuiTableInstanceData_GetHoveredRowLast returns value of ImGuiTableInstanceData.HoveredRowLast
//
// Index of row which was hovered last frame.
func (self *TableInstanceData) HoveredRowLast() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableInstanceData_GetHoveredRowLast(internal.ReinterpretCast[*C.ImGuiTableInstanceData](selfArg)))
}

// ImGuiTableInstanceData_SetHoveredRowNext sets value of ImGuiTableInstanceData.HoveredRowNext
//
// Index of row hovered this frame, set after encountering it.
func (self TableInstanceData) SetHoveredRowNext(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableInstanceData_SetHoveredRowNext(selfArg, C.int(v))
}

// ImGuiTableInstanceData_GetHoveredRowNext returns value of ImGuiTableInstanceData.HoveredRowNext
//
// Index of row hovered this frame, set after encountering it.
func (self *TableInstanceData) HoveredRowNext() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableInstanceData_GetHoveredRowNext(internal.ReinterpretCast[*C.ImGuiTableInstanceData](selfArg)))
}

// ImGuiTableSettings_SetID sets value of ImGuiTableSettings.ID
//
// Set to 0 to invalidate/delete the setting
func (self TableSettings) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTableSettings_GetID returns value of ImGuiTableSettings.ID
//
// Set to 0 to invalidate/delete the setting
func (self *TableSettings) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTableSettings_GetID(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg))
		return &result
	}())
}

// ImGuiTableSettings_SetSaveFlags sets value of ImGuiTableSettings.SaveFlags
//
// Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
func (self TableSettings) SetSaveFlags(v TableFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetSaveFlags(selfArg, C.ImGuiTableFlags(v))
}

// ImGuiTableSettings_GetSaveFlags returns value of ImGuiTableSettings.SaveFlags
//
// Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
func (self *TableSettings) SaveFlags() TableFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TableFlags(C.wrap_ImGuiTableSettings_GetSaveFlags(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg)))
}

// ImGuiTableSettings_SetRefScale sets value of ImGuiTableSettings.RefScale
//
// Reference scale to be able to rescale columns on font/dpi changes.
func (self TableSettings) SetRefScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetRefScale(selfArg, C.float(v))
}

// ImGuiTableSettings_GetRefScale returns value of ImGuiTableSettings.RefScale
//
// Reference scale to be able to rescale columns on font/dpi changes.
func (self *TableSettings) RefScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableSettings_GetRefScale(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg)))
}

// ImGuiTableSettings_SetColumnsCount sets value of ImGuiTableSettings.ColumnsCount
func (self TableSettings) SetColumnsCount(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetColumnsCount(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableSettings_GetColumnsCount returns value of ImGuiTableSettings.ColumnsCount
func (self *TableSettings) ColumnsCount() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableSettings_GetColumnsCount(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg))
		return &result
	}())
}

// ImGuiTableSettings_SetColumnsCountMax sets value of ImGuiTableSettings.ColumnsCountMax
//
// Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
func (self TableSettings) SetColumnsCountMax(v TableColumnIdx) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetColumnsCountMax(selfArg, internal.ReinterpretCast[C.ImGuiTableColumnIdx](vArg))
}

// ImGuiTableSettings_GetColumnsCountMax returns value of ImGuiTableSettings.ColumnsCountMax
//
// Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
func (self *TableSettings) ColumnsCountMax() TableColumnIdx {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTableColumnIdxFromC(func() *C.ImGuiTableColumnIdx {
		result := C.wrap_ImGuiTableSettings_GetColumnsCountMax(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg))
		return &result
	}())
}

// ImGuiTableSettings_SetWantApply sets value of ImGuiTableSettings.WantApply
//
// Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
func (self TableSettings) SetWantApply(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSettings_SetWantApply(selfArg, C.bool(v))
}

// ImGuiTableSettings_GetWantApply returns value of ImGuiTableSettings.WantApply
//
// Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
func (self *TableSettings) WantApply() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableSettings_GetWantApply(internal.ReinterpretCast[*C.ImGuiTableSettings](selfArg)) == C.bool(true)
}

// ImGuiTableSortSpecs_SetSpecs sets value of ImGuiTableSortSpecs.Specs
//
// Pointer to sort spec array.
func (self TableSortSpecs) SetSpecs(v *TableColumnSortSpecs) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSortSpecs_SetSpecs(selfArg, internal.ReinterpretCast[*C.ImGuiTableColumnSortSpecs](vArg))
}

// ImGuiTableSortSpecs_GetSpecs returns value of ImGuiTableSortSpecs.Specs
//
// Pointer to sort spec array.
func (self *TableSortSpecs) Specs() *TableColumnSortSpecs {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewTableColumnSortSpecsFromC(C.wrap_ImGuiTableSortSpecs_GetSpecs(internal.ReinterpretCast[*C.ImGuiTableSortSpecs](selfArg)))
}

// ImGuiTableSortSpecs_SetSpecsCount sets value of ImGuiTableSortSpecs.SpecsCount
//
// Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
func (self TableSortSpecs) SetSpecsCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSortSpecs_SetSpecsCount(selfArg, C.int(v))
}

// ImGuiTableSortSpecs_GetSpecsCount returns value of ImGuiTableSortSpecs.SpecsCount
//
// Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
func (self *TableSortSpecs) SpecsCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableSortSpecs_GetSpecsCount(internal.ReinterpretCast[*C.ImGuiTableSortSpecs](selfArg)))
}

// ImGuiTableSortSpecs_SetSpecsDirty sets value of ImGuiTableSortSpecs.SpecsDirty
//
// Set to true when specs have changed since last time! Use this to sort again, then clear the flag.
func (self TableSortSpecs) SetSpecsDirty(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableSortSpecs_SetSpecsDirty(selfArg, C.bool(v))
}

// ImGuiTableSortSpecs_GetSpecsDirty returns value of ImGuiTableSortSpecs.SpecsDirty
//
// Set to true when specs have changed since last time! Use this to sort again, then clear the flag.
func (self *TableSortSpecs) SpecsDirty() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTableSortSpecs_GetSpecsDirty(internal.ReinterpretCast[*C.ImGuiTableSortSpecs](selfArg)) == C.bool(true)
}

// ImGuiTableTempData_SetTableIndex sets value of ImGuiTableTempData.TableIndex
//
// Index in g.Tables.Buf[] pool
func (self TableTempData) SetTableIndex(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetTableIndex(selfArg, C.int(v))
}

// ImGuiTableTempData_GetTableIndex returns value of ImGuiTableTempData.TableIndex
//
// Index in g.Tables.Buf[] pool
func (self *TableTempData) TableIndex() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableTempData_GetTableIndex(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)))
}

// ImGuiTableTempData_SetLastTimeActive sets value of ImGuiTableTempData.LastTimeActive
//
// Last timestamp this structure was used
func (self TableTempData) SetLastTimeActive(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetLastTimeActive(selfArg, C.float(v))
}

// ImGuiTableTempData_GetLastTimeActive returns value of ImGuiTableTempData.LastTimeActive
//
// Last timestamp this structure was used
func (self *TableTempData) LastTimeActive() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableTempData_GetLastTimeActive(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)))
}

// ImGuiTableTempData_SetAngledHeadersExtraWidth sets value of ImGuiTableTempData.AngledHeadersExtraWidth
//
// Used in EndTable()
func (self TableTempData) SetAngledHeadersExtraWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetAngledHeadersExtraWidth(selfArg, C.float(v))
}

// ImGuiTableTempData_GetAngledHeadersExtraWidth returns value of ImGuiTableTempData.AngledHeadersExtraWidth
//
// Used in EndTable()
func (self *TableTempData) AngledHeadersExtraWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableTempData_GetAngledHeadersExtraWidth(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)))
}

// ImGuiTableTempData_SetAngledHeadersRequests sets value of ImGuiTableTempData.AngledHeadersRequests
//
// Used in TableAngledHeadersRow()
func (self TableTempData) SetAngledHeadersRequests(v vectors.Vector[TableHeaderData]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiTableHeaderData)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiTableHeaderData](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetAngledHeadersRequests(selfArg, *vVecArg)
}

// ImGuiTableTempData_GetAngledHeadersRequests returns value of ImGuiTableTempData.AngledHeadersRequests
//
// Used in TableAngledHeadersRow()
func (self *TableTempData) AngledHeadersRequests() vectors.Vector[TableHeaderData] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiTableTempData_GetAngledHeadersRequests(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)).Size, C.wrap_ImGuiTableTempData_GetAngledHeadersRequests(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)).Capacity, NewTableHeaderDataFromC(C.wrap_ImGuiTableTempData_GetAngledHeadersRequests(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)).Data))
}

// ImGuiTableTempData_SetUserOuterSize sets value of ImGuiTableTempData.UserOuterSize
//
// outer_size.x passed to BeginTable()
func (self TableTempData) SetUserOuterSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetUserOuterSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiTableTempData_GetUserOuterSize returns value of ImGuiTableTempData.UserOuterSize
//
// outer_size.x passed to BeginTable()
func (self *TableTempData) UserOuterSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiTableTempData_GetUserOuterSize(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTableTempData_SetDrawSplitter sets value of ImGuiTableTempData.DrawSplitter
func (self TableTempData) SetDrawSplitter(v DrawListSplitter) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetDrawSplitter(selfArg, internal.ReinterpretCast[C.ImDrawListSplitter](vArg))
}

// ImGuiTableTempData_GetDrawSplitter returns value of ImGuiTableTempData.DrawSplitter
func (self *TableTempData) DrawSplitter() DrawListSplitter {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawListSplitterFromC(func() *C.ImDrawListSplitter {
		result := C.wrap_ImGuiTableTempData_GetDrawSplitter(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return &result
	}())
}

// ImGuiTableTempData_SetHostBackupWorkRect sets value of ImGuiTableTempData.HostBackupWorkRect
//
// Backup of InnerWindow->WorkRect at the end of BeginTable()
func (self TableTempData) SetHostBackupWorkRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupWorkRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTableTempData_GetHostBackupWorkRect returns value of ImGuiTableTempData.HostBackupWorkRect
//
// Backup of InnerWindow->WorkRect at the end of BeginTable()
func (self *TableTempData) HostBackupWorkRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTableTempData_GetHostBackupWorkRect(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTableTempData_SetHostBackupParentWorkRect sets value of ImGuiTableTempData.HostBackupParentWorkRect
//
// Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
func (self TableTempData) SetHostBackupParentWorkRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupParentWorkRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTableTempData_GetHostBackupParentWorkRect returns value of ImGuiTableTempData.HostBackupParentWorkRect
//
// Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
func (self *TableTempData) HostBackupParentWorkRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTableTempData_GetHostBackupParentWorkRect(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTableTempData_SetHostBackupPrevLineSize sets value of ImGuiTableTempData.HostBackupPrevLineSize
//
// Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
func (self TableTempData) SetHostBackupPrevLineSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupPrevLineSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiTableTempData_GetHostBackupPrevLineSize returns value of ImGuiTableTempData.HostBackupPrevLineSize
//
// Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
func (self *TableTempData) HostBackupPrevLineSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiTableTempData_GetHostBackupPrevLineSize(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTableTempData_SetHostBackupCurrLineSize sets value of ImGuiTableTempData.HostBackupCurrLineSize
//
// Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
func (self TableTempData) SetHostBackupCurrLineSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupCurrLineSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiTableTempData_GetHostBackupCurrLineSize returns value of ImGuiTableTempData.HostBackupCurrLineSize
//
// Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
func (self *TableTempData) HostBackupCurrLineSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiTableTempData_GetHostBackupCurrLineSize(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTableTempData_SetHostBackupCursorMaxPos sets value of ImGuiTableTempData.HostBackupCursorMaxPos
//
// Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
func (self TableTempData) SetHostBackupCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupCursorMaxPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiTableTempData_GetHostBackupCursorMaxPos returns value of ImGuiTableTempData.HostBackupCursorMaxPos
//
// Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
func (self *TableTempData) HostBackupCursorMaxPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiTableTempData_GetHostBackupCursorMaxPos(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTableTempData_SetHostBackupColumnsOffset sets value of ImGuiTableTempData.HostBackupColumnsOffset
//
// Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
func (self TableTempData) SetHostBackupColumnsOffset(v Vec1) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupColumnsOffset(selfArg, internal.ReinterpretCast[C.ImVec1](vArg))
}

// ImGuiTableTempData_GetHostBackupColumnsOffset returns value of ImGuiTableTempData.HostBackupColumnsOffset
//
// Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
func (self *TableTempData) HostBackupColumnsOffset() Vec1 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewVec1FromC(func() *C.ImVec1 {
		result := C.wrap_ImGuiTableTempData_GetHostBackupColumnsOffset(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg))
		return &result
	}())
}

// ImGuiTableTempData_SetHostBackupItemWidth sets value of ImGuiTableTempData.HostBackupItemWidth
//
// Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
func (self TableTempData) SetHostBackupItemWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupItemWidth(selfArg, C.float(v))
}

// ImGuiTableTempData_GetHostBackupItemWidth returns value of ImGuiTableTempData.HostBackupItemWidth
//
// Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
func (self *TableTempData) HostBackupItemWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTableTempData_GetHostBackupItemWidth(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)))
}

// ImGuiTableTempData_SetHostBackupItemWidthStackSize sets value of ImGuiTableTempData.HostBackupItemWidthStackSize
//
// Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()
func (self TableTempData) SetHostBackupItemWidthStackSize(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTableTempData_SetHostBackupItemWidthStackSize(selfArg, C.int(v))
}

// ImGuiTableTempData_GetHostBackupItemWidthStackSize returns value of ImGuiTableTempData.HostBackupItemWidthStackSize
//
// Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()
func (self *TableTempData) HostBackupItemWidthStackSize() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTableTempData_GetHostBackupItemWidthStackSize(internal.ReinterpretCast[*C.ImGuiTableTempData](selfArg)))
}

// ImGuiTextBuffer_SetBuf sets value of ImGuiTextBuffer.Buf
func (self TextBuffer) SetBuf(v vectors.Vector[int8]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.char, int8](vData)
	vVecArg := new(C.ImVector_char)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextBuffer_SetBuf(selfArg, *vVecArg)
}

// ImGuiTextBuffer_GetBuf returns value of ImGuiTextBuffer.Buf
func (self *TextBuffer) Buf() vectors.Vector[int8] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiTextBuffer_GetBuf(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg)).Size, C.wrap_ImGuiTextBuffer_GetBuf(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg)).Capacity, (*int8)(C.wrap_ImGuiTextBuffer_GetBuf(internal.ReinterpretCast[*C.ImGuiTextBuffer](selfArg)).Data))
}

// ImGuiTextFilter_SetInputBuf sets value of ImGuiTextFilter.InputBuf[256]
func (self TextFilter) SetInputBuf(v *[256]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextFilter_SetInputBuf(selfArg, (*C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = rune(vV)
	}
}

// ImGuiTextFilter_GetInputBuf returns value of ImGuiTextFilter.InputBuf[256]
func (self *TextFilter) InputBuf() [256]rune {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [256]rune {
		result := [256]rune{}
		resultMirr := C.wrap_ImGuiTextFilter_GetInputBuf(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg))
		for i := range result {
			result[i] = rune(C.cimgui_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiTextFilter_SetFilters sets value of ImGuiTextFilter.Filters
func (self TextFilter) SetFilters(v vectors.Vector[TextRange]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiTextRange)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiTextRange](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextFilter_SetFilters(selfArg, *vVecArg)
}

// ImGuiTextFilter_GetFilters returns value of ImGuiTextFilter.Filters
func (self *TextFilter) Filters() vectors.Vector[TextRange] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiTextFilter_GetFilters(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg)).Size, C.wrap_ImGuiTextFilter_GetFilters(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg)).Capacity, NewTextRangeFromC(C.wrap_ImGuiTextFilter_GetFilters(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg)).Data))
}

// ImGuiTextFilter_SetCountGrep sets value of ImGuiTextFilter.CountGrep
func (self TextFilter) SetCountGrep(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextFilter_SetCountGrep(selfArg, C.int(v))
}

// ImGuiTextFilter_GetCountGrep returns value of ImGuiTextFilter.CountGrep
func (self *TextFilter) CountGrep() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTextFilter_GetCountGrep(internal.ReinterpretCast[*C.ImGuiTextFilter](selfArg)))
}

// ImGuiTextIndex_SetLineOffsets sets value of ImGuiTextIndex.LineOffsets
func (self TextIndex) SetLineOffsets(v vectors.Vector[int32]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.int, int32](vData)
	vVecArg := new(C.ImVector_int)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextIndex_SetLineOffsets(selfArg, *vVecArg)
}

// ImGuiTextIndex_GetLineOffsets returns value of ImGuiTextIndex.LineOffsets
func (self *TextIndex) LineOffsets() vectors.Vector[int32] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiTextIndex_GetLineOffsets(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg)).Size, C.wrap_ImGuiTextIndex_GetLineOffsets(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg)).Capacity, (*int32)(C.wrap_ImGuiTextIndex_GetLineOffsets(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg)).Data))
}

// ImGuiTextIndex_SetEndOffset sets value of ImGuiTextIndex.EndOffset
//
// Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)
func (self TextIndex) SetEndOffset(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextIndex_SetEndOffset(selfArg, C.int(v))
}

// ImGuiTextIndex_GetEndOffset returns value of ImGuiTextIndex.EndOffset
//
// Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)
func (self *TextIndex) EndOffset() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTextIndex_GetEndOffset(internal.ReinterpretCast[*C.ImGuiTextIndex](selfArg)))
}

// ImGuiTextRange_SetB sets value of ImGuiTextRange.b
func (self TextRange) SetB(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextRange_SetB(selfArg, vArg)
}

// ImGuiTextRange_GetB returns value of ImGuiTextRange.b
func (self *TextRange) B() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiTextRange_GetB(internal.ReinterpretCast[*C.ImGuiTextRange](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiTextRange_SetE sets value of ImGuiTextRange.e
func (self TextRange) SetE(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTextRange_SetE(selfArg, vArg)
}

// ImGuiTextRange_GetE returns value of ImGuiTextRange.e
func (self *TextRange) E() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiTextRange_GetE(internal.ReinterpretCast[*C.ImGuiTextRange](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiTreeNodeStackData_SetID sets value of ImGuiTreeNodeStackData.ID
func (self TreeNodeStackData) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTreeNodeStackData_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTreeNodeStackData_GetID returns value of ImGuiTreeNodeStackData.ID
func (self *TreeNodeStackData) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTreeNodeStackData_GetID(internal.ReinterpretCast[*C.ImGuiTreeNodeStackData](selfArg))
		return &result
	}())
}

// ImGuiTreeNodeStackData_SetTreeFlags sets value of ImGuiTreeNodeStackData.TreeFlags
func (self TreeNodeStackData) SetTreeFlags(v TreeNodeFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTreeNodeStackData_SetTreeFlags(selfArg, C.ImGuiTreeNodeFlags(v))
}

// ImGuiTreeNodeStackData_GetTreeFlags returns value of ImGuiTreeNodeStackData.TreeFlags
func (self *TreeNodeStackData) TreeFlags() TreeNodeFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TreeNodeFlags(C.wrap_ImGuiTreeNodeStackData_GetTreeFlags(internal.ReinterpretCast[*C.ImGuiTreeNodeStackData](selfArg)))
}

// ImGuiTreeNodeStackData_SetItemFlags sets value of ImGuiTreeNodeStackData.ItemFlags
//
// Used for nav landing
func (self TreeNodeStackData) SetItemFlags(v ItemFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTreeNodeStackData_SetItemFlags(selfArg, C.ImGuiItemFlags(v))
}

// ImGuiTreeNodeStackData_GetItemFlags returns value of ImGuiTreeNodeStackData.ItemFlags
//
// Used for nav landing
func (self *TreeNodeStackData) ItemFlags() ItemFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ItemFlags(C.wrap_ImGuiTreeNodeStackData_GetItemFlags(internal.ReinterpretCast[*C.ImGuiTreeNodeStackData](selfArg)))
}

// ImGuiTreeNodeStackData_SetNavRect sets value of ImGuiTreeNodeStackData.NavRect
//
// Used for nav landing
func (self TreeNodeStackData) SetNavRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTreeNodeStackData_SetNavRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiTreeNodeStackData_GetNavRect returns value of ImGuiTreeNodeStackData.NavRect
//
// Used for nav landing
func (self *TreeNodeStackData) NavRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiTreeNodeStackData_GetNavRect(internal.ReinterpretCast[*C.ImGuiTreeNodeStackData](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiTypingSelectRequest_SetFlags sets value of ImGuiTypingSelectRequest.Flags
//
// Flags passed to GetTypingSelectRequest()
func (self TypingSelectRequest) SetFlags(v TypingSelectFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetFlags(selfArg, C.ImGuiTypingSelectFlags(v))
}

// ImGuiTypingSelectRequest_GetFlags returns value of ImGuiTypingSelectRequest.Flags
//
// Flags passed to GetTypingSelectRequest()
func (self *TypingSelectRequest) Flags() TypingSelectFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TypingSelectFlags(C.wrap_ImGuiTypingSelectRequest_GetFlags(internal.ReinterpretCast[*C.ImGuiTypingSelectRequest](selfArg)))
}

// ImGuiTypingSelectRequest_SetSearchBufferLen sets value of ImGuiTypingSelectRequest.SearchBufferLen
func (self TypingSelectRequest) SetSearchBufferLen(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSearchBufferLen(selfArg, C.int(v))
}

// ImGuiTypingSelectRequest_GetSearchBufferLen returns value of ImGuiTypingSelectRequest.SearchBufferLen
func (self *TypingSelectRequest) SearchBufferLen() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTypingSelectRequest_GetSearchBufferLen(internal.ReinterpretCast[*C.ImGuiTypingSelectRequest](selfArg)))
}

// ImGuiTypingSelectRequest_SetSearchBuffer sets value of ImGuiTypingSelectRequest.SearchBuffer
//
// Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).
func (self TypingSelectRequest) SetSearchBuffer(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSearchBuffer(selfArg, vArg)
}

// ImGuiTypingSelectRequest_GetSearchBuffer returns value of ImGuiTypingSelectRequest.SearchBuffer
//
// Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).
func (self *TypingSelectRequest) SearchBuffer() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiTypingSelectRequest_GetSearchBuffer(internal.ReinterpretCast[*C.ImGuiTypingSelectRequest](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiTypingSelectRequest_SetSelectRequest sets value of ImGuiTypingSelectRequest.SelectRequest
//
// Set when buffer was modified this frame, requesting a selection.
func (self TypingSelectRequest) SetSelectRequest(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSelectRequest(selfArg, C.bool(v))
}

// ImGuiTypingSelectRequest_GetSelectRequest returns value of ImGuiTypingSelectRequest.SelectRequest
//
// Set when buffer was modified this frame, requesting a selection.
func (self *TypingSelectRequest) SelectRequest() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTypingSelectRequest_GetSelectRequest(internal.ReinterpretCast[*C.ImGuiTypingSelectRequest](selfArg)) == C.bool(true)
}

// ImGuiTypingSelectRequest_SetSingleCharMode sets value of ImGuiTypingSelectRequest.SingleCharMode
//
// Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.
func (self TypingSelectRequest) SetSingleCharMode(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSingleCharMode(selfArg, C.bool(v))
}

// ImGuiTypingSelectRequest_GetSingleCharMode returns value of ImGuiTypingSelectRequest.SingleCharMode
//
// Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.
func (self *TypingSelectRequest) SingleCharMode() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTypingSelectRequest_GetSingleCharMode(internal.ReinterpretCast[*C.ImGuiTypingSelectRequest](selfArg)) == C.bool(true)
}

// ImGuiTypingSelectRequest_SetSingleCharSize sets value of ImGuiTypingSelectRequest.SingleCharSize
//
// Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.
func (self TypingSelectRequest) SetSingleCharSize(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectRequest_SetSingleCharSize(selfArg, C.ImS8(v))
}

// ImGuiTypingSelectRequest_GetSingleCharSize returns value of ImGuiTypingSelectRequest.SingleCharSize
//
// Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.
func (self *TypingSelectRequest) SingleCharSize() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiTypingSelectRequest_GetSingleCharSize(internal.ReinterpretCast[*C.ImGuiTypingSelectRequest](selfArg)))
}

// ImGuiTypingSelectState_SetRequest sets value of ImGuiTypingSelectState.Request
//
// User-facing data
func (self TypingSelectState) SetRequest(v TypingSelectRequest) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetRequest(selfArg, internal.ReinterpretCast[C.ImGuiTypingSelectRequest](vArg))
}

// ImGuiTypingSelectState_GetRequest returns value of ImGuiTypingSelectState.Request
//
// User-facing data
func (self *TypingSelectState) Request() TypingSelectRequest {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewTypingSelectRequestFromC(func() *C.ImGuiTypingSelectRequest {
		result := C.wrap_ImGuiTypingSelectState_GetRequest(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg))
		return &result
	}())
}

// ImGuiTypingSelectState_SetSearchBuffer sets value of ImGuiTypingSelectState.SearchBuffer[64]
//
// Search buffer: no need to make dynamic as this search is very transient.
func (self TypingSelectState) SetSearchBuffer(v *[64]rune) {
	vArg := make([]C.char, len(v))
	for i, vV := range v {
		vArg[i] = C.char(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetSearchBuffer(selfArg, (*C.char)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = rune(vV)
	}
}

// ImGuiTypingSelectState_GetSearchBuffer returns value of ImGuiTypingSelectState.SearchBuffer[64]
//
// Search buffer: no need to make dynamic as this search is very transient.
func (self *TypingSelectState) SearchBuffer() [64]rune {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [64]rune {
		result := [64]rune{}
		resultMirr := C.wrap_ImGuiTypingSelectState_GetSearchBuffer(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg))
		for i := range result {
			result[i] = rune(C.cimgui_char_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiTypingSelectState_SetFocusScope sets value of ImGuiTypingSelectState.FocusScope
func (self TypingSelectState) SetFocusScope(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetFocusScope(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiTypingSelectState_GetFocusScope returns value of ImGuiTypingSelectState.FocusScope
func (self *TypingSelectState) FocusScope() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiTypingSelectState_GetFocusScope(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg))
		return &result
	}())
}

// ImGuiTypingSelectState_SetLastRequestFrame sets value of ImGuiTypingSelectState.LastRequestFrame
func (self TypingSelectState) SetLastRequestFrame(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetLastRequestFrame(selfArg, C.int(v))
}

// ImGuiTypingSelectState_GetLastRequestFrame returns value of ImGuiTypingSelectState.LastRequestFrame
func (self *TypingSelectState) LastRequestFrame() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiTypingSelectState_GetLastRequestFrame(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg)))
}

// ImGuiTypingSelectState_SetLastRequestTime sets value of ImGuiTypingSelectState.LastRequestTime
func (self TypingSelectState) SetLastRequestTime(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetLastRequestTime(selfArg, C.float(v))
}

// ImGuiTypingSelectState_GetLastRequestTime returns value of ImGuiTypingSelectState.LastRequestTime
func (self *TypingSelectState) LastRequestTime() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiTypingSelectState_GetLastRequestTime(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg)))
}

// ImGuiTypingSelectState_SetSingleCharModeLock sets value of ImGuiTypingSelectState.SingleCharModeLock
//
// After a certain single char repeat count we lock into SingleCharMode. Two benefits: 1) buffer never fill, 2) we can provide an immediate SingleChar mode without timer elapsing.
func (self TypingSelectState) SetSingleCharModeLock(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiTypingSelectState_SetSingleCharModeLock(selfArg, C.bool(v))
}

// ImGuiTypingSelectState_GetSingleCharModeLock returns value of ImGuiTypingSelectState.SingleCharModeLock
//
// After a certain single char repeat count we lock into SingleCharMode. Two benefits: 1) buffer never fill, 2) we can provide an immediate SingleChar mode without timer elapsing.
func (self *TypingSelectState) SingleCharModeLock() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiTypingSelectState_GetSingleCharModeLock(internal.ReinterpretCast[*C.ImGuiTypingSelectState](selfArg)) == C.bool(true)
}

// ImGuiViewport_SetID sets value of ImGuiViewport.ID
//
// Unique identifier for the viewport
func (self Viewport) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiViewport_GetID returns value of ImGuiViewport.ID
//
// Unique identifier for the viewport
func (self *Viewport) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiViewport_GetID(internal.ReinterpretCast[*C.ImGuiViewport](selfArg))
		return &result
	}())
}

// ImGuiViewport_SetFlags sets value of ImGuiViewport.Flags
//
// See ImGuiViewportFlags_
func (self Viewport) SetFlags(v ViewportFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetFlags(selfArg, C.ImGuiViewportFlags(v))
}

// ImGuiViewport_GetFlags returns value of ImGuiViewport.Flags
//
// See ImGuiViewportFlags_
func (self *Viewport) Flags() ViewportFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ViewportFlags(C.wrap_ImGuiViewport_GetFlags(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)))
}

// ImGuiViewport_SetPos sets value of ImGuiViewport.Pos
//
// Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)
func (self Viewport) SetPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewport_GetPos returns value of ImGuiViewport.Pos
//
// Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)
func (self *Viewport) Pos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewport_GetPos(internal.ReinterpretCast[*C.ImGuiViewport](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewport_SetSize sets value of ImGuiViewport.Size
//
// Main Area: Size of the viewport.
func (self Viewport) SetSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewport_GetSize returns value of ImGuiViewport.Size
//
// Main Area: Size of the viewport.
func (self *Viewport) Size() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewport_GetSize(internal.ReinterpretCast[*C.ImGuiViewport](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewport_SetWorkPos sets value of ImGuiViewport.WorkPos
//
// Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)
func (self Viewport) SetWorkPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetWorkPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewport_GetWorkPos returns value of ImGuiViewport.WorkPos
//
// Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)
func (self *Viewport) WorkPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewport_GetWorkPos(internal.ReinterpretCast[*C.ImGuiViewport](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewport_SetWorkSize sets value of ImGuiViewport.WorkSize
//
// Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)
func (self Viewport) SetWorkSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetWorkSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewport_GetWorkSize returns value of ImGuiViewport.WorkSize
//
// Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)
func (self *Viewport) WorkSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewport_GetWorkSize(internal.ReinterpretCast[*C.ImGuiViewport](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewport_SetDpiScale sets value of ImGuiViewport.DpiScale
//
// 1.0f = 96 DPI = No extra scale.
func (self Viewport) SetDpiScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetDpiScale(selfArg, C.float(v))
}

// ImGuiViewport_GetDpiScale returns value of ImGuiViewport.DpiScale
//
// 1.0f = 96 DPI = No extra scale.
func (self *Viewport) DpiScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiViewport_GetDpiScale(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)))
}

// ImGuiViewport_SetParentViewportId sets value of ImGuiViewport.ParentViewportId
//
// (Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows.
func (self Viewport) SetParentViewportId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetParentViewportId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiViewport_GetParentViewportId returns value of ImGuiViewport.ParentViewportId
//
// (Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows.
func (self *Viewport) ParentViewportId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiViewport_GetParentViewportId(internal.ReinterpretCast[*C.ImGuiViewport](selfArg))
		return &result
	}())
}

// ImGuiViewport_SetDrawData sets value of ImGuiViewport.DrawData
//
// The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().
func (self Viewport) SetDrawData(v *DrawData) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetDrawData(selfArg, internal.ReinterpretCast[*C.ImDrawData](vArg))
}

// ImGuiViewport_GetDrawData returns value of ImGuiViewport.DrawData
//
// The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().
func (self *Viewport) DrawData() *DrawData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDrawDataFromC(C.wrap_ImGuiViewport_GetDrawData(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)))
}

// ImGuiViewport_SetRendererUserData sets value of ImGuiViewport.RendererUserData
//
//	// Platform/Backend Dependent Data
//	// Our design separate the Renderer and Platform backends to facilitate combining default backends with each others.
//	// When our create your own backend for a custom engine, it is possible that both Renderer and Platform will be handled
//	// by the same system and you may not need to use all the UserData/Handle fields.
//	// The library never uses those fields, they are merely storage to facilitate backend implementation.
//
// void* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.
func (self Viewport) SetRendererUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetRendererUserData(selfArg, C.uintptr_t(v))
}

// ImGuiViewport_GetRendererUserData returns value of ImGuiViewport.RendererUserData
//
//	// Platform/Backend Dependent Data
//	// Our design separate the Renderer and Platform backends to facilitate combining default backends with each others.
//	// When our create your own backend for a custom engine, it is possible that both Renderer and Platform will be handled
//	// by the same system and you may not need to use all the UserData/Handle fields.
//	// The library never uses those fields, they are merely storage to facilitate backend implementation.
//
// void* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.
func (self *Viewport) RendererUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiViewport_GetRendererUserData(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)))
}

// ImGuiViewport_SetPlatformUserData sets value of ImGuiViewport.PlatformUserData
//
// void* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.
func (self Viewport) SetPlatformUserData(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformUserData(selfArg, C.uintptr_t(v))
}

// ImGuiViewport_GetPlatformUserData returns value of ImGuiViewport.PlatformUserData
//
// void* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.
func (self *Viewport) PlatformUserData() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiViewport_GetPlatformUserData(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)))
}

// ImGuiViewport_SetPlatformHandle sets value of ImGuiViewport.PlatformHandle
//
// void* to hold higher-level, platform window handle (e.g. HWND, GLFWWindow*, SDL_Window*), for FindViewportByPlatformHandle().
func (self Viewport) SetPlatformHandle(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformHandle(selfArg, C.uintptr_t(v))
}

// ImGuiViewport_GetPlatformHandle returns value of ImGuiViewport.PlatformHandle
//
// void* to hold higher-level, platform window handle (e.g. HWND, GLFWWindow*, SDL_Window*), for FindViewportByPlatformHandle().
func (self *Viewport) PlatformHandle() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiViewport_GetPlatformHandle(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)))
}

// ImGuiViewport_SetPlatformHandleRaw sets value of ImGuiViewport.PlatformHandleRaw
//
// void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)
func (self Viewport) SetPlatformHandleRaw(v uintptr) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformHandleRaw(selfArg, C.uintptr_t(v))
}

// ImGuiViewport_GetPlatformHandleRaw returns value of ImGuiViewport.PlatformHandleRaw
//
// void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)
func (self *Viewport) PlatformHandleRaw() uintptr {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uintptr(C.wrap_ImGuiViewport_GetPlatformHandleRaw(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)))
}

// ImGuiViewport_SetPlatformWindowCreated sets value of ImGuiViewport.PlatformWindowCreated
//
// Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.
func (self Viewport) SetPlatformWindowCreated(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformWindowCreated(selfArg, C.bool(v))
}

// ImGuiViewport_GetPlatformWindowCreated returns value of ImGuiViewport.PlatformWindowCreated
//
// Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.
func (self *Viewport) PlatformWindowCreated() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformWindowCreated(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)) == C.bool(true)
}

// ImGuiViewport_SetPlatformRequestMove sets value of ImGuiViewport.PlatformRequestMove
//
// Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)
func (self Viewport) SetPlatformRequestMove(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformRequestMove(selfArg, C.bool(v))
}

// ImGuiViewport_GetPlatformRequestMove returns value of ImGuiViewport.PlatformRequestMove
//
// Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)
func (self *Viewport) PlatformRequestMove() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformRequestMove(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)) == C.bool(true)
}

// ImGuiViewport_SetPlatformRequestResize sets value of ImGuiViewport.PlatformRequestResize
//
// Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)
func (self Viewport) SetPlatformRequestResize(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformRequestResize(selfArg, C.bool(v))
}

// ImGuiViewport_GetPlatformRequestResize returns value of ImGuiViewport.PlatformRequestResize
//
// Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)
func (self *Viewport) PlatformRequestResize() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformRequestResize(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)) == C.bool(true)
}

// ImGuiViewport_SetPlatformRequestClose sets value of ImGuiViewport.PlatformRequestClose
//
// Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)
func (self Viewport) SetPlatformRequestClose(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewport_SetPlatformRequestClose(selfArg, C.bool(v))
}

// ImGuiViewport_GetPlatformRequestClose returns value of ImGuiViewport.PlatformRequestClose
//
// Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)
func (self *Viewport) PlatformRequestClose() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewport_GetPlatformRequestClose(internal.ReinterpretCast[*C.ImGuiViewport](selfArg)) == C.bool(true)
}

// ImGuiViewportP_Set_ImGuiViewport sets value of ImGuiViewportP._ImGuiViewport
func (self ViewportP) SetImGuiViewport(v Viewport) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_Set_ImGuiViewport(selfArg, internal.ReinterpretCast[C.ImGuiViewport](vArg))
}

// ImGuiViewportP_Get_ImGuiViewport returns value of ImGuiViewportP._ImGuiViewport
func (self *ViewportP) ImGuiViewport() Viewport {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewViewportFromC(func() *C.ImGuiViewport {
		result := C.wrap_ImGuiViewportP_Get_ImGuiViewport(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return &result
	}())
}

// ImGuiViewportP_SetWindow sets value of ImGuiViewportP.Window
//
// Set when the viewport is owned by a window (and ImGuiViewportFlags_CanHostOtherWindows is NOT set)
func (self ViewportP) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiViewportP_GetWindow returns value of ImGuiViewportP.Window
//
// Set when the viewport is owned by a window (and ImGuiViewportFlags_CanHostOtherWindows is NOT set)
func (self *ViewportP) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiViewportP_GetWindow(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)))
}

// ImGuiViewportP_SetIdx sets value of ImGuiViewportP.Idx
func (self ViewportP) SetIdx(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetIdx(selfArg, C.int(v))
}

// ImGuiViewportP_GetIdx returns value of ImGuiViewportP.Idx
func (self *ViewportP) Idx() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiViewportP_GetIdx(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)))
}

// ImGuiViewportP_SetLastFrameActive sets value of ImGuiViewportP.LastFrameActive
//
// Last frame number this viewport was activated by a window
func (self ViewportP) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastFrameActive(selfArg, C.int(v))
}

// ImGuiViewportP_GetLastFrameActive returns value of ImGuiViewportP.LastFrameActive
//
// Last frame number this viewport was activated by a window
func (self *ViewportP) LastFrameActive() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiViewportP_GetLastFrameActive(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)))
}

// ImGuiViewportP_SetLastFocusedStampCount sets value of ImGuiViewportP.LastFocusedStampCount
//
// Last stamp number from when a window hosted by this viewport was focused (by comparing this value between two viewport we have an implicit viewport z-order we use as fallback)
func (self ViewportP) SetLastFocusedStampCount(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastFocusedStampCount(selfArg, C.int(v))
}

// ImGuiViewportP_GetLastFocusedStampCount returns value of ImGuiViewportP.LastFocusedStampCount
//
// Last stamp number from when a window hosted by this viewport was focused (by comparing this value between two viewport we have an implicit viewport z-order we use as fallback)
func (self *ViewportP) LastFocusedStampCount() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiViewportP_GetLastFocusedStampCount(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)))
}

// ImGuiViewportP_SetLastNameHash sets value of ImGuiViewportP.LastNameHash
func (self ViewportP) SetLastNameHash(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastNameHash(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiViewportP_GetLastNameHash returns value of ImGuiViewportP.LastNameHash
func (self *ViewportP) LastNameHash() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiViewportP_GetLastNameHash(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return &result
	}())
}

// ImGuiViewportP_SetLastPos sets value of ImGuiViewportP.LastPos
func (self ViewportP) SetLastPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetLastPos returns value of ImGuiViewportP.LastPos
func (self *ViewportP) LastPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetLastPos(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetLastSize sets value of ImGuiViewportP.LastSize
func (self ViewportP) SetLastSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetLastSize returns value of ImGuiViewportP.LastSize
func (self *ViewportP) LastSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetLastSize(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetAlpha sets value of ImGuiViewportP.Alpha
//
// Window opacity (when dragging dockable windows/viewports we make them transparent)
func (self ViewportP) SetAlpha(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetAlpha(selfArg, C.float(v))
}

// ImGuiViewportP_GetAlpha returns value of ImGuiViewportP.Alpha
//
// Window opacity (when dragging dockable windows/viewports we make them transparent)
func (self *ViewportP) Alpha() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiViewportP_GetAlpha(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)))
}

// ImGuiViewportP_SetLastAlpha sets value of ImGuiViewportP.LastAlpha
func (self ViewportP) SetLastAlpha(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastAlpha(selfArg, C.float(v))
}

// ImGuiViewportP_GetLastAlpha returns value of ImGuiViewportP.LastAlpha
func (self *ViewportP) LastAlpha() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiViewportP_GetLastAlpha(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)))
}

// ImGuiViewportP_SetLastFocusedHadNavWindow sets value of ImGuiViewportP.LastFocusedHadNavWindow
//
// Instead of maintaining a LastFocusedWindow (which may harder to correctly maintain), we merely store weither NavWindow != NULL last time the viewport was focused.
func (self ViewportP) SetLastFocusedHadNavWindow(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastFocusedHadNavWindow(selfArg, C.bool(v))
}

// ImGuiViewportP_GetLastFocusedHadNavWindow returns value of ImGuiViewportP.LastFocusedHadNavWindow
//
// Instead of maintaining a LastFocusedWindow (which may harder to correctly maintain), we merely store weither NavWindow != NULL last time the viewport was focused.
func (self *ViewportP) LastFocusedHadNavWindow() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiViewportP_GetLastFocusedHadNavWindow(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)) == C.bool(true)
}

// ImGuiViewportP_SetPlatformMonitor sets value of ImGuiViewportP.PlatformMonitor
func (self ViewportP) SetPlatformMonitor(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetPlatformMonitor(selfArg, C.short(v))
}

// ImGuiViewportP_GetPlatformMonitor returns value of ImGuiViewportP.PlatformMonitor
func (self *ViewportP) PlatformMonitor() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiViewportP_GetPlatformMonitor(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg)))
}

// ImGuiViewportP_SetBgFgDrawListsLastFrame sets value of ImGuiViewportP.BgFgDrawListsLastFrame[2]
//
// Last frame number the background (0) and foreground (1) draw lists were used
func (self ViewportP) SetBgFgDrawListsLastFrame(v *[2]int32) {
	vArg := make([]C.int, len(v))
	for i, vV := range v {
		vArg[i] = C.int(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetBgFgDrawListsLastFrame(selfArg, (*C.int)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = int32(vV)
	}
}

// ImGuiViewportP_GetBgFgDrawListsLastFrame returns value of ImGuiViewportP.BgFgDrawListsLastFrame[2]
//
// Last frame number the background (0) and foreground (1) draw lists were used
func (self *ViewportP) BgFgDrawListsLastFrame() [2]int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [2]int32 {
		result := [2]int32{}
		resultMirr := C.wrap_ImGuiViewportP_GetBgFgDrawListsLastFrame(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		for i := range result {
			result[i] = int32(C.cimgui_int_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiViewportP_SetBgFgDrawLists sets value of ImGuiViewportP.BgFgDrawLists[2]
//
// Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.
func (self ViewportP) SetBgFgDrawLists(v *[2]*DrawList) {
	vArg := make([]*C.ImDrawList, len(v))
	for i, vV := range v {
		vVArg, _ := vV.Handle()
		vArg[i] = internal.ReinterpretCast[*C.ImDrawList](vVArg)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetBgFgDrawLists(selfArg, (**C.ImDrawList)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = NewDrawListFromC(vV)
	}
}

// ImGuiViewportP_GetBgFgDrawLists returns value of ImGuiViewportP.BgFgDrawLists[2]
//
// Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.
func (self *ViewportP) BgFgDrawLists() [2]*DrawList {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [2]*DrawList {
		result := [2]*DrawList{}
		resultMirr := C.wrap_ImGuiViewportP_GetBgFgDrawLists(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		for i := range result {
			result[i] = NewDrawListFromC(C.cimgui_ImDrawListPtr_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiViewportP_SetDrawDataP sets value of ImGuiViewportP.DrawDataP
func (self ViewportP) SetDrawDataP(v DrawData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetDrawDataP(selfArg, internal.ReinterpretCast[C.ImDrawData](vArg))
}

// ImGuiViewportP_GetDrawDataP returns value of ImGuiViewportP.DrawDataP
func (self *ViewportP) DrawDataP() DrawData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawDataFromC(func() *C.ImDrawData {
		result := C.wrap_ImGuiViewportP_GetDrawDataP(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return &result
	}())
}

// ImGuiViewportP_SetDrawDataBuilder sets value of ImGuiViewportP.DrawDataBuilder
//
// Temporary data while building final ImDrawData
func (self ViewportP) SetDrawDataBuilder(v DrawDataBuilder) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetDrawDataBuilder(selfArg, internal.ReinterpretCast[C.ImDrawDataBuilder](vArg))
}

// ImGuiViewportP_GetDrawDataBuilder returns value of ImGuiViewportP.DrawDataBuilder
//
// Temporary data while building final ImDrawData
func (self *ViewportP) DrawDataBuilder() DrawDataBuilder {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawDataBuilderFromC(func() *C.ImDrawDataBuilder {
		result := C.wrap_ImGuiViewportP_GetDrawDataBuilder(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return &result
	}())
}

// ImGuiViewportP_SetLastPlatformPos sets value of ImGuiViewportP.LastPlatformPos
func (self ViewportP) SetLastPlatformPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastPlatformPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetLastPlatformPos returns value of ImGuiViewportP.LastPlatformPos
func (self *ViewportP) LastPlatformPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetLastPlatformPos(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetLastPlatformSize sets value of ImGuiViewportP.LastPlatformSize
func (self ViewportP) SetLastPlatformSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastPlatformSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetLastPlatformSize returns value of ImGuiViewportP.LastPlatformSize
func (self *ViewportP) LastPlatformSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetLastPlatformSize(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetLastRendererSize sets value of ImGuiViewportP.LastRendererSize
func (self ViewportP) SetLastRendererSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetLastRendererSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetLastRendererSize returns value of ImGuiViewportP.LastRendererSize
func (self *ViewportP) LastRendererSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetLastRendererSize(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetWorkInsetMin sets value of ImGuiViewportP.WorkInsetMin
//
//	// Per-viewport work area
//	// - Insets are >= 0.0f values, distance from viewport corners to work area.
//	// - BeginMainMenuBar() and DockspaceOverViewport() tend to use work area to avoid stepping over existing contents.
//	// - Generally 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.
//
// Work Area inset locked for the frame. GetWorkRect() always fits within GetMainRect().
func (self ViewportP) SetWorkInsetMin(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetWorkInsetMin(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetWorkInsetMin returns value of ImGuiViewportP.WorkInsetMin
//
//	// Per-viewport work area
//	// - Insets are >= 0.0f values, distance from viewport corners to work area.
//	// - BeginMainMenuBar() and DockspaceOverViewport() tend to use work area to avoid stepping over existing contents.
//	// - Generally 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.
//
// Work Area inset locked for the frame. GetWorkRect() always fits within GetMainRect().
func (self *ViewportP) WorkInsetMin() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetWorkInsetMin(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetWorkInsetMax sets value of ImGuiViewportP.WorkInsetMax
//
// "
func (self ViewportP) SetWorkInsetMax(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetWorkInsetMax(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetWorkInsetMax returns value of ImGuiViewportP.WorkInsetMax
//
// "
func (self *ViewportP) WorkInsetMax() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetWorkInsetMax(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetBuildWorkInsetMin sets value of ImGuiViewportP.BuildWorkInsetMin
//
// Work Area inset accumulator for current frame, to become next frame's WorkInset
func (self ViewportP) SetBuildWorkInsetMin(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetBuildWorkInsetMin(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetBuildWorkInsetMin returns value of ImGuiViewportP.BuildWorkInsetMin
//
// Work Area inset accumulator for current frame, to become next frame's WorkInset
func (self *ViewportP) BuildWorkInsetMin() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetBuildWorkInsetMin(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiViewportP_SetBuildWorkInsetMax sets value of ImGuiViewportP.BuildWorkInsetMax
//
// "
func (self ViewportP) SetBuildWorkInsetMax(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiViewportP_SetBuildWorkInsetMax(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiViewportP_GetBuildWorkInsetMax returns value of ImGuiViewportP.BuildWorkInsetMax
//
// "
func (self *ViewportP) BuildWorkInsetMax() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiViewportP_GetBuildWorkInsetMax(internal.ReinterpretCast[*C.ImGuiViewportP](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetCtx sets value of ImGuiWindow.Ctx
//
// Parent UI context (needs to be set explicitly by parent).
func (self Window) SetCtx(v *Context) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetCtx(selfArg, internal.ReinterpretCast[*C.ImGuiContext](vArg))
}

// ImGuiWindow_GetCtx returns value of ImGuiWindow.Ctx
//
// Parent UI context (needs to be set explicitly by parent).
func (self *Window) Ctx() *Context {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewContextFromC(C.wrap_ImGuiWindow_GetCtx(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetName sets value of ImGuiWindow.Name
//
// Window name, owned by the window.
func (self Window) SetName(v string) {
	vArg, _ := internal.WrapString[C.char](v)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetName(selfArg, vArg)
}

// ImGuiWindow_GetName returns value of ImGuiWindow.Name
//
// Window name, owned by the window.
func (self *Window) Name() string {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() string {
		result := C.wrap_ImGuiWindow_GetName(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		defer C.free(unsafe.Pointer(result))
		return C.GoString(result)
	}()
}

// ImGuiWindow_SetID sets value of ImGuiWindow.ID
//
// == ImHashStr(Name)
func (self Window) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetID returns value of ImGuiWindow.ID
//
// == ImHashStr(Name)
func (self *Window) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetID(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetFlags sets value of ImGuiWindow.Flags
//
// See enum ImGuiWindowFlags_
func (self Window) SetFlags(v WindowFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFlags(selfArg, C.ImGuiWindowFlags(v))
}

// ImGuiWindow_GetFlags returns value of ImGuiWindow.Flags
//
// See enum ImGuiWindowFlags_
func (self *Window) Flags() WindowFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return WindowFlags(C.wrap_ImGuiWindow_GetFlags(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetFlagsPreviousFrame sets value of ImGuiWindow.FlagsPreviousFrame
//
// See enum ImGuiWindowFlags_
func (self Window) SetFlagsPreviousFrame(v WindowFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFlagsPreviousFrame(selfArg, C.ImGuiWindowFlags(v))
}

// ImGuiWindow_GetFlagsPreviousFrame returns value of ImGuiWindow.FlagsPreviousFrame
//
// See enum ImGuiWindowFlags_
func (self *Window) FlagsPreviousFrame() WindowFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return WindowFlags(C.wrap_ImGuiWindow_GetFlagsPreviousFrame(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetChildFlags sets value of ImGuiWindow.ChildFlags
//
// Set when window is a child window. See enum ImGuiChildFlags_
func (self Window) SetChildFlags(v ChildFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetChildFlags(selfArg, C.ImGuiChildFlags(v))
}

// ImGuiWindow_GetChildFlags returns value of ImGuiWindow.ChildFlags
//
// Set when window is a child window. See enum ImGuiChildFlags_
func (self *Window) ChildFlags() ChildFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ChildFlags(C.wrap_ImGuiWindow_GetChildFlags(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetWindowClass sets value of ImGuiWindow.WindowClass
//
// Advanced users only. Set with SetNextWindowClass()
func (self Window) SetWindowClass(v WindowClass) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowClass(selfArg, internal.ReinterpretCast[C.ImGuiWindowClass](vArg))
}

// ImGuiWindow_GetWindowClass returns value of ImGuiWindow.WindowClass
//
// Advanced users only. Set with SetNextWindowClass()
func (self *Window) WindowClass() WindowClass {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewWindowClassFromC(func() *C.ImGuiWindowClass {
		result := C.wrap_ImGuiWindow_GetWindowClass(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetViewport sets value of ImGuiWindow.Viewport
//
// Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.
func (self Window) SetViewport(v *ViewportP) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewport(selfArg, internal.ReinterpretCast[*C.ImGuiViewportP](vArg))
}

// ImGuiWindow_GetViewport returns value of ImGuiWindow.Viewport
//
// Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.
func (self *Window) Viewport() *ViewportP {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewViewportPFromC(C.wrap_ImGuiWindow_GetViewport(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetViewportId sets value of ImGuiWindow.ViewportId
//
// We backup the viewport id (since the viewport may disappear or never be created if the window is inactive)
func (self Window) SetViewportId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetViewportId returns value of ImGuiWindow.ViewportId
//
// We backup the viewport id (since the viewport may disappear or never be created if the window is inactive)
func (self *Window) ViewportId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetViewportId(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetViewportPos sets value of ImGuiWindow.ViewportPos
//
// We backup the viewport position (since the viewport may disappear or never be created if the window is inactive)
func (self Window) SetViewportPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetViewportPos returns value of ImGuiWindow.ViewportPos
//
// We backup the viewport position (since the viewport may disappear or never be created if the window is inactive)
func (self *Window) ViewportPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetViewportPos(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetViewportAllowPlatformMonitorExtend sets value of ImGuiWindow.ViewportAllowPlatformMonitorExtend
//
// Reset to -1 every frame (index is guaranteed to be valid between NewFrame..EndFrame), only used in the Appearing frame of a tooltip/popup to enforce clamping to a given monitor
func (self Window) SetViewportAllowPlatformMonitorExtend(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportAllowPlatformMonitorExtend(selfArg, C.int(v))
}

// ImGuiWindow_GetViewportAllowPlatformMonitorExtend returns value of ImGuiWindow.ViewportAllowPlatformMonitorExtend
//
// Reset to -1 every frame (index is guaranteed to be valid between NewFrame..EndFrame), only used in the Appearing frame of a tooltip/popup to enforce clamping to a given monitor
func (self *Window) ViewportAllowPlatformMonitorExtend() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetViewportAllowPlatformMonitorExtend(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetPos sets value of ImGuiWindow.Pos
//
// Position (always rounded-up to nearest pixel)
func (self Window) SetPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetPos returns value of ImGuiWindow.Pos
//
// Position (always rounded-up to nearest pixel)
func (self *Window) Pos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetPos(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetSize sets value of ImGuiWindow.Size
//
// Current size (==SizeFull or collapsed title bar size)
func (self Window) SetSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetSize returns value of ImGuiWindow.Size
//
// Current size (==SizeFull or collapsed title bar size)
func (self *Window) Size() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetSize(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetSizeFull sets value of ImGuiWindow.SizeFull
//
// Size when non collapsed
func (self Window) SetSizeFull(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSizeFull(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetSizeFull returns value of ImGuiWindow.SizeFull
//
// Size when non collapsed
func (self *Window) SizeFull() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetSizeFull(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetContentSize sets value of ImGuiWindow.ContentSize
//
// Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
func (self Window) SetContentSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetContentSize returns value of ImGuiWindow.ContentSize
//
// Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
func (self *Window) ContentSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetContentSize(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetContentSizeIdeal sets value of ImGuiWindow.ContentSizeIdeal
func (self Window) SetContentSizeIdeal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentSizeIdeal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetContentSizeIdeal returns value of ImGuiWindow.ContentSizeIdeal
func (self *Window) ContentSizeIdeal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetContentSizeIdeal(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetContentSizeExplicit sets value of ImGuiWindow.ContentSizeExplicit
//
// Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
func (self Window) SetContentSizeExplicit(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentSizeExplicit(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetContentSizeExplicit returns value of ImGuiWindow.ContentSizeExplicit
//
// Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
func (self *Window) ContentSizeExplicit() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetContentSizeExplicit(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetWindowPadding sets value of ImGuiWindow.WindowPadding
//
// Window padding at the time of Begin().
func (self Window) SetWindowPadding(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowPadding(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetWindowPadding returns value of ImGuiWindow.WindowPadding
//
// Window padding at the time of Begin().
func (self *Window) WindowPadding() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetWindowPadding(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetWindowRounding sets value of ImGuiWindow.WindowRounding
//
// Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.
func (self Window) SetWindowRounding(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowRounding(selfArg, C.float(v))
}

// ImGuiWindow_GetWindowRounding returns value of ImGuiWindow.WindowRounding
//
// Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.
func (self *Window) WindowRounding() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetWindowRounding(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetWindowBorderSize sets value of ImGuiWindow.WindowBorderSize
//
// Window border size at the time of Begin().
func (self Window) SetWindowBorderSize(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWindowBorderSize(selfArg, C.float(v))
}

// ImGuiWindow_GetWindowBorderSize returns value of ImGuiWindow.WindowBorderSize
//
// Window border size at the time of Begin().
func (self *Window) WindowBorderSize() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetWindowBorderSize(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetTitleBarHeight sets value of ImGuiWindow.TitleBarHeight
//
// Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.
func (self Window) SetTitleBarHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetTitleBarHeight(selfArg, C.float(v))
}

// ImGuiWindow_GetTitleBarHeight returns value of ImGuiWindow.TitleBarHeight
//
// Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.
func (self *Window) TitleBarHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetTitleBarHeight(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetMenuBarHeight sets value of ImGuiWindow.MenuBarHeight
//
// Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.
func (self Window) SetMenuBarHeight(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMenuBarHeight(selfArg, C.float(v))
}

// ImGuiWindow_GetMenuBarHeight returns value of ImGuiWindow.MenuBarHeight
//
// Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.
func (self *Window) MenuBarHeight() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetMenuBarHeight(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDecoOuterSizeX1 sets value of ImGuiWindow.DecoOuterSizeX1
//
// Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
func (self Window) SetDecoOuterSizeX1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeX1(selfArg, C.float(v))
}

// ImGuiWindow_GetDecoOuterSizeX1 returns value of ImGuiWindow.DecoOuterSizeX1
//
// Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
func (self *Window) DecoOuterSizeX1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeX1(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDecoOuterSizeY1 sets value of ImGuiWindow.DecoOuterSizeY1
//
// Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
func (self Window) SetDecoOuterSizeY1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeY1(selfArg, C.float(v))
}

// ImGuiWindow_GetDecoOuterSizeY1 returns value of ImGuiWindow.DecoOuterSizeY1
//
// Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
func (self *Window) DecoOuterSizeY1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeY1(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDecoOuterSizeX2 sets value of ImGuiWindow.DecoOuterSizeX2
//
// Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
func (self Window) SetDecoOuterSizeX2(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeX2(selfArg, C.float(v))
}

// ImGuiWindow_GetDecoOuterSizeX2 returns value of ImGuiWindow.DecoOuterSizeX2
//
// Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
func (self *Window) DecoOuterSizeX2() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeX2(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDecoOuterSizeY2 sets value of ImGuiWindow.DecoOuterSizeY2
//
// Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
func (self Window) SetDecoOuterSizeY2(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoOuterSizeY2(selfArg, C.float(v))
}

// ImGuiWindow_GetDecoOuterSizeY2 returns value of ImGuiWindow.DecoOuterSizeY2
//
// Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
func (self *Window) DecoOuterSizeY2() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoOuterSizeY2(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDecoInnerSizeX1 sets value of ImGuiWindow.DecoInnerSizeX1
//
// Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
func (self Window) SetDecoInnerSizeX1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoInnerSizeX1(selfArg, C.float(v))
}

// ImGuiWindow_GetDecoInnerSizeX1 returns value of ImGuiWindow.DecoInnerSizeX1
//
// Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
func (self *Window) DecoInnerSizeX1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoInnerSizeX1(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDecoInnerSizeY1 sets value of ImGuiWindow.DecoInnerSizeY1
//
// Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
func (self Window) SetDecoInnerSizeY1(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDecoInnerSizeY1(selfArg, C.float(v))
}

// ImGuiWindow_GetDecoInnerSizeY1 returns value of ImGuiWindow.DecoInnerSizeY1
//
// Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
func (self *Window) DecoInnerSizeY1() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetDecoInnerSizeY1(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetNameBufLen sets value of ImGuiWindow.NameBufLen
//
// Size of buffer storing Name. May be larger than strlen(Name)!
func (self Window) SetNameBufLen(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNameBufLen(selfArg, C.int(v))
}

// ImGuiWindow_GetNameBufLen returns value of ImGuiWindow.NameBufLen
//
// Size of buffer storing Name. May be larger than strlen(Name)!
func (self *Window) NameBufLen() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetNameBufLen(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetMoveId sets value of ImGuiWindow.MoveId
//
// == window->GetID("#MOVE")
func (self Window) SetMoveId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMoveId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetMoveId returns value of ImGuiWindow.MoveId
//
// == window->GetID("#MOVE")
func (self *Window) MoveId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetMoveId(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetTabId sets value of ImGuiWindow.TabId
//
// == window->GetID("#TAB")
func (self Window) SetTabId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetTabId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetTabId returns value of ImGuiWindow.TabId
//
// == window->GetID("#TAB")
func (self *Window) TabId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetTabId(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetChildId sets value of ImGuiWindow.ChildId
//
// ID of corresponding item in parent window (for navigation to return from child window to parent window)
func (self Window) SetChildId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetChildId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetChildId returns value of ImGuiWindow.ChildId
//
// ID of corresponding item in parent window (for navigation to return from child window to parent window)
func (self *Window) ChildId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetChildId(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetPopupId sets value of ImGuiWindow.PopupId
//
// ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
func (self Window) SetPopupId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetPopupId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetPopupId returns value of ImGuiWindow.PopupId
//
// ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
func (self *Window) PopupId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetPopupId(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetScroll sets value of ImGuiWindow.Scroll
func (self Window) SetScroll(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScroll(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetScroll returns value of ImGuiWindow.Scroll
func (self *Window) Scroll() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetScroll(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetScrollMax sets value of ImGuiWindow.ScrollMax
func (self Window) SetScrollMax(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollMax(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetScrollMax returns value of ImGuiWindow.ScrollMax
func (self *Window) ScrollMax() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetScrollMax(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetScrollTarget sets value of ImGuiWindow.ScrollTarget
//
// target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
func (self Window) SetScrollTarget(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollTarget(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetScrollTarget returns value of ImGuiWindow.ScrollTarget
//
// target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
func (self *Window) ScrollTarget() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetScrollTarget(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetScrollTargetCenterRatio sets value of ImGuiWindow.ScrollTargetCenterRatio
//
// 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
func (self Window) SetScrollTargetCenterRatio(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollTargetCenterRatio(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetScrollTargetCenterRatio returns value of ImGuiWindow.ScrollTargetCenterRatio
//
// 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
func (self *Window) ScrollTargetCenterRatio() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetScrollTargetCenterRatio(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetScrollTargetEdgeSnapDist sets value of ImGuiWindow.ScrollTargetEdgeSnapDist
//
// 0.0f = no snapping, >0.0f snapping threshold
func (self Window) SetScrollTargetEdgeSnapDist(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollTargetEdgeSnapDist(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetScrollTargetEdgeSnapDist returns value of ImGuiWindow.ScrollTargetEdgeSnapDist
//
// 0.0f = no snapping, >0.0f snapping threshold
func (self *Window) ScrollTargetEdgeSnapDist() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetScrollTargetEdgeSnapDist(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetScrollbarSizes sets value of ImGuiWindow.ScrollbarSizes
//
// Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
func (self Window) SetScrollbarSizes(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollbarSizes(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetScrollbarSizes returns value of ImGuiWindow.ScrollbarSizes
//
// Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
func (self *Window) ScrollbarSizes() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetScrollbarSizes(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetScrollbarX sets value of ImGuiWindow.ScrollbarX
//
// Are scrollbars visible?
func (self Window) SetScrollbarX(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollbarX(selfArg, C.bool(v))
}

// ImGuiWindow_GetScrollbarX returns value of ImGuiWindow.ScrollbarX
//
// Are scrollbars visible?
func (self *Window) ScrollbarX() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetScrollbarX(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetScrollbarY sets value of ImGuiWindow.ScrollbarY
//
// Are scrollbars visible?
func (self Window) SetScrollbarY(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetScrollbarY(selfArg, C.bool(v))
}

// ImGuiWindow_GetScrollbarY returns value of ImGuiWindow.ScrollbarY
//
// Are scrollbars visible?
func (self *Window) ScrollbarY() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetScrollbarY(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetViewportOwned sets value of ImGuiWindow.ViewportOwned
func (self Window) SetViewportOwned(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetViewportOwned(selfArg, C.bool(v))
}

// ImGuiWindow_GetViewportOwned returns value of ImGuiWindow.ViewportOwned
func (self *Window) ViewportOwned() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetViewportOwned(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetActive sets value of ImGuiWindow.Active
//
// Set to true on Begin(), unless Collapsed
func (self Window) SetActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetActive(selfArg, C.bool(v))
}

// ImGuiWindow_GetActive returns value of ImGuiWindow.Active
//
// Set to true on Begin(), unless Collapsed
func (self *Window) Active() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetActive(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetWasActive sets value of ImGuiWindow.WasActive
func (self Window) SetWasActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWasActive(selfArg, C.bool(v))
}

// ImGuiWindow_GetWasActive returns value of ImGuiWindow.WasActive
func (self *Window) WasActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetWasActive(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetWriteAccessed sets value of ImGuiWindow.WriteAccessed
//
// Set to true when any widget access the current window
func (self Window) SetWriteAccessed(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWriteAccessed(selfArg, C.bool(v))
}

// ImGuiWindow_GetWriteAccessed returns value of ImGuiWindow.WriteAccessed
//
// Set to true when any widget access the current window
func (self *Window) WriteAccessed() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetWriteAccessed(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetCollapsed sets value of ImGuiWindow.Collapsed
//
// Set when collapsing window to become only title-bar
func (self Window) SetCollapsed(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetCollapsed(selfArg, C.bool(v))
}

// ImGuiWindow_GetCollapsed returns value of ImGuiWindow.Collapsed
//
// Set when collapsing window to become only title-bar
func (self *Window) Collapsed() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetCollapsed(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetWantCollapseToggle sets value of ImGuiWindow.WantCollapseToggle
func (self Window) SetWantCollapseToggle(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWantCollapseToggle(selfArg, C.bool(v))
}

// ImGuiWindow_GetWantCollapseToggle returns value of ImGuiWindow.WantCollapseToggle
func (self *Window) WantCollapseToggle() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetWantCollapseToggle(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetSkipItems sets value of ImGuiWindow.SkipItems
//
// Set when items can safely be all clipped (e.g. window not visible or collapsed)
func (self Window) SetSkipItems(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSkipItems(selfArg, C.bool(v))
}

// ImGuiWindow_GetSkipItems returns value of ImGuiWindow.SkipItems
//
// Set when items can safely be all clipped (e.g. window not visible or collapsed)
func (self *Window) SkipItems() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetSkipItems(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetSkipRefresh sets value of ImGuiWindow.SkipRefresh
//
// [EXPERIMENTAL] Reuse previous frame drawn contents, Begin() returns false.
func (self Window) SetSkipRefresh(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSkipRefresh(selfArg, C.bool(v))
}

// ImGuiWindow_GetSkipRefresh returns value of ImGuiWindow.SkipRefresh
//
// [EXPERIMENTAL] Reuse previous frame drawn contents, Begin() returns false.
func (self *Window) SkipRefresh() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetSkipRefresh(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetAppearing sets value of ImGuiWindow.Appearing
//
// Set during the frame where the window is appearing (or re-appearing)
func (self Window) SetAppearing(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAppearing(selfArg, C.bool(v))
}

// ImGuiWindow_GetAppearing returns value of ImGuiWindow.Appearing
//
// Set during the frame where the window is appearing (or re-appearing)
func (self *Window) Appearing() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetAppearing(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetHidden sets value of ImGuiWindow.Hidden
//
// Do not display (== HiddenFrames*** > 0)
func (self Window) SetHidden(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHidden(selfArg, C.bool(v))
}

// ImGuiWindow_GetHidden returns value of ImGuiWindow.Hidden
//
// Do not display (== HiddenFrames*** > 0)
func (self *Window) Hidden() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetHidden(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetIsFallbackWindow sets value of ImGuiWindow.IsFallbackWindow
//
// Set on the "Debug##Default" window.
func (self Window) SetIsFallbackWindow(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetIsFallbackWindow(selfArg, C.bool(v))
}

// ImGuiWindow_GetIsFallbackWindow returns value of ImGuiWindow.IsFallbackWindow
//
// Set on the "Debug##Default" window.
func (self *Window) IsFallbackWindow() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetIsFallbackWindow(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetIsExplicitChild sets value of ImGuiWindow.IsExplicitChild
//
// Set when passed _ChildWindow, left to false by BeginDocked()
func (self Window) SetIsExplicitChild(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetIsExplicitChild(selfArg, C.bool(v))
}

// ImGuiWindow_GetIsExplicitChild returns value of ImGuiWindow.IsExplicitChild
//
// Set when passed _ChildWindow, left to false by BeginDocked()
func (self *Window) IsExplicitChild() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetIsExplicitChild(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetHasCloseButton sets value of ImGuiWindow.HasCloseButton
//
// Set when the window has a close button (p_open != NULL)
func (self Window) SetHasCloseButton(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHasCloseButton(selfArg, C.bool(v))
}

// ImGuiWindow_GetHasCloseButton returns value of ImGuiWindow.HasCloseButton
//
// Set when the window has a close button (p_open != NULL)
func (self *Window) HasCloseButton() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetHasCloseButton(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetBeginCount sets value of ImGuiWindow.BeginCount
//
// Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
func (self Window) SetBeginCount(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginCount(selfArg, C.short(v))
}

// ImGuiWindow_GetBeginCount returns value of ImGuiWindow.BeginCount
//
// Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
func (self *Window) BeginCount() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginCount(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetBeginCountPreviousFrame sets value of ImGuiWindow.BeginCountPreviousFrame
//
// Number of Begin() during the previous frame
func (self Window) SetBeginCountPreviousFrame(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginCountPreviousFrame(selfArg, C.short(v))
}

// ImGuiWindow_GetBeginCountPreviousFrame returns value of ImGuiWindow.BeginCountPreviousFrame
//
// Number of Begin() during the previous frame
func (self *Window) BeginCountPreviousFrame() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginCountPreviousFrame(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetBeginOrderWithinParent sets value of ImGuiWindow.BeginOrderWithinParent
//
// Begin() order within immediate parent window, if we are a child window. Otherwise 0.
func (self Window) SetBeginOrderWithinParent(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginOrderWithinParent(selfArg, C.short(v))
}

// ImGuiWindow_GetBeginOrderWithinParent returns value of ImGuiWindow.BeginOrderWithinParent
//
// Begin() order within immediate parent window, if we are a child window. Otherwise 0.
func (self *Window) BeginOrderWithinParent() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginOrderWithinParent(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetBeginOrderWithinContext sets value of ImGuiWindow.BeginOrderWithinContext
//
// Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.
func (self Window) SetBeginOrderWithinContext(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetBeginOrderWithinContext(selfArg, C.short(v))
}

// ImGuiWindow_GetBeginOrderWithinContext returns value of ImGuiWindow.BeginOrderWithinContext
//
// Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.
func (self *Window) BeginOrderWithinContext() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetBeginOrderWithinContext(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetFocusOrder sets value of ImGuiWindow.FocusOrder
//
// Order within WindowsFocusOrder[], altered when windows are focused.
func (self Window) SetFocusOrder(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFocusOrder(selfArg, C.short(v))
}

// ImGuiWindow_GetFocusOrder returns value of ImGuiWindow.FocusOrder
//
// Order within WindowsFocusOrder[], altered when windows are focused.
func (self *Window) FocusOrder() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetFocusOrder(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetAutoFitFramesX sets value of ImGuiWindow.AutoFitFramesX
func (self Window) SetAutoFitFramesX(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoFitFramesX(selfArg, C.ImS8(v))
}

// ImGuiWindow_GetAutoFitFramesX returns value of ImGuiWindow.AutoFitFramesX
func (self *Window) AutoFitFramesX() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetAutoFitFramesX(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetAutoFitFramesY sets value of ImGuiWindow.AutoFitFramesY
func (self Window) SetAutoFitFramesY(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoFitFramesY(selfArg, C.ImS8(v))
}

// ImGuiWindow_GetAutoFitFramesY returns value of ImGuiWindow.AutoFitFramesY
func (self *Window) AutoFitFramesY() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetAutoFitFramesY(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetAutoFitOnlyGrows sets value of ImGuiWindow.AutoFitOnlyGrows
func (self Window) SetAutoFitOnlyGrows(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoFitOnlyGrows(selfArg, C.bool(v))
}

// ImGuiWindow_GetAutoFitOnlyGrows returns value of ImGuiWindow.AutoFitOnlyGrows
func (self *Window) AutoFitOnlyGrows() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetAutoFitOnlyGrows(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetAutoPosLastDirection sets value of ImGuiWindow.AutoPosLastDirection
func (self Window) SetAutoPosLastDirection(v Dir) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetAutoPosLastDirection(selfArg, C.ImGuiDir(v))
}

// ImGuiWindow_GetAutoPosLastDirection returns value of ImGuiWindow.AutoPosLastDirection
func (self *Window) AutoPosLastDirection() Dir {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Dir(C.wrap_ImGuiWindow_GetAutoPosLastDirection(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetHiddenFramesCanSkipItems sets value of ImGuiWindow.HiddenFramesCanSkipItems
//
// Hide the window for N frames
func (self Window) SetHiddenFramesCanSkipItems(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHiddenFramesCanSkipItems(selfArg, C.ImS8(v))
}

// ImGuiWindow_GetHiddenFramesCanSkipItems returns value of ImGuiWindow.HiddenFramesCanSkipItems
//
// Hide the window for N frames
func (self *Window) HiddenFramesCanSkipItems() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetHiddenFramesCanSkipItems(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetHiddenFramesCannotSkipItems sets value of ImGuiWindow.HiddenFramesCannotSkipItems
//
// Hide the window for N frames while allowing items to be submitted so we can measure their size
func (self Window) SetHiddenFramesCannotSkipItems(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHiddenFramesCannotSkipItems(selfArg, C.ImS8(v))
}

// ImGuiWindow_GetHiddenFramesCannotSkipItems returns value of ImGuiWindow.HiddenFramesCannotSkipItems
//
// Hide the window for N frames while allowing items to be submitted so we can measure their size
func (self *Window) HiddenFramesCannotSkipItems() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetHiddenFramesCannotSkipItems(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetHiddenFramesForRenderOnly sets value of ImGuiWindow.HiddenFramesForRenderOnly
//
// Hide the window until frame N at Render() time only
func (self Window) SetHiddenFramesForRenderOnly(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetHiddenFramesForRenderOnly(selfArg, C.ImS8(v))
}

// ImGuiWindow_GetHiddenFramesForRenderOnly returns value of ImGuiWindow.HiddenFramesForRenderOnly
//
// Hide the window until frame N at Render() time only
func (self *Window) HiddenFramesForRenderOnly() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetHiddenFramesForRenderOnly(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDisableInputsFrames sets value of ImGuiWindow.DisableInputsFrames
//
// Disable window interactions for N frames
func (self Window) SetDisableInputsFrames(v int) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDisableInputsFrames(selfArg, C.ImS8(v))
}

// ImGuiWindow_GetDisableInputsFrames returns value of ImGuiWindow.DisableInputsFrames
//
// Disable window interactions for N frames
func (self *Window) DisableInputsFrames() int {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int(C.wrap_ImGuiWindow_GetDisableInputsFrames(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetSetWindowPosAllowFlags sets value of ImGuiWindow.SetWindowPosAllowFlags
//
// store acceptable condition flags for SetNextWindowPos() use.
func (self Window) SetSetWindowPosAllowFlags(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowPosAllowFlags(selfArg, C.ImGuiCond(v))
}

// ImGuiWindow_GetSetWindowPosAllowFlags returns value of ImGuiWindow.SetWindowPosAllowFlags
//
// store acceptable condition flags for SetNextWindowPos() use.
func (self *Window) SetWindowPosAllowFlags() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowPosAllowFlags(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetSetWindowSizeAllowFlags sets value of ImGuiWindow.SetWindowSizeAllowFlags
//
// store acceptable condition flags for SetNextWindowSize() use.
func (self Window) SetSetWindowSizeAllowFlags(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowSizeAllowFlags(selfArg, C.ImGuiCond(v))
}

// ImGuiWindow_GetSetWindowSizeAllowFlags returns value of ImGuiWindow.SetWindowSizeAllowFlags
//
// store acceptable condition flags for SetNextWindowSize() use.
func (self *Window) SetWindowSizeAllowFlags() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowSizeAllowFlags(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetSetWindowCollapsedAllowFlags sets value of ImGuiWindow.SetWindowCollapsedAllowFlags
//
// store acceptable condition flags for SetNextWindowCollapsed() use.
func (self Window) SetSetWindowCollapsedAllowFlags(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowCollapsedAllowFlags(selfArg, C.ImGuiCond(v))
}

// ImGuiWindow_GetSetWindowCollapsedAllowFlags returns value of ImGuiWindow.SetWindowCollapsedAllowFlags
//
// store acceptable condition flags for SetNextWindowCollapsed() use.
func (self *Window) SetWindowCollapsedAllowFlags() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowCollapsedAllowFlags(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetSetWindowDockAllowFlags sets value of ImGuiWindow.SetWindowDockAllowFlags
//
// store acceptable condition flags for SetNextWindowDock() use.
func (self Window) SetSetWindowDockAllowFlags(v Cond) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowDockAllowFlags(selfArg, C.ImGuiCond(v))
}

// ImGuiWindow_GetSetWindowDockAllowFlags returns value of ImGuiWindow.SetWindowDockAllowFlags
//
// store acceptable condition flags for SetNextWindowDock() use.
func (self *Window) SetWindowDockAllowFlags() Cond {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return Cond(C.wrap_ImGuiWindow_GetSetWindowDockAllowFlags(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetSetWindowPosVal sets value of ImGuiWindow.SetWindowPosVal
//
// store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
func (self Window) SetSetWindowPosVal(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowPosVal(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetSetWindowPosVal returns value of ImGuiWindow.SetWindowPosVal
//
// store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
func (self *Window) SetWindowPosVal() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetSetWindowPosVal(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetSetWindowPosPivot sets value of ImGuiWindow.SetWindowPosPivot
//
// store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.
func (self Window) SetSetWindowPosPivot(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSetWindowPosPivot(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindow_GetSetWindowPosPivot returns value of ImGuiWindow.SetWindowPosPivot
//
// store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.
func (self *Window) SetWindowPosPivot() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindow_GetSetWindowPosPivot(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetIDStack sets value of ImGuiWindow.IDStack
//
// ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
func (self Window) SetIDStack(v vectors.Vector[ID]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiID)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiID](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetIDStack(selfArg, *vVecArg)
}

// ImGuiWindow_GetIDStack returns value of ImGuiWindow.IDStack
//
// ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
func (self *Window) IDStack() vectors.Vector[ID] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiWindow_GetIDStack(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)).Size, C.wrap_ImGuiWindow_GetIDStack(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)).Capacity, NewIDFromC(C.wrap_ImGuiWindow_GetIDStack(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)).Data))
}

// ImGuiWindow_SetDC sets value of ImGuiWindow.DC
//
// Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.
func (self Window) SetDC(v WindowTempData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDC(selfArg, internal.ReinterpretCast[C.ImGuiWindowTempData](vArg))
}

// ImGuiWindow_GetDC returns value of ImGuiWindow.DC
//
// Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.
func (self *Window) DC() WindowTempData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewWindowTempDataFromC(func() *C.ImGuiWindowTempData {
		result := C.wrap_ImGuiWindow_GetDC(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetOuterRectClipped sets value of ImGuiWindow.OuterRectClipped
//
//	// The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.
//	// The main 'OuterRect', omitted as a field, is window->Rect().
//
// == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
func (self Window) SetOuterRectClipped(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetOuterRectClipped(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetOuterRectClipped returns value of ImGuiWindow.OuterRectClipped
//
//	// The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.
//	// The main 'OuterRect', omitted as a field, is window->Rect().
//
// == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
func (self *Window) OuterRectClipped() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetOuterRectClipped(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetInnerRect sets value of ImGuiWindow.InnerRect
//
// Inner rectangle (omit title bar, menu bar, scroll bar)
func (self Window) SetInnerRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetInnerRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetInnerRect returns value of ImGuiWindow.InnerRect
//
// Inner rectangle (omit title bar, menu bar, scroll bar)
func (self *Window) InnerRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetInnerRect(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetInnerClipRect sets value of ImGuiWindow.InnerClipRect
//
// == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
func (self Window) SetInnerClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetInnerClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetInnerClipRect returns value of ImGuiWindow.InnerClipRect
//
// == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
func (self *Window) InnerClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetInnerClipRect(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetWorkRect sets value of ImGuiWindow.WorkRect
//
// Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
func (self Window) SetWorkRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetWorkRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetWorkRect returns value of ImGuiWindow.WorkRect
//
// Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
func (self *Window) WorkRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetWorkRect(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetParentWorkRect sets value of ImGuiWindow.ParentWorkRect
//
// Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?
func (self Window) SetParentWorkRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetParentWorkRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetParentWorkRect returns value of ImGuiWindow.ParentWorkRect
//
// Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?
func (self *Window) ParentWorkRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetParentWorkRect(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetClipRect sets value of ImGuiWindow.ClipRect
//
// Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
func (self Window) SetClipRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetClipRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetClipRect returns value of ImGuiWindow.ClipRect
//
// Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
func (self *Window) ClipRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetClipRect(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetContentRegionRect sets value of ImGuiWindow.ContentRegionRect
//
// FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.
func (self Window) SetContentRegionRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetContentRegionRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetContentRegionRect returns value of ImGuiWindow.ContentRegionRect
//
// FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.
func (self *Window) ContentRegionRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetContentRegionRect(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindow_SetLastFrameActive sets value of ImGuiWindow.LastFrameActive
//
// Last frame number the window was Active.
func (self Window) SetLastFrameActive(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetLastFrameActive(selfArg, C.int(v))
}

// ImGuiWindow_GetLastFrameActive returns value of ImGuiWindow.LastFrameActive
//
// Last frame number the window was Active.
func (self *Window) LastFrameActive() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetLastFrameActive(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetLastFrameJustFocused sets value of ImGuiWindow.LastFrameJustFocused
//
// Last frame number the window was made Focused.
func (self Window) SetLastFrameJustFocused(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetLastFrameJustFocused(selfArg, C.int(v))
}

// ImGuiWindow_GetLastFrameJustFocused returns value of ImGuiWindow.LastFrameJustFocused
//
// Last frame number the window was made Focused.
func (self *Window) LastFrameJustFocused() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetLastFrameJustFocused(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetLastTimeActive sets value of ImGuiWindow.LastTimeActive
//
// Last timestamp the window was Active (using float as we don't need high precision there)
func (self Window) SetLastTimeActive(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetLastTimeActive(selfArg, C.float(v))
}

// ImGuiWindow_GetLastTimeActive returns value of ImGuiWindow.LastTimeActive
//
// Last timestamp the window was Active (using float as we don't need high precision there)
func (self *Window) LastTimeActive() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetLastTimeActive(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetItemWidthDefault sets value of ImGuiWindow.ItemWidthDefault
func (self Window) SetItemWidthDefault(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetItemWidthDefault(selfArg, C.float(v))
}

// ImGuiWindow_GetItemWidthDefault returns value of ImGuiWindow.ItemWidthDefault
func (self *Window) ItemWidthDefault() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetItemWidthDefault(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetStateStorage sets value of ImGuiWindow.StateStorage
func (self Window) SetStateStorage(v Storage) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetStateStorage(selfArg, internal.ReinterpretCast[C.ImGuiStorage](vArg))
}

// ImGuiWindow_GetStateStorage returns value of ImGuiWindow.StateStorage
func (self *Window) StateStorage() Storage {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewStorageFromC(func() *C.ImGuiStorage {
		result := C.wrap_ImGuiWindow_GetStateStorage(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetColumnsStorage sets value of ImGuiWindow.ColumnsStorage
func (self Window) SetColumnsStorage(v vectors.Vector[OldColumns]) {
	vData := v.Data
	vDataArg, _ := vData.Handle()
	vVecArg := new(C.ImVector_ImGuiOldColumns)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = internal.ReinterpretCast[*C.ImGuiOldColumns](vDataArg)
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetColumnsStorage(selfArg, *vVecArg)
}

// ImGuiWindow_GetColumnsStorage returns value of ImGuiWindow.ColumnsStorage
func (self *Window) ColumnsStorage() vectors.Vector[OldColumns] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiWindow_GetColumnsStorage(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)).Size, C.wrap_ImGuiWindow_GetColumnsStorage(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)).Capacity, NewOldColumnsFromC(C.wrap_ImGuiWindow_GetColumnsStorage(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)).Data))
}

// ImGuiWindow_SetFontWindowScale sets value of ImGuiWindow.FontWindowScale
//
// User scale multiplier per-window, via SetWindowFontScale()
func (self Window) SetFontWindowScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFontWindowScale(selfArg, C.float(v))
}

// ImGuiWindow_GetFontWindowScale returns value of ImGuiWindow.FontWindowScale
//
// User scale multiplier per-window, via SetWindowFontScale()
func (self *Window) FontWindowScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetFontWindowScale(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetFontDpiScale sets value of ImGuiWindow.FontDpiScale
func (self Window) SetFontDpiScale(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetFontDpiScale(selfArg, C.float(v))
}

// ImGuiWindow_GetFontDpiScale returns value of ImGuiWindow.FontDpiScale
func (self *Window) FontDpiScale() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindow_GetFontDpiScale(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetSettingsOffset sets value of ImGuiWindow.SettingsOffset
//
// Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)
func (self Window) SetSettingsOffset(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetSettingsOffset(selfArg, C.int(v))
}

// ImGuiWindow_GetSettingsOffset returns value of ImGuiWindow.SettingsOffset
//
// Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)
func (self *Window) SettingsOffset() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetSettingsOffset(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDrawList sets value of ImGuiWindow.DrawList
//
// == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
func (self Window) SetDrawList(v *DrawList) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDrawList(selfArg, internal.ReinterpretCast[*C.ImDrawList](vArg))
}

// ImGuiWindow_GetDrawList returns value of ImGuiWindow.DrawList
//
// == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
func (self *Window) DrawList() *DrawList {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDrawListFromC(C.wrap_ImGuiWindow_GetDrawList(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDrawListInst sets value of ImGuiWindow.DrawListInst
func (self Window) SetDrawListInst(v DrawList) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDrawListInst(selfArg, internal.ReinterpretCast[C.ImDrawList](vArg))
}

// ImGuiWindow_GetDrawListInst returns value of ImGuiWindow.DrawListInst
func (self *Window) DrawListInst() DrawList {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewDrawListFromC(func() *C.ImDrawList {
		result := C.wrap_ImGuiWindow_GetDrawListInst(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetParentWindow sets value of ImGuiWindow.ParentWindow
//
// If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.
func (self Window) SetParentWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetParentWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetParentWindow returns value of ImGuiWindow.ParentWindow
//
// If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.
func (self *Window) ParentWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetParentWindow(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetParentWindowInBeginStack sets value of ImGuiWindow.ParentWindowInBeginStack
func (self Window) SetParentWindowInBeginStack(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetParentWindowInBeginStack(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetParentWindowInBeginStack returns value of ImGuiWindow.ParentWindowInBeginStack
func (self *Window) ParentWindowInBeginStack() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetParentWindowInBeginStack(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetRootWindow sets value of ImGuiWindow.RootWindow
//
// Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.
func (self Window) SetRootWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetRootWindow returns value of ImGuiWindow.RootWindow
//
// Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.
func (self *Window) RootWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetRootWindow(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetRootWindowPopupTree sets value of ImGuiWindow.RootWindowPopupTree
//
// Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.
func (self Window) SetRootWindowPopupTree(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowPopupTree(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetRootWindowPopupTree returns value of ImGuiWindow.RootWindowPopupTree
//
// Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.
func (self *Window) RootWindowPopupTree() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetRootWindowPopupTree(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetRootWindowDockTree sets value of ImGuiWindow.RootWindowDockTree
//
// Point to ourself or first ancestor that is not a child window. Cross through dock nodes.
func (self Window) SetRootWindowDockTree(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowDockTree(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetRootWindowDockTree returns value of ImGuiWindow.RootWindowDockTree
//
// Point to ourself or first ancestor that is not a child window. Cross through dock nodes.
func (self *Window) RootWindowDockTree() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetRootWindowDockTree(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetRootWindowForTitleBarHighlight sets value of ImGuiWindow.RootWindowForTitleBarHighlight
//
// Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
func (self Window) SetRootWindowForTitleBarHighlight(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowForTitleBarHighlight(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetRootWindowForTitleBarHighlight returns value of ImGuiWindow.RootWindowForTitleBarHighlight
//
// Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
func (self *Window) RootWindowForTitleBarHighlight() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetRootWindowForTitleBarHighlight(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetRootWindowForNav sets value of ImGuiWindow.RootWindowForNav
//
// Point to ourself or first ancestor which doesn't have the NavFlattened flag.
func (self Window) SetRootWindowForNav(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetRootWindowForNav(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetRootWindowForNav returns value of ImGuiWindow.RootWindowForNav
//
// Point to ourself or first ancestor which doesn't have the NavFlattened flag.
func (self *Window) RootWindowForNav() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetRootWindowForNav(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetParentWindowForFocusRoute sets value of ImGuiWindow.ParentWindowForFocusRoute
//
// Set to manual link a window to its logical parent so that Shortcut() chain are honoerd (e.g. Tool linked to Document)
func (self Window) SetParentWindowForFocusRoute(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetParentWindowForFocusRoute(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetParentWindowForFocusRoute returns value of ImGuiWindow.ParentWindowForFocusRoute
//
// Set to manual link a window to its logical parent so that Shortcut() chain are honoerd (e.g. Tool linked to Document)
func (self *Window) ParentWindowForFocusRoute() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetParentWindowForFocusRoute(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetNavLastChildNavWindow sets value of ImGuiWindow.NavLastChildNavWindow
//
// When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
func (self Window) SetNavLastChildNavWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavLastChildNavWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindow_GetNavLastChildNavWindow returns value of ImGuiWindow.NavLastChildNavWindow
//
// When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
func (self *Window) NavLastChildNavWindow() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindow_GetNavLastChildNavWindow(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetNavLastIds sets value of ImGuiWindow.NavLastIds[ImGuiNavLayer_COUNT]
//
// Last known NavId for this window, per layer (0/1)
func (self Window) SetNavLastIds(v *[2]ID) {
	vArg := make([]C.ImGuiID, len(v))
	for i, vV := range v {
		vVArg, _ := vV.C()
		vArg[i] = internal.ReinterpretCast[C.ImGuiID](vVArg)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavLastIds(selfArg, (*C.ImGuiID)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = *NewIDFromC(func() *C.ImGuiID { result := vV; return &result }())
	}
}

// ImGuiWindow_GetNavLastIds returns value of ImGuiWindow.NavLastIds[ImGuiNavLayer_COUNT]
//
// Last known NavId for this window, per layer (0/1)
func (self *Window) NavLastIds() [2]ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [2]ID {
		result := [2]ID{}
		resultMirr := C.wrap_ImGuiWindow_GetNavLastIds(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		for i := range result {
			result[i] = *NewIDFromC(func() *C.ImGuiID { result := C.cimgui_ImGuiID_GetAtIdx(resultMirr, C.int(i)); return &result }())
		}

		return result
	}()
}

// ImGuiWindow_SetNavRectRel sets value of ImGuiWindow.NavRectRel[ImGuiNavLayer_COUNT]
//
// Reference rectangle, in window relative space
func (self Window) SetNavRectRel(v *[2]Rect) {
	vArg := make([]C.ImRect, len(v))
	for i, vV := range v {
		vArg[i] = internal.ReinterpretCast[C.ImRect](vV.ToC())
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavRectRel(selfArg, (*C.ImRect)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = func() Rect { out := vV; return *(&Rect{}).FromC(unsafe.Pointer(&out)) }()
	}
}

// ImGuiWindow_GetNavRectRel returns value of ImGuiWindow.NavRectRel[ImGuiNavLayer_COUNT]
//
// Reference rectangle, in window relative space
func (self *Window) NavRectRel() [2]Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [2]Rect {
		result := [2]Rect{}
		resultMirr := C.wrap_ImGuiWindow_GetNavRectRel(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		for i := range result {
			result[i] = func() Rect {
				out := C.cimgui_ImRect_GetAtIdx(resultMirr, C.int(i))
				return *(&Rect{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}

// ImGuiWindow_SetNavPreferredScoringPosRel sets value of ImGuiWindow.NavPreferredScoringPosRel[ImGuiNavLayer_COUNT]
//
// Preferred X/Y position updated when moving on a given axis, reset to FLT_MAX.
func (self Window) SetNavPreferredScoringPosRel(v [2]*Vec2) {
	vArg := make([]C.ImVec2, len(v))
	vFin := make([]func(), len(v))
	for i, vV := range v {
		var tmp *C.ImVec2
		tmp, vFin[i] = internal.Wrap(vV)
		vArg[i] = *tmp
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavPreferredScoringPosRel(selfArg, (*C.ImVec2)(&vArg[0]))
}

// ImGuiWindow_GetNavPreferredScoringPosRel returns value of ImGuiWindow.NavPreferredScoringPosRel[ImGuiNavLayer_COUNT]
//
// Preferred X/Y position updated when moving on a given axis, reset to FLT_MAX.
func (self *Window) NavPreferredScoringPosRel() [2]Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [2]Vec2 {
		result := [2]Vec2{}
		resultMirr := C.wrap_ImGuiWindow_GetNavPreferredScoringPosRel(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		for i := range result {
			result[i] = func() Vec2 {
				out := C.cimgui_ImVec2_GetAtIdx(resultMirr, C.int(i))
				return *(&Vec2{}).FromC(unsafe.Pointer(&out))
			}()
		}

		return result
	}()
}

// ImGuiWindow_SetNavRootFocusScopeId sets value of ImGuiWindow.NavRootFocusScopeId
//
// Focus Scope ID at the time of Begin()
func (self Window) SetNavRootFocusScopeId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetNavRootFocusScopeId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetNavRootFocusScopeId returns value of ImGuiWindow.NavRootFocusScopeId
//
// Focus Scope ID at the time of Begin()
func (self *Window) NavRootFocusScopeId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetNavRootFocusScopeId(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetMemoryDrawListIdxCapacity sets value of ImGuiWindow.MemoryDrawListIdxCapacity
//
// Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy
func (self Window) SetMemoryDrawListIdxCapacity(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMemoryDrawListIdxCapacity(selfArg, C.int(v))
}

// ImGuiWindow_GetMemoryDrawListIdxCapacity returns value of ImGuiWindow.MemoryDrawListIdxCapacity
//
// Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy
func (self *Window) MemoryDrawListIdxCapacity() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetMemoryDrawListIdxCapacity(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetMemoryDrawListVtxCapacity sets value of ImGuiWindow.MemoryDrawListVtxCapacity
func (self Window) SetMemoryDrawListVtxCapacity(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMemoryDrawListVtxCapacity(selfArg, C.int(v))
}

// ImGuiWindow_GetMemoryDrawListVtxCapacity returns value of ImGuiWindow.MemoryDrawListVtxCapacity
func (self *Window) MemoryDrawListVtxCapacity() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindow_GetMemoryDrawListVtxCapacity(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetMemoryCompacted sets value of ImGuiWindow.MemoryCompacted
//
// Set when window extraneous data have been garbage collected
func (self Window) SetMemoryCompacted(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetMemoryCompacted(selfArg, C.bool(v))
}

// ImGuiWindow_GetMemoryCompacted returns value of ImGuiWindow.MemoryCompacted
//
// Set when window extraneous data have been garbage collected
func (self *Window) MemoryCompacted() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetMemoryCompacted(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetDockIsActive sets value of ImGuiWindow.DockIsActive
//
//	// Docking
//
// When docking artifacts are actually visible. When this is set, DockNode is guaranteed to be != NULL. ~~ (DockNode != NULL) && (DockNode->Windows.Size > 1).
func (self Window) SetDockIsActive(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockIsActive(selfArg, C.bool(v))
}

// ImGuiWindow_GetDockIsActive returns value of ImGuiWindow.DockIsActive
//
//	// Docking
//
// When docking artifacts are actually visible. When this is set, DockNode is guaranteed to be != NULL. ~~ (DockNode != NULL) && (DockNode->Windows.Size > 1).
func (self *Window) DockIsActive() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockIsActive(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetDockNodeIsVisible sets value of ImGuiWindow.DockNodeIsVisible
func (self Window) SetDockNodeIsVisible(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockNodeIsVisible(selfArg, C.bool(v))
}

// ImGuiWindow_GetDockNodeIsVisible returns value of ImGuiWindow.DockNodeIsVisible
func (self *Window) DockNodeIsVisible() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockNodeIsVisible(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetDockTabIsVisible sets value of ImGuiWindow.DockTabIsVisible
//
// Is our window visible this frame? ~~ is the corresponding tab selected?
func (self Window) SetDockTabIsVisible(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabIsVisible(selfArg, C.bool(v))
}

// ImGuiWindow_GetDockTabIsVisible returns value of ImGuiWindow.DockTabIsVisible
//
// Is our window visible this frame? ~~ is the corresponding tab selected?
func (self *Window) DockTabIsVisible() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockTabIsVisible(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetDockTabWantClose sets value of ImGuiWindow.DockTabWantClose
func (self Window) SetDockTabWantClose(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabWantClose(selfArg, C.bool(v))
}

// ImGuiWindow_GetDockTabWantClose returns value of ImGuiWindow.DockTabWantClose
func (self *Window) DockTabWantClose() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindow_GetDockTabWantClose(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)) == C.bool(true)
}

// ImGuiWindow_SetDockOrder sets value of ImGuiWindow.DockOrder
//
// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
func (self Window) SetDockOrder(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockOrder(selfArg, C.short(v))
}

// ImGuiWindow_GetDockOrder returns value of ImGuiWindow.DockOrder
//
// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
func (self *Window) DockOrder() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindow_GetDockOrder(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDockStyle sets value of ImGuiWindow.DockStyle
func (self Window) SetDockStyle(v WindowDockStyle) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockStyle(selfArg, internal.ReinterpretCast[C.ImGuiWindowDockStyle](vArg))
}

// ImGuiWindow_GetDockStyle returns value of ImGuiWindow.DockStyle
func (self *Window) DockStyle() WindowDockStyle {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewWindowDockStyleFromC(func() *C.ImGuiWindowDockStyle {
		result := C.wrap_ImGuiWindow_GetDockStyle(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetDockNode sets value of ImGuiWindow.DockNode
//
// Which node are we docked into. Important: Prefer testing DockIsActive in many cases as this will still be set when the dock node is hidden.
func (self Window) SetDockNode(v *DockNode) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockNode(selfArg, internal.ReinterpretCast[*C.ImGuiDockNode](vArg))
}

// ImGuiWindow_GetDockNode returns value of ImGuiWindow.DockNode
//
// Which node are we docked into. Important: Prefer testing DockIsActive in many cases as this will still be set when the dock node is hidden.
func (self *Window) DockNode() *DockNode {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDockNodeFromC(C.wrap_ImGuiWindow_GetDockNode(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDockNodeAsHost sets value of ImGuiWindow.DockNodeAsHost
//
// Which node are we owning (for parent windows)
func (self Window) SetDockNodeAsHost(v *DockNode) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockNodeAsHost(selfArg, internal.ReinterpretCast[*C.ImGuiDockNode](vArg))
}

// ImGuiWindow_GetDockNodeAsHost returns value of ImGuiWindow.DockNodeAsHost
//
// Which node are we owning (for parent windows)
func (self *Window) DockNodeAsHost() *DockNode {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewDockNodeFromC(C.wrap_ImGuiWindow_GetDockNodeAsHost(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDockId sets value of ImGuiWindow.DockId
//
// Backup of last valid DockNode->ID, so single window remember their dock node id even when they are not bound any more
func (self Window) SetDockId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindow_GetDockId returns value of ImGuiWindow.DockId
//
// Backup of last valid DockNode->ID, so single window remember their dock node id even when they are not bound any more
func (self *Window) DockId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindow_GetDockId(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return &result
	}())
}

// ImGuiWindow_SetDockTabItemStatusFlags sets value of ImGuiWindow.DockTabItemStatusFlags
func (self Window) SetDockTabItemStatusFlags(v ItemStatusFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabItemStatusFlags(selfArg, C.ImGuiItemStatusFlags(v))
}

// ImGuiWindow_GetDockTabItemStatusFlags returns value of ImGuiWindow.DockTabItemStatusFlags
func (self *Window) DockTabItemStatusFlags() ItemStatusFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ItemStatusFlags(C.wrap_ImGuiWindow_GetDockTabItemStatusFlags(internal.ReinterpretCast[*C.ImGuiWindow](selfArg)))
}

// ImGuiWindow_SetDockTabItemRect sets value of ImGuiWindow.DockTabItemRect
func (self Window) SetDockTabItemRect(v Rect) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindow_SetDockTabItemRect(selfArg, internal.ReinterpretCast[C.ImRect](v.ToC()))
}

// ImGuiWindow_GetDockTabItemRect returns value of ImGuiWindow.DockTabItemRect
func (self *Window) DockTabItemRect() Rect {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Rect {
		out := C.wrap_ImGuiWindow_GetDockTabItemRect(internal.ReinterpretCast[*C.ImGuiWindow](selfArg))
		return *(&Rect{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowClass_SetClassId sets value of ImGuiWindowClass.ClassId
//
// User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.
func (self WindowClass) SetClassId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetClassId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindowClass_GetClassId returns value of ImGuiWindowClass.ClassId
//
// User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.
func (self *WindowClass) ClassId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindowClass_GetClassId(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg))
		return &result
	}())
}

// ImGuiWindowClass_SetParentViewportId sets value of ImGuiWindowClass.ParentViewportId
//
// Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent<>child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.
func (self WindowClass) SetParentViewportId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetParentViewportId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindowClass_GetParentViewportId returns value of ImGuiWindowClass.ParentViewportId
//
// Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent<>child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.
func (self *WindowClass) ParentViewportId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindowClass_GetParentViewportId(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg))
		return &result
	}())
}

// ImGuiWindowClass_SetFocusRouteParentWindowId sets value of ImGuiWindowClass.FocusRouteParentWindowId
//
// ID of parent window for shortcut focus route evaluation, e.g. Shortcut() call from Parent Window will succeed when this window is focused.
func (self WindowClass) SetFocusRouteParentWindowId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetFocusRouteParentWindowId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindowClass_GetFocusRouteParentWindowId returns value of ImGuiWindowClass.FocusRouteParentWindowId
//
// ID of parent window for shortcut focus route evaluation, e.g. Shortcut() call from Parent Window will succeed when this window is focused.
func (self *WindowClass) FocusRouteParentWindowId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindowClass_GetFocusRouteParentWindowId(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg))
		return &result
	}())
}

// ImGuiWindowClass_SetViewportFlagsOverrideSet sets value of ImGuiWindowClass.ViewportFlagsOverrideSet
//
// Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
func (self WindowClass) SetViewportFlagsOverrideSet(v ViewportFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetViewportFlagsOverrideSet(selfArg, C.ImGuiViewportFlags(v))
}

// ImGuiWindowClass_GetViewportFlagsOverrideSet returns value of ImGuiWindowClass.ViewportFlagsOverrideSet
//
// Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
func (self *WindowClass) ViewportFlagsOverrideSet() ViewportFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ViewportFlags(C.wrap_ImGuiWindowClass_GetViewportFlagsOverrideSet(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg)))
}

// ImGuiWindowClass_SetViewportFlagsOverrideClear sets value of ImGuiWindowClass.ViewportFlagsOverrideClear
//
// Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
func (self WindowClass) SetViewportFlagsOverrideClear(v ViewportFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetViewportFlagsOverrideClear(selfArg, C.ImGuiViewportFlags(v))
}

// ImGuiWindowClass_GetViewportFlagsOverrideClear returns value of ImGuiWindowClass.ViewportFlagsOverrideClear
//
// Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
func (self *WindowClass) ViewportFlagsOverrideClear() ViewportFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return ViewportFlags(C.wrap_ImGuiWindowClass_GetViewportFlagsOverrideClear(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg)))
}

// ImGuiWindowClass_SetTabItemFlagsOverrideSet sets value of ImGuiWindowClass.TabItemFlagsOverrideSet
//
// [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.
func (self WindowClass) SetTabItemFlagsOverrideSet(v TabItemFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetTabItemFlagsOverrideSet(selfArg, C.ImGuiTabItemFlags(v))
}

// ImGuiWindowClass_GetTabItemFlagsOverrideSet returns value of ImGuiWindowClass.TabItemFlagsOverrideSet
//
// [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.
func (self *WindowClass) TabItemFlagsOverrideSet() TabItemFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return TabItemFlags(C.wrap_ImGuiWindowClass_GetTabItemFlagsOverrideSet(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg)))
}

// ImGuiWindowClass_SetDockNodeFlagsOverrideSet sets value of ImGuiWindowClass.DockNodeFlagsOverrideSet
//
// [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)
func (self WindowClass) SetDockNodeFlagsOverrideSet(v DockNodeFlags) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetDockNodeFlagsOverrideSet(selfArg, C.ImGuiDockNodeFlags(v))
}

// ImGuiWindowClass_GetDockNodeFlagsOverrideSet returns value of ImGuiWindowClass.DockNodeFlagsOverrideSet
//
// [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)
func (self *WindowClass) DockNodeFlagsOverrideSet() DockNodeFlags {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return DockNodeFlags(C.wrap_ImGuiWindowClass_GetDockNodeFlagsOverrideSet(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg)))
}

// ImGuiWindowClass_SetDockingAlwaysTabBar sets value of ImGuiWindowClass.DockingAlwaysTabBar
//
// Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)
func (self WindowClass) SetDockingAlwaysTabBar(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetDockingAlwaysTabBar(selfArg, C.bool(v))
}

// ImGuiWindowClass_GetDockingAlwaysTabBar returns value of ImGuiWindowClass.DockingAlwaysTabBar
//
// Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)
func (self *WindowClass) DockingAlwaysTabBar() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowClass_GetDockingAlwaysTabBar(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg)) == C.bool(true)
}

// ImGuiWindowClass_SetDockingAllowUnclassed sets value of ImGuiWindowClass.DockingAllowUnclassed
//
// Set to true to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?
func (self WindowClass) SetDockingAllowUnclassed(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowClass_SetDockingAllowUnclassed(selfArg, C.bool(v))
}

// ImGuiWindowClass_GetDockingAllowUnclassed returns value of ImGuiWindowClass.DockingAllowUnclassed
//
// Set to true to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?
func (self *WindowClass) DockingAllowUnclassed() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowClass_GetDockingAllowUnclassed(internal.ReinterpretCast[*C.ImGuiWindowClass](selfArg)) == C.bool(true)
}

// ImGuiWindowDockStyle_SetColors sets value of ImGuiWindowDockStyle.Colors[ImGuiWindowDockStyleCol_COUNT]
func (self WindowDockStyle) SetColors(v *[8]uint32) {
	vArg := make([]C.ImU32, len(v))
	for i, vV := range v {
		vArg[i] = C.ImU32(vV)
	}

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowDockStyle_SetColors(selfArg, (*C.ImU32)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = uint32(vV)
	}
}

// ImGuiWindowDockStyle_GetColors returns value of ImGuiWindowDockStyle.Colors[ImGuiWindowDockStyleCol_COUNT]
func (self *WindowDockStyle) Colors() [8]uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() [8]uint32 {
		result := [8]uint32{}
		resultMirr := C.wrap_ImGuiWindowDockStyle_GetColors(internal.ReinterpretCast[*C.ImGuiWindowDockStyle](selfArg))
		for i := range result {
			result[i] = uint32(C.cimgui_ImU32_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}

// ImGuiWindowSettings_SetID sets value of ImGuiWindowSettings.ID
func (self WindowSettings) SetID(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetID(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindowSettings_GetID returns value of ImGuiWindowSettings.ID
func (self *WindowSettings) ID() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindowSettings_GetID(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg))
		return &result
	}())
}

// ImGuiWindowSettings_SetViewportId sets value of ImGuiWindowSettings.ViewportId
func (self WindowSettings) SetViewportId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetViewportId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindowSettings_GetViewportId returns value of ImGuiWindowSettings.ViewportId
func (self *WindowSettings) ViewportId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindowSettings_GetViewportId(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg))
		return &result
	}())
}

// ImGuiWindowSettings_SetDockId sets value of ImGuiWindowSettings.DockId
//
// ID of last known DockNode (even if the DockNode is invisible because it has only 1 active window), or 0 if none.
func (self WindowSettings) SetDockId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetDockId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindowSettings_GetDockId returns value of ImGuiWindowSettings.DockId
//
// ID of last known DockNode (even if the DockNode is invisible because it has only 1 active window), or 0 if none.
func (self *WindowSettings) DockId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindowSettings_GetDockId(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg))
		return &result
	}())
}

// ImGuiWindowSettings_SetClassId sets value of ImGuiWindowSettings.ClassId
//
// ID of window class if specified
func (self WindowSettings) SetClassId(v ID) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetClassId(selfArg, internal.ReinterpretCast[C.ImGuiID](vArg))
}

// ImGuiWindowSettings_GetClassId returns value of ImGuiWindowSettings.ClassId
//
// ID of window class if specified
func (self *WindowSettings) ClassId() ID {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewIDFromC(func() *C.ImGuiID {
		result := C.wrap_ImGuiWindowSettings_GetClassId(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg))
		return &result
	}())
}

// ImGuiWindowSettings_SetDockOrder sets value of ImGuiWindowSettings.DockOrder
//
// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
func (self WindowSettings) SetDockOrder(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetDockOrder(selfArg, C.short(v))
}

// ImGuiWindowSettings_GetDockOrder returns value of ImGuiWindowSettings.DockOrder
//
// Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
func (self *WindowSettings) DockOrder() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindowSettings_GetDockOrder(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg)))
}

// ImGuiWindowSettings_SetCollapsed sets value of ImGuiWindowSettings.Collapsed
func (self WindowSettings) SetCollapsed(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetCollapsed(selfArg, C.bool(v))
}

// ImGuiWindowSettings_GetCollapsed returns value of ImGuiWindowSettings.Collapsed
func (self *WindowSettings) Collapsed() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowSettings_GetCollapsed(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg)) == C.bool(true)
}

// ImGuiWindowSettings_SetIsChild sets value of ImGuiWindowSettings.IsChild
func (self WindowSettings) SetIsChild(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetIsChild(selfArg, C.bool(v))
}

// ImGuiWindowSettings_GetIsChild returns value of ImGuiWindowSettings.IsChild
func (self *WindowSettings) IsChild() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowSettings_GetIsChild(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg)) == C.bool(true)
}

// ImGuiWindowSettings_SetWantApply sets value of ImGuiWindowSettings.WantApply
//
// Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
func (self WindowSettings) SetWantApply(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetWantApply(selfArg, C.bool(v))
}

// ImGuiWindowSettings_GetWantApply returns value of ImGuiWindowSettings.WantApply
//
// Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
func (self *WindowSettings) WantApply() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowSettings_GetWantApply(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg)) == C.bool(true)
}

// ImGuiWindowSettings_SetWantDelete sets value of ImGuiWindowSettings.WantDelete
//
// Set to invalidate/delete the settings entry
func (self WindowSettings) SetWantDelete(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowSettings_SetWantDelete(selfArg, C.bool(v))
}

// ImGuiWindowSettings_GetWantDelete returns value of ImGuiWindowSettings.WantDelete
//
// Set to invalidate/delete the settings entry
func (self *WindowSettings) WantDelete() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowSettings_GetWantDelete(internal.ReinterpretCast[*C.ImGuiWindowSettings](selfArg)) == C.bool(true)
}

// ImGuiWindowStackData_SetWindow sets value of ImGuiWindowStackData.Window
func (self WindowStackData) SetWindow(v *Window) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowStackData_SetWindow(selfArg, internal.ReinterpretCast[*C.ImGuiWindow](vArg))
}

// ImGuiWindowStackData_GetWindow returns value of ImGuiWindowStackData.Window
func (self *WindowStackData) Window() *Window {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewWindowFromC(C.wrap_ImGuiWindowStackData_GetWindow(internal.ReinterpretCast[*C.ImGuiWindowStackData](selfArg)))
}

// ImGuiWindowStackData_SetParentLastItemDataBackup sets value of ImGuiWindowStackData.ParentLastItemDataBackup
func (self WindowStackData) SetParentLastItemDataBackup(v LastItemData) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowStackData_SetParentLastItemDataBackup(selfArg, internal.ReinterpretCast[C.ImGuiLastItemData](vArg))
}

// ImGuiWindowStackData_GetParentLastItemDataBackup returns value of ImGuiWindowStackData.ParentLastItemDataBackup
func (self *WindowStackData) ParentLastItemDataBackup() LastItemData {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewLastItemDataFromC(func() *C.ImGuiLastItemData {
		result := C.wrap_ImGuiWindowStackData_GetParentLastItemDataBackup(internal.ReinterpretCast[*C.ImGuiWindowStackData](selfArg))
		return &result
	}())
}

// ImGuiWindowStackData_SetStackSizesInBegin sets value of ImGuiWindowStackData.StackSizesInBegin
//
// Store size of various stacks for asserting
func (self WindowStackData) SetStackSizesInBegin(v ErrorRecoveryState) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowStackData_SetStackSizesInBegin(selfArg, internal.ReinterpretCast[C.ImGuiErrorRecoveryState](vArg))
}

// ImGuiWindowStackData_GetStackSizesInBegin returns value of ImGuiWindowStackData.StackSizesInBegin
//
// Store size of various stacks for asserting
func (self *WindowStackData) StackSizesInBegin() ErrorRecoveryState {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewErrorRecoveryStateFromC(func() *C.ImGuiErrorRecoveryState {
		result := C.wrap_ImGuiWindowStackData_GetStackSizesInBegin(internal.ReinterpretCast[*C.ImGuiWindowStackData](selfArg))
		return &result
	}())
}

// ImGuiWindowStackData_SetDisabledOverrideReenable sets value of ImGuiWindowStackData.DisabledOverrideReenable
//
// Non-child window override disabled flag
func (self WindowStackData) SetDisabledOverrideReenable(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowStackData_SetDisabledOverrideReenable(selfArg, C.bool(v))
}

// ImGuiWindowStackData_GetDisabledOverrideReenable returns value of ImGuiWindowStackData.DisabledOverrideReenable
//
// Non-child window override disabled flag
func (self *WindowStackData) DisabledOverrideReenable() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowStackData_GetDisabledOverrideReenable(internal.ReinterpretCast[*C.ImGuiWindowStackData](selfArg)) == C.bool(true)
}

// ImGuiWindowTempData_SetCursorPos sets value of ImGuiWindowTempData.CursorPos
//
//	// Layout
//
// Current emitting position, in absolute coordinates.
func (self WindowTempData) SetCursorPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetCursorPos returns value of ImGuiWindowTempData.CursorPos
//
//	// Layout
//
// Current emitting position, in absolute coordinates.
func (self *WindowTempData) CursorPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetCursorPos(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetCursorPosPrevLine sets value of ImGuiWindowTempData.CursorPosPrevLine
func (self WindowTempData) SetCursorPosPrevLine(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorPosPrevLine(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetCursorPosPrevLine returns value of ImGuiWindowTempData.CursorPosPrevLine
func (self *WindowTempData) CursorPosPrevLine() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetCursorPosPrevLine(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetCursorStartPos sets value of ImGuiWindowTempData.CursorStartPos
//
// Initial position after Begin(), generally ~ window position + WindowPadding.
func (self WindowTempData) SetCursorStartPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorStartPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetCursorStartPos returns value of ImGuiWindowTempData.CursorStartPos
//
// Initial position after Begin(), generally ~ window position + WindowPadding.
func (self *WindowTempData) CursorStartPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetCursorStartPos(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetCursorMaxPos sets value of ImGuiWindowTempData.CursorMaxPos
//
// Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.
func (self WindowTempData) SetCursorMaxPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorMaxPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetCursorMaxPos returns value of ImGuiWindowTempData.CursorMaxPos
//
// Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.
func (self *WindowTempData) CursorMaxPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetCursorMaxPos(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetIdealMaxPos sets value of ImGuiWindowTempData.IdealMaxPos
//
// Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.
func (self WindowTempData) SetIdealMaxPos(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIdealMaxPos(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetIdealMaxPos returns value of ImGuiWindowTempData.IdealMaxPos
//
// Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.
func (self *WindowTempData) IdealMaxPos() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetIdealMaxPos(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetCurrLineSize sets value of ImGuiWindowTempData.CurrLineSize
func (self WindowTempData) SetCurrLineSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrLineSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetCurrLineSize returns value of ImGuiWindowTempData.CurrLineSize
func (self *WindowTempData) CurrLineSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetCurrLineSize(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetPrevLineSize sets value of ImGuiWindowTempData.PrevLineSize
func (self WindowTempData) SetPrevLineSize(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetPrevLineSize(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetPrevLineSize returns value of ImGuiWindowTempData.PrevLineSize
func (self *WindowTempData) PrevLineSize() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetPrevLineSize(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetCurrLineTextBaseOffset sets value of ImGuiWindowTempData.CurrLineTextBaseOffset
//
// Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
func (self WindowTempData) SetCurrLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrLineTextBaseOffset(selfArg, C.float(v))
}

// ImGuiWindowTempData_GetCurrLineTextBaseOffset returns value of ImGuiWindowTempData.CurrLineTextBaseOffset
//
// Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
func (self *WindowTempData) CurrLineTextBaseOffset() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetCurrLineTextBaseOffset(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetPrevLineTextBaseOffset sets value of ImGuiWindowTempData.PrevLineTextBaseOffset
func (self WindowTempData) SetPrevLineTextBaseOffset(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetPrevLineTextBaseOffset(selfArg, C.float(v))
}

// ImGuiWindowTempData_GetPrevLineTextBaseOffset returns value of ImGuiWindowTempData.PrevLineTextBaseOffset
func (self *WindowTempData) PrevLineTextBaseOffset() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetPrevLineTextBaseOffset(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetIsSameLine sets value of ImGuiWindowTempData.IsSameLine
func (self WindowTempData) SetIsSameLine(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIsSameLine(selfArg, C.bool(v))
}

// ImGuiWindowTempData_GetIsSameLine returns value of ImGuiWindowTempData.IsSameLine
func (self *WindowTempData) IsSameLine() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetIsSameLine(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)) == C.bool(true)
}

// ImGuiWindowTempData_SetIsSetPos sets value of ImGuiWindowTempData.IsSetPos
func (self WindowTempData) SetIsSetPos(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIsSetPos(selfArg, C.bool(v))
}

// ImGuiWindowTempData_GetIsSetPos returns value of ImGuiWindowTempData.IsSetPos
func (self *WindowTempData) IsSetPos() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetIsSetPos(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)) == C.bool(true)
}

// ImGuiWindowTempData_SetIndent sets value of ImGuiWindowTempData.Indent
//
// Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
func (self WindowTempData) SetIndent(v Vec1) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetIndent(selfArg, internal.ReinterpretCast[C.ImVec1](vArg))
}

// ImGuiWindowTempData_GetIndent returns value of ImGuiWindowTempData.Indent
//
// Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
func (self *WindowTempData) Indent() Vec1 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewVec1FromC(func() *C.ImVec1 {
		result := C.wrap_ImGuiWindowTempData_GetIndent(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return &result
	}())
}

// ImGuiWindowTempData_SetColumnsOffset sets value of ImGuiWindowTempData.ColumnsOffset
//
// Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
func (self WindowTempData) SetColumnsOffset(v Vec1) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetColumnsOffset(selfArg, internal.ReinterpretCast[C.ImVec1](vArg))
}

// ImGuiWindowTempData_GetColumnsOffset returns value of ImGuiWindowTempData.ColumnsOffset
//
// Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
func (self *WindowTempData) ColumnsOffset() Vec1 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewVec1FromC(func() *C.ImVec1 {
		result := C.wrap_ImGuiWindowTempData_GetColumnsOffset(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return &result
	}())
}

// ImGuiWindowTempData_SetGroupOffset sets value of ImGuiWindowTempData.GroupOffset
func (self WindowTempData) SetGroupOffset(v Vec1) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetGroupOffset(selfArg, internal.ReinterpretCast[C.ImVec1](vArg))
}

// ImGuiWindowTempData_GetGroupOffset returns value of ImGuiWindowTempData.GroupOffset
func (self *WindowTempData) GroupOffset() Vec1 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewVec1FromC(func() *C.ImVec1 {
		result := C.wrap_ImGuiWindowTempData_GetGroupOffset(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return &result
	}())
}

// ImGuiWindowTempData_SetCursorStartPosLossyness sets value of ImGuiWindowTempData.CursorStartPosLossyness
//
// Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.
func (self WindowTempData) SetCursorStartPosLossyness(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCursorStartPosLossyness(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetCursorStartPosLossyness returns value of ImGuiWindowTempData.CursorStartPosLossyness
//
// Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.
func (self *WindowTempData) CursorStartPosLossyness() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetCursorStartPosLossyness(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetNavLayerCurrent sets value of ImGuiWindowTempData.NavLayerCurrent
//
//	// Keyboard/Gamepad navigation
//
// Current layer, 0..31 (we currently only use 0..1)
func (self WindowTempData) SetNavLayerCurrent(v NavLayer) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavLayerCurrent(selfArg, C.ImGuiNavLayer(v))
}

// ImGuiWindowTempData_GetNavLayerCurrent returns value of ImGuiWindowTempData.NavLayerCurrent
//
//	// Keyboard/Gamepad navigation
//
// Current layer, 0..31 (we currently only use 0..1)
func (self *WindowTempData) NavLayerCurrent() NavLayer {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NavLayer(C.wrap_ImGuiWindowTempData_GetNavLayerCurrent(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetNavLayersActiveMask sets value of ImGuiWindowTempData.NavLayersActiveMask
//
// Which layers have been written to (result from previous frame)
func (self WindowTempData) SetNavLayersActiveMask(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavLayersActiveMask(selfArg, C.short(v))
}

// ImGuiWindowTempData_GetNavLayersActiveMask returns value of ImGuiWindowTempData.NavLayersActiveMask
//
// Which layers have been written to (result from previous frame)
func (self *WindowTempData) NavLayersActiveMask() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindowTempData_GetNavLayersActiveMask(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetNavLayersActiveMaskNext sets value of ImGuiWindowTempData.NavLayersActiveMaskNext
//
// Which layers have been written to (accumulator for current frame)
func (self WindowTempData) SetNavLayersActiveMaskNext(v int16) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavLayersActiveMaskNext(selfArg, C.short(v))
}

// ImGuiWindowTempData_GetNavLayersActiveMaskNext returns value of ImGuiWindowTempData.NavLayersActiveMaskNext
//
// Which layers have been written to (accumulator for current frame)
func (self *WindowTempData) NavLayersActiveMaskNext() int16 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int16(C.wrap_ImGuiWindowTempData_GetNavLayersActiveMaskNext(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetNavIsScrollPushableX sets value of ImGuiWindowTempData.NavIsScrollPushableX
//
// Set when current work location may be scrolled horizontally when moving left / right. This is generally always true UNLESS within a column.
func (self WindowTempData) SetNavIsScrollPushableX(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavIsScrollPushableX(selfArg, C.bool(v))
}

// ImGuiWindowTempData_GetNavIsScrollPushableX returns value of ImGuiWindowTempData.NavIsScrollPushableX
//
// Set when current work location may be scrolled horizontally when moving left / right. This is generally always true UNLESS within a column.
func (self *WindowTempData) NavIsScrollPushableX() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetNavIsScrollPushableX(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)) == C.bool(true)
}

// ImGuiWindowTempData_SetNavHideHighlightOneFrame sets value of ImGuiWindowTempData.NavHideHighlightOneFrame
func (self WindowTempData) SetNavHideHighlightOneFrame(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavHideHighlightOneFrame(selfArg, C.bool(v))
}

// ImGuiWindowTempData_GetNavHideHighlightOneFrame returns value of ImGuiWindowTempData.NavHideHighlightOneFrame
func (self *WindowTempData) NavHideHighlightOneFrame() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetNavHideHighlightOneFrame(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)) == C.bool(true)
}

// ImGuiWindowTempData_SetNavWindowHasScrollY sets value of ImGuiWindowTempData.NavWindowHasScrollY
//
// Set per window when scrolling can be used (== ScrollMax.y > 0.0f)
func (self WindowTempData) SetNavWindowHasScrollY(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetNavWindowHasScrollY(selfArg, C.bool(v))
}

// ImGuiWindowTempData_GetNavWindowHasScrollY returns value of ImGuiWindowTempData.NavWindowHasScrollY
//
// Set per window when scrolling can be used (== ScrollMax.y > 0.0f)
func (self *WindowTempData) NavWindowHasScrollY() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetNavWindowHasScrollY(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)) == C.bool(true)
}

// ImGuiWindowTempData_SetMenuBarAppending sets value of ImGuiWindowTempData.MenuBarAppending
//
//	// Miscellaneous
//
// FIXME: Remove this
func (self WindowTempData) SetMenuBarAppending(v bool) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetMenuBarAppending(selfArg, C.bool(v))
}

// ImGuiWindowTempData_GetMenuBarAppending returns value of ImGuiWindowTempData.MenuBarAppending
//
//	// Miscellaneous
//
// FIXME: Remove this
func (self *WindowTempData) MenuBarAppending() bool {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return C.wrap_ImGuiWindowTempData_GetMenuBarAppending(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)) == C.bool(true)
}

// ImGuiWindowTempData_SetMenuBarOffset sets value of ImGuiWindowTempData.MenuBarOffset
//
// MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
func (self WindowTempData) SetMenuBarOffset(v Vec2) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetMenuBarOffset(selfArg, internal.ReinterpretCast[C.ImVec2](v.ToC()))
}

// ImGuiWindowTempData_GetMenuBarOffset returns value of ImGuiWindowTempData.MenuBarOffset
//
// MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
func (self *WindowTempData) MenuBarOffset() Vec2 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return func() Vec2 {
		out := C.wrap_ImGuiWindowTempData_GetMenuBarOffset(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return *(&Vec2{}).FromC(unsafe.Pointer(&out))
	}()
}

// ImGuiWindowTempData_SetMenuColumns sets value of ImGuiWindowTempData.MenuColumns
//
// Simplified columns storage for menu items measurement
func (self WindowTempData) SetMenuColumns(v MenuColumns) {
	vArg, _ := v.C()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetMenuColumns(selfArg, internal.ReinterpretCast[C.ImGuiMenuColumns](vArg))
}

// ImGuiWindowTempData_GetMenuColumns returns value of ImGuiWindowTempData.MenuColumns
//
// Simplified columns storage for menu items measurement
func (self *WindowTempData) MenuColumns() MenuColumns {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return *NewMenuColumnsFromC(func() *C.ImGuiMenuColumns {
		result := C.wrap_ImGuiWindowTempData_GetMenuColumns(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg))
		return &result
	}())
}

// ImGuiWindowTempData_SetTreeDepth sets value of ImGuiWindowTempData.TreeDepth
//
// Current tree depth.
func (self WindowTempData) SetTreeDepth(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTreeDepth(selfArg, C.int(v))
}

// ImGuiWindowTempData_GetTreeDepth returns value of ImGuiWindowTempData.TreeDepth
//
// Current tree depth.
func (self *WindowTempData) TreeDepth() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindowTempData_GetTreeDepth(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetTreeHasStackDataDepthMask sets value of ImGuiWindowTempData.TreeHasStackDataDepthMask
//
// Store whether given depth has ImGuiTreeNodeStackData data. Could be turned into a ImU64 if necessary.
func (self WindowTempData) SetTreeHasStackDataDepthMask(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTreeHasStackDataDepthMask(selfArg, C.ImU32(v))
}

// ImGuiWindowTempData_GetTreeHasStackDataDepthMask returns value of ImGuiWindowTempData.TreeHasStackDataDepthMask
//
// Store whether given depth has ImGuiTreeNodeStackData data. Could be turned into a ImU64 if necessary.
func (self *WindowTempData) TreeHasStackDataDepthMask() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiWindowTempData_GetTreeHasStackDataDepthMask(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetStateStorage sets value of ImGuiWindowTempData.StateStorage
//
// Current persistent per-window storage (store e.g. tree node open/close state)
func (self WindowTempData) SetStateStorage(v *Storage) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetStateStorage(selfArg, internal.ReinterpretCast[*C.ImGuiStorage](vArg))
}

// ImGuiWindowTempData_GetStateStorage returns value of ImGuiWindowTempData.StateStorage
//
// Current persistent per-window storage (store e.g. tree node open/close state)
func (self *WindowTempData) StateStorage() *Storage {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewStorageFromC(C.wrap_ImGuiWindowTempData_GetStateStorage(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetCurrentColumns sets value of ImGuiWindowTempData.CurrentColumns
//
// Current columns set
func (self WindowTempData) SetCurrentColumns(v *OldColumns) {
	vArg, _ := v.Handle()

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrentColumns(selfArg, internal.ReinterpretCast[*C.ImGuiOldColumns](vArg))
}

// ImGuiWindowTempData_GetCurrentColumns returns value of ImGuiWindowTempData.CurrentColumns
//
// Current columns set
func (self *WindowTempData) CurrentColumns() *OldColumns {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return NewOldColumnsFromC(C.wrap_ImGuiWindowTempData_GetCurrentColumns(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetCurrentTableIdx sets value of ImGuiWindowTempData.CurrentTableIdx
//
// Current table index (into g.Tables)
func (self WindowTempData) SetCurrentTableIdx(v int32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetCurrentTableIdx(selfArg, C.int(v))
}

// ImGuiWindowTempData_GetCurrentTableIdx returns value of ImGuiWindowTempData.CurrentTableIdx
//
// Current table index (into g.Tables)
func (self *WindowTempData) CurrentTableIdx() int32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return int32(C.wrap_ImGuiWindowTempData_GetCurrentTableIdx(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetLayoutType sets value of ImGuiWindowTempData.LayoutType
func (self WindowTempData) SetLayoutType(v LayoutType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetLayoutType(selfArg, C.ImGuiLayoutType(v))
}

// ImGuiWindowTempData_GetLayoutType returns value of ImGuiWindowTempData.LayoutType
func (self *WindowTempData) LayoutType() LayoutType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return LayoutType(C.wrap_ImGuiWindowTempData_GetLayoutType(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetParentLayoutType sets value of ImGuiWindowTempData.ParentLayoutType
//
// Layout type of parent window at the time of Begin()
func (self WindowTempData) SetParentLayoutType(v LayoutType) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetParentLayoutType(selfArg, C.ImGuiLayoutType(v))
}

// ImGuiWindowTempData_GetParentLayoutType returns value of ImGuiWindowTempData.ParentLayoutType
//
// Layout type of parent window at the time of Begin()
func (self *WindowTempData) ParentLayoutType() LayoutType {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return LayoutType(C.wrap_ImGuiWindowTempData_GetParentLayoutType(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetModalDimBgColor sets value of ImGuiWindowTempData.ModalDimBgColor
func (self WindowTempData) SetModalDimBgColor(v uint32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetModalDimBgColor(selfArg, C.ImU32(v))
}

// ImGuiWindowTempData_GetModalDimBgColor returns value of ImGuiWindowTempData.ModalDimBgColor
func (self *WindowTempData) ModalDimBgColor() uint32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return uint32(C.wrap_ImGuiWindowTempData_GetModalDimBgColor(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetItemWidth sets value of ImGuiWindowTempData.ItemWidth
//
//	// Local parameters stacks
//	// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
//
// Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).
func (self WindowTempData) SetItemWidth(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetItemWidth(selfArg, C.float(v))
}

// ImGuiWindowTempData_GetItemWidth returns value of ImGuiWindowTempData.ItemWidth
//
//	// Local parameters stacks
//	// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
//
// Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).
func (self *WindowTempData) ItemWidth() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetItemWidth(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetTextWrapPos sets value of ImGuiWindowTempData.TextWrapPos
//
// Current text wrap pos.
func (self WindowTempData) SetTextWrapPos(v float32) {
	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTextWrapPos(selfArg, C.float(v))
}

// ImGuiWindowTempData_GetTextWrapPos returns value of ImGuiWindowTempData.TextWrapPos
//
// Current text wrap pos.
func (self *WindowTempData) TextWrapPos() float32 {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_ImGuiWindowTempData_GetTextWrapPos(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)))
}

// ImGuiWindowTempData_SetItemWidthStack sets value of ImGuiWindowTempData.ItemWidthStack
//
// Store item widths to restore (attention: .back() is not == ItemWidth)
func (self WindowTempData) SetItemWidthStack(v vectors.Vector[float32]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetItemWidthStack(selfArg, *vVecArg)
}

// ImGuiWindowTempData_GetItemWidthStack returns value of ImGuiWindowTempData.ItemWidthStack
//
// Store item widths to restore (attention: .back() is not == ItemWidth)
func (self *WindowTempData) ItemWidthStack() vectors.Vector[float32] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiWindowTempData_GetItemWidthStack(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)).Size, C.wrap_ImGuiWindowTempData_GetItemWidthStack(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)).Capacity, (*float32)(C.wrap_ImGuiWindowTempData_GetItemWidthStack(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)).Data))
}

// ImGuiWindowTempData_SetTextWrapPosStack sets value of ImGuiWindowTempData.TextWrapPosStack
//
// Store text wrap pos to restore (attention: .back() is not == TextWrapPos)
func (self WindowTempData) SetTextWrapPosStack(v vectors.Vector[float32]) {
	vData := v.Data
	vDataArg, _ := internal.WrapNumberPtr[C.float, float32](vData)
	vVecArg := new(C.ImVector_float)
	vVecArg.Size = C.int(v.Size)
	vVecArg.Capacity = C.int(v.Capacity)
	vVecArg.Data = vDataArg
	v.Pinner().Pin(vVecArg.Data)

	selfArg, selfFin := self.Handle()
	defer selfFin()
	C.wrap_ImGuiWindowTempData_SetTextWrapPosStack(selfArg, *vVecArg)
}

// ImGuiWindowTempData_GetTextWrapPosStack returns value of ImGuiWindowTempData.TextWrapPosStack
//
// Store text wrap pos to restore (attention: .back() is not == TextWrapPos)
func (self *WindowTempData) TextWrapPosStack() vectors.Vector[float32] {
	selfArg, selfFin := self.Handle()

	defer func() {
		selfFin()
	}()
	return vectors.NewVectorFromC(C.wrap_ImGuiWindowTempData_GetTextWrapPosStack(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)).Size, C.wrap_ImGuiWindowTempData_GetTextWrapPosStack(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)).Capacity, (*float32)(C.wrap_ImGuiWindowTempData_GetTextWrapPosStack(internal.ReinterpretCast[*C.ImGuiWindowTempData](selfArg)).Data))
}
