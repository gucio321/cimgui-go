// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include "extra_types.h"
// #include "cimguizmo_structs_accessor.h"
// #include "cimguizmo_wrapper.h"
import "C"

func GizmozmoAllowAxisFlip(value bool) {
	C.ImGuizmo_AllowAxisFlip(C.bool(value))
}

func GizmozmoBeginFrame() {
	C.ImGuizmo_BeginFrame()
}

func GizmozmoDecomposeMatrixToComponents(matrix []float32, translation *float32, rotation *float32, scale *float32) {
	translationArg, translationFin := WrapNumberPtr[C.float, float32](translation)
	rotationArg, rotationFin := WrapNumberPtr[C.float, float32](rotation)
	scaleArg, scaleFin := WrapNumberPtr[C.float, float32](scale)
	C.ImGuizmo_DecomposeMatrixToComponents((*C.float)(&(matrix[0])), translationArg, rotationArg, scaleArg)

	translationFin()
	rotationFin()
	scaleFin()
}

func GizmozmoDrawCubes(view []float32, projection []float32, matrices []float32, matrixCount int32) {
	C.ImGuizmo_DrawCubes((*C.float)(&(view[0])), (*C.float)(&(projection[0])), (*C.float)(&(matrices[0])), C.int(matrixCount))
}

func GizmozmoDrawGrid(view []float32, projection []float32, matrix []float32, gridSize float32) {
	C.ImGuizmo_DrawGrid((*C.float)(&(view[0])), (*C.float)(&(projection[0])), (*C.float)(&(matrix[0])), C.float(gridSize))
}

func GizmozmoEnable(enable bool) {
	C.ImGuizmo_Enable(C.bool(enable))
}

func GizmozmoGetStyle() *GizmoStyle {
	return newGizmoStyleFromC(C.ImGuizmo_GetStyle())
}

func GizmozmoIsOver() bool {
	return C.ImGuizmo_IsOver_Nil() == C.bool(true)
}

func GizmozmoIsOverOPERATION(op GizmoOPERATION) bool {
	return C.ImGuizmo_IsOver_OPERATION(C.OPERATION(op)) == C.bool(true)
}

func GizmozmoIsUsing() bool {
	return C.ImGuizmo_IsUsing() == C.bool(true)
}

func GizmozmoIsUsingAny() bool {
	return C.ImGuizmo_IsUsingAny() == C.bool(true)
}

// GizmozmoManipulateV parameter default value hint:
// deltaMatrix: NULL
// snap: NULL
// localBounds: NULL
// boundsSnap: NULL
func GizmozmoManipulateV(view []float32, projection []float32, operation GizmoOPERATION, mode GizmoMODE, matrix *float32, deltaMatrix *float32, snap []float32, localBounds []float32, boundsSnap []float32) bool {
	matrixArg, matrixFin := WrapNumberPtr[C.float, float32](matrix)
	deltaMatrixArg, deltaMatrixFin := WrapNumberPtr[C.float, float32](deltaMatrix)

	defer func() {
		matrixFin()
		deltaMatrixFin()
	}()
	return C.ImGuizmo_Manipulate((*C.float)(&(view[0])), (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg, deltaMatrixArg, (*C.float)(&(snap[0])), (*C.float)(&(localBounds[0])), (*C.float)(&(boundsSnap[0]))) == C.bool(true)
}

func GizmozmoRecomposeMatrixFromComponents(translation []float32, rotation []float32, scale []float32, matrix *float32) {
	matrixArg, matrixFin := WrapNumberPtr[C.float, float32](matrix)
	C.ImGuizmo_RecomposeMatrixFromComponents((*C.float)(&(translation[0])), (*C.float)(&(rotation[0])), (*C.float)(&(scale[0])), matrixArg)

	matrixFin()
}

func GizmozmoSetAxisLimit(value float32) {
	C.ImGuizmo_SetAxisLimit(C.float(value))
}

func GizmozmoSetGizmoSizeClipSpace(value float32) {
	C.ImGuizmo_SetGizmoSizeClipSpace(C.float(value))
}

func GizmozmoSetID(id int32) {
	C.ImGuizmo_SetID(C.int(id))
}

func GizmozmoSetOrthographic(isOrthographic bool) {
	C.ImGuizmo_SetOrthographic(C.bool(isOrthographic))
}

func GizmozmoSetPlaneLimit(value float32) {
	C.ImGuizmo_SetPlaneLimit(C.float(value))
}

func GizmozmoSetRect(x float32, y float32, width float32, height float32) {
	C.ImGuizmo_SetRect(C.float(x), C.float(y), C.float(width), C.float(height))
}

func GizmozmoViewManipulateFloat(view *float32, length float32, position Vec2, size Vec2, backgroundColor uint32) {
	viewArg, viewFin := WrapNumberPtr[C.float, float32](view)
	C.ImGuizmo_ViewManipulate_Float(viewArg, C.float(length), position.toC(), size.toC(), C.ImU32(backgroundColor))

	viewFin()
}

func GizmozmoViewManipulateFloatPtr(view *float32, projection []float32, operation GizmoOPERATION, mode GizmoMODE, matrix *float32, length float32, position Vec2, size Vec2, backgroundColor uint32) {
	viewArg, viewFin := WrapNumberPtr[C.float, float32](view)
	matrixArg, matrixFin := WrapNumberPtr[C.float, float32](matrix)
	C.ImGuizmo_ViewManipulate_FloatPtr(viewArg, (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg, C.float(length), position.toC(), size.toC(), C.ImU32(backgroundColor))

	viewFin()
	matrixFin()
}

func GizmoNewStyle() *GizmoStyle {
	return newGizmoStyleFromC(C.Style_Style())
}

func (self *GizmoStyle) GizmoDestroy() {
	selfArg, selfFin := self.handle()
	C.Style_destroy(selfArg)

	selfFin()
}

func GizmozmoManipulate(view []float32, projection []float32, operation GizmoOPERATION, mode GizmoMODE, matrix *float32) bool {
	matrixArg, matrixFin := WrapNumberPtr[C.float, float32](matrix)

	defer func() {
		matrixFin()
	}()
	return C.wrap_ImGuizmo_Manipulate((*C.float)(&(view[0])), (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg) == C.bool(true)
}

func GizmozmoSetDrawlist() {
	C.wrap_ImGuizmo_SetDrawlist()
}

func (self GizmoStyle) GizmoSetTranslationLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetTranslationLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoTranslationLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetTranslationLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetTranslationLineArrowSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetTranslationLineArrowSize(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoTranslationLineArrowSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetTranslationLineArrowSize(selfArg))
}

func (self GizmoStyle) GizmoSetRotationLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetRotationLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoRotationLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetRotationLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetRotationOuterLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetRotationOuterLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoRotationOuterLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetRotationOuterLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetScaleLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetScaleLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoScaleLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetScaleLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetScaleLineCircleSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetScaleLineCircleSize(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoScaleLineCircleSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetScaleLineCircleSize(selfArg))
}

func (self GizmoStyle) GizmoSetHatchedAxisLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetHatchedAxisLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoHatchedAxisLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetHatchedAxisLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetCenterCircleSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetCenterCircleSize(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoCenterCircleSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetCenterCircleSize(selfArg))
}

func (self GizmoStyle) GizmoSetColors(v *[15]Vec4) {
	vArg := make([]C.ImVec4, len(v))
	for i, vV := range v {
		vArg[i] = vV.toC()
	}

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetColors(selfArg, (*C.ImVec4)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = *(&Vec4{}).fromC(vV)
	}
}

func (self *GizmoStyle) GizmoColors() [15]Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return func() [15]Vec4 {
		result := [15]Vec4{}
		resultMirr := C.wrap_Style_GetColors(selfArg)
		for i := range result {
			result[i] = *(&Vec4{}).fromC(C.cimguizmo_ImVec4_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}
