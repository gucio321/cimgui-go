// Code generated by cmd/codegen from https://github.com/AllenDang/cimgui-go.
// DO NOT EDIT.

package imgui

// #include "extra_types.h"
// #include "cimguizmo_structs_accessor.h"
// #include "cimguizmo_wrapper.h"
import "C"

func GizmoAllowAxisFlip(value bool) {
	C.AllowAxisFlip(C.bool(value))
}

func GizmoBeginFrame() {
	C.BeginFrame()
}

func GizmoDecomposeMatrixToComponents(matrix []float32, translation *float32, rotation *float32, scale *float32) {
	translationArg, translationFin := WrapNumberPtr[C.float, float32](translation)
	rotationArg, rotationFin := WrapNumberPtr[C.float, float32](rotation)
	scaleArg, scaleFin := WrapNumberPtr[C.float, float32](scale)
	C.DecomposeMatrixToComponents((*C.float)(&(matrix[0])), translationArg, rotationArg, scaleArg)

	translationFin()
	rotationFin()
	scaleFin()
}

func GizmoDrawCubes(view []float32, projection []float32, matrices []float32, matrixCount int32) {
	C.DrawCubes((*C.float)(&(view[0])), (*C.float)(&(projection[0])), (*C.float)(&(matrices[0])), C.int(matrixCount))
}

func GizmoDrawGrid(view []float32, projection []float32, matrix []float32, gridSize float32) {
	C.DrawGrid((*C.float)(&(view[0])), (*C.float)(&(projection[0])), (*C.float)(&(matrix[0])), C.float(gridSize))
}

func GizmoEnable(enable bool) {
	C.Enable(C.bool(enable))
}

func GizmoStyle() *GizmoStyle {
	return newGizmoStyleFromC(C.GetStyle())
}

func GizmoIsOver() bool {
	return C.IsOver() == C.bool(true)
}

func GizmoIsUsing() bool {
	return C.IsUsing() == C.bool(true)
}

func GizmoIsUsingAny() bool {
	return C.IsUsingAny() == C.bool(true)
}

// GizmoManipulateV parameter default value hint:
// deltaMatrix: NULL
// snap: NULL
// localBounds: NULL
// boundsSnap: NULL
func GizmoManipulateV(view []float32, projection []float32, operation GizmoOPERATION, mode GizmoMODE, matrix *float32, deltaMatrix *float32, snap []float32, localBounds []float32, boundsSnap []float32) bool {
	matrixArg, matrixFin := WrapNumberPtr[C.float, float32](matrix)
	deltaMatrixArg, deltaMatrixFin := WrapNumberPtr[C.float, float32](deltaMatrix)

	defer func() {
		matrixFin()
		deltaMatrixFin()
	}()
	return C.Manipulate((*C.float)(&(view[0])), (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg, deltaMatrixArg, (*C.float)(&(snap[0])), (*C.float)(&(localBounds[0])), (*C.float)(&(boundsSnap[0]))) == C.bool(true)
}

func GizmoRecomposeMatrixFromComponents(translation []float32, rotation []float32, scale []float32, matrix *float32) {
	matrixArg, matrixFin := WrapNumberPtr[C.float, float32](matrix)
	C.RecomposeMatrixFromComponents((*C.float)(&(translation[0])), (*C.float)(&(rotation[0])), (*C.float)(&(scale[0])), matrixArg)

	matrixFin()
}

func GizmoSetAxisLimit(value float32) {
	C.SetAxisLimit(C.float(value))
}

func GizmoSetGizmoSizeClipSpace(value float32) {
	C.SetGizmoSizeClipSpace(C.float(value))
}

func GizmoSetID(id int32) {
	C.SetID(C.int(id))
}

func GizmoSetOrthographic(isOrthographic bool) {
	C.SetOrthographic(C.bool(isOrthographic))
}

func GizmoSetPlaneLimit(value float32) {
	C.SetPlaneLimit(C.float(value))
}

func GizmoSetRect(x float32, y float32, width float32, height float32) {
	C.SetRect(C.float(x), C.float(y), C.float(width), C.float(height))
}

func GizmoNewStyle() *GizmoStyle {
	return newGizmoStyleFromC(C.Style_Style())
}

func (self *GizmoStyle) GizmoDestroy() {
	selfArg, selfFin := self.handle()
	C.Style_destroy(selfArg)

	selfFin()
}

func GizmoViewManipulate(view *float32, length float32, position Vec2, size Vec2, backgroundColor uint32) {
	viewArg, viewFin := WrapNumberPtr[C.float, float32](view)
	C.ViewManipulate(viewArg, C.float(length), position.toC(), size.toC(), C.ImU32(backgroundColor))

	viewFin()
}

func GizmoManipulate(view []float32, projection []float32, operation GizmoOPERATION, mode GizmoMODE, matrix *float32) bool {
	matrixArg, matrixFin := WrapNumberPtr[C.float, float32](matrix)

	defer func() {
		matrixFin()
	}()
	return C.wrap_Manipulate((*C.float)(&(view[0])), (*C.float)(&(projection[0])), C.OPERATION(operation), C.MODE(mode), matrixArg) == C.bool(true)
}

func GizmoSetDrawlist() {
	C.wrap_SetDrawlist()
}

func (self GizmoStyle) GizmoSetTranslationLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetTranslationLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoTranslationLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetTranslationLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetTranslationLineArrowSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetTranslationLineArrowSize(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoTranslationLineArrowSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetTranslationLineArrowSize(selfArg))
}

func (self GizmoStyle) GizmoSetRotationLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetRotationLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoRotationLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetRotationLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetRotationOuterLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetRotationOuterLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoRotationOuterLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetRotationOuterLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetScaleLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetScaleLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoScaleLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetScaleLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetScaleLineCircleSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetScaleLineCircleSize(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoScaleLineCircleSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetScaleLineCircleSize(selfArg))
}

func (self GizmoStyle) GizmoSetHatchedAxisLineThickness(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetHatchedAxisLineThickness(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoHatchedAxisLineThickness() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetHatchedAxisLineThickness(selfArg))
}

func (self GizmoStyle) GizmoSetCenterCircleSize(v float32) {
	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetCenterCircleSize(selfArg, C.float(v))
}

func (self *GizmoStyle) GizmoCenterCircleSize() float32 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return float32(C.wrap_Style_GetCenterCircleSize(selfArg))
}

func (self GizmoStyle) GizmoSetColors(v *[15]Vec4) {
	vArg := make([]C.ImVec4, len(v))
	for i, vV := range v {
		vArg[i] = vV.toC()
	}

	selfArg, selfFin := self.handle()
	defer selfFin()
	C.wrap_Style_SetColors(selfArg, (*C.ImVec4)(&vArg[0]))

	for i, vV := range vArg {
		(*v)[i] = *(&Vec4{}).fromC(vV)
	}
}

func (self *GizmoStyle) GizmoColors() [15]Vec4 {
	selfArg, selfFin := self.handle()

	defer func() {
		selfFin()
	}()
	return func() [15]Vec4 {
		result := [15]Vec4{}
		resultMirr := C.wrap_Style_GetColors(selfArg)
		for i := range result {
			result[i] = *(&Vec4{}).fromC(C.cimguizmo_ImVec4_GetAtIdx(resultMirr, C.int(i)))
		}

		return result
	}()
}
